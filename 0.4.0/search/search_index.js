var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Harmony Integration","text":""},{"location":"index.html#implemented-functionality","title":"Implemented functionality:","text":"<ul> <li>workfile management</li> <li>creators for:</li> <li>render - locally/farm</li> <li>palette - automatic during collection</li> <li>template - group of nodes wrapped in Backdrop</li> <li>loaders for:</li> <li>audio</li> <li>background - json file and list of images</li> <li>image sequences</li> <li>palette</li> <li>template</li> <li>whole Harmony workfile</li> </ul> <p>It should reasonably support even Harmony Advanced (without Node View) - templates will not work as it is required to wrap nodes that should be in a template which is not possible without Node View.</p>"},{"location":"index.html#setup","title":"Setup","text":"<p>The easiest way to setup for using Toon Boom Harmony is to use the built-in launch:</p> <pre><code>python -c \"import ayon_harmony.api as harmony;harmony.launch(\"path/to/harmony/executable\")\"\n</code></pre> <p>Communication with Harmony happens with a server/client relationship where the server is in the Python process and the client is in the Harmony process. Messages between Python and Harmony are required to be dictionaries, which are serialized to strings:</p> <pre><code>+------------+\n|            |\n|   Python   |\n|   Process  |\n|            |\n| +--------+ |\n| |        | |\n| |  Main  | |\n| | Thread | |\n| |        | |\n| +----^---+ |\n|     ||     |\n|     ||     |\n| +---v----+ |     +---------+\n| |        | |     |         |\n| | Server +-------&gt; Harmony |\n| | Thread &lt;-------+ Process |\n| |        | |     |         |\n| +--------+ |     +---------+\n+------------+\n</code></pre> <p>Server/client now uses stricter protocol to handle communication. This is necessary because of precise control over data passed between server/client. Each message is prepended with 6 bytes:</p> <pre><code>| A | H | 0x00 | 0x00 | 0x00 | 0x00 | ...\n\n</code></pre> <p>First two bytes are magic bytes stands for Ayon Harmony. Next four bytes hold length of the message <code>...</code> encoded as 32bit unsigned integer. This way we know how many bytes to read from the socket and if we need more or we need to parse multiple messages.</p>"},{"location":"index.html#usage","title":"Usage","text":"<p>The integration creates an <code>AYON</code> menu entry where all related tools are located.</p> <p>NOTE: Menu creation can be temperamental. The best way is to launch Harmony and do nothing else until Harmony is fully launched.</p>"},{"location":"index.html#work-files","title":"Work files","text":"<p>Because Harmony projects are directories, this integration uses <code>.zip</code> as work file extension. Internally the project directories are stored under <code>[User]/.ayon/harmony</code>. Whenever the user saves the <code>.xstage</code> file, the integration zips up the project directory and moves it to the AYON project path. Zipping and moving happens in the background.</p>"},{"location":"index.html#show-workfiles-on-launch","title":"Show Workfiles on launch","text":"<p>You can show the Workfiles app when Harmony launches by setting environment variable <code>AYON_HARMONY_WORKFILES_ON_LAUNCH=1</code>.</p>"},{"location":"index.html#developing","title":"Developing","text":""},{"location":"index.html#low-level-messaging","title":"Low level messaging","text":"<p>To send from Python to Harmony you can use the exposed method:</p> <pre><code>import ayon_harmony.api as harmony\nfrom uuid import uuid4\n\n\nfunc = \"\"\"function %s_hello(person)\n{\n  return (\"Hello \" + person + \"!\");\n}\n%s_hello\n\"\"\" % (uuid4(), uuid4())\nprint(harmony.send({\"function\": func, \"args\": [\"Python\"]})[\"result\"])\n</code></pre> <p>NOTE: Its important to declare the function at the end of the function string. You can have multiple functions within your function string, but the function declared at the end is what gets executed.</p> <p>To send a function with multiple arguments its best to declare the arguments within the function:</p> <pre><code>import ayon_harmony.api as harmony\nfrom uuid import uuid4\n\nsignature = str(uuid4()).replace(\"-\", \"_\")\nfunc = \"\"\"function %s_hello(args)\n{\n  var greeting = args[0];\n  var person = args[1];\n  return (greeting + \" \" + person + \"!\");\n}\n%s_hello\n\"\"\" % (signature, signature)\nprint(harmony.send({\"function\": func, \"args\": [\"Hello\", \"Python\"]})[\"result\"])\n</code></pre>"},{"location":"index.html#caution","title":"Caution","text":"<p>When naming your functions be aware that they are executed in global scope. They can potentially clash with Harmony own function and object names. For example <code>func</code> is already existing Harmony object. When you call your function <code>func</code> it will overwrite in global scope the one from Harmony, causing erratic behavior of Harmony. AYON is prefixing those function names with UUID4 making chance of such clash minimal. See above examples how that works. This will result in function named <code>38dfcef0_a6d7_4064_8069_51fe99ab276e_hello()</code>. You can find list of Harmony object and function in Harmony documentation.</p>"},{"location":"index.html#higher-level-recommended","title":"Higher level (recommended)","text":"<p>Instead of sending functions directly to Harmony, it is more efficient and safe to just add your code to <code>js/AyonHarmony.js</code> or utilize <code>{\"script\": \"...\"}</code> method.</p>"},{"location":"index.html#extending-ayonharmonyjs","title":"Extending AyonHarmony.js","text":"<p>Add your function to <code>AyonHarmony.js</code>. For example:</p> <pre><code>AyonHarmony.myAwesomeFunction = function() {\n  someCoolStuff();\n};\n</code></pre> <p>Then you can call that javascript code from your Python like:</p> <pre><code>import ayon_harmony.api as harmony\n\nharmony.send({\"function\": \"AyonHarmony.myAwesomeFunction\"});\n\n</code></pre>"},{"location":"index.html#using-script-method","title":"Using Script method","text":"<p>You can also pass whole scripts into harmony and call their functions later as needed.</p> <p>For example, you have bunch of javascript files:</p> <pre><code>/* Master.js */\n\nvar Master = {\n  Foo = {};\n  Boo = {};\n};\n\n/* FileA.js */\nvar Foo = function() {};\n\nFoo.prototype.A = function() {\n  someAStuff();\n}\n\n// This will construct object Foo and add it to Master namespace.\nMaster.Foo = new Foo();\n\n/* FileB.js */\nvar Boo = function() {};\n\nBoo.prototype.B = function() {\n  someBStuff();\n}\n\n// This will construct object Boo and add it to Master namespace.\nMaster.Boo = new Boo();\n</code></pre> <p>Now in python, just read all those files and send them to Harmony.</p> <pre><code>from pathlib import Path\nimport ayon_harmony.api as harmony\n\npath_to_js = Path('/path/to/my/js')\nscript_to_send = \"\"\n\nfor file in path_to_js.iterdir():\n  if file.suffix == \".js\":\n    script_to_send += file.read_text()\n\nharmony.send({\"script\": script_to_send})\n\n# and use your code in Harmony\nharmony.send({\"function\": \"Master.Boo.B\"})\n\n</code></pre>"},{"location":"index.html#scene-save","title":"Scene Save","text":"<p>Instead of sending a request to Harmony with <code>scene.saveAll</code> please use:</p> <pre><code>import ayon_harmony.api as harmony\nharmony.save_scene()\n</code></pre> Click to expand for details on scene save.    Because AYON tools do not deal well with folders for a single entity like a Harmony scene, this integration has implemented to use zip files to encapsulate the Harmony scene folders. Saving scene in Harmony via menu or CTRL+S will not result in producing zip file, only saving it from Workfiles will. This is because   zipping process can take some time in which we cannot block user from saving again. If xstage file is changed during zipping process it will produce corrupted zip   archive."},{"location":"index.html#resources","title":"Resources","text":"<ul> <li>https://github.com/diegogarciahuerta/tk-harmony</li> <li>https://github.com/cfourney/OpenHarmony</li> <li>Toon Boom Discord</li> <li>Toon Boom TD</li> </ul>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_harmony<ul> <li>addon</li> <li>api<ul> <li>launch_script</li> <li>lib</li> <li>pipeline</li> <li>plugin</li> <li>server</li> <li>workio</li> </ul> </li> <li>hooks<ul> <li>pre_launch_args</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>convert_legacy</li> <li>create_render</li> <li>create_template</li> <li>create_workfile</li> </ul> </li> <li>load<ul> <li>load_audio</li> <li>load_background</li> <li>load_imagesequence</li> <li>load_palette</li> <li>load_template</li> <li>load_template_workfile</li> </ul> </li> <li>publish<ul> <li>collect_audio</li> <li>collect_current_file</li> <li>collect_farm_render</li> <li>collect_instances</li> <li>collect_palettes</li> <li>collect_scene</li> <li>extract_palette</li> <li>extract_render</li> <li>extract_save_scene</li> <li>extract_template</li> <li>extract_workfile</li> <li>increment_workfile</li> <li>validate_audio</li> <li>validate_instances</li> <li>validate_scene_settings</li> </ul> </li> </ul> </li> <li>vendor<ul> <li>OpenHarmony<ul> <li>openHarmony</li> <li>reference</li> <li>tools<ul> <li>OpenHarmony_basic</li> </ul> </li> </ul> </li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>creator_plugins</li> <li>imageio</li> <li>main</li> <li>publish_plugins</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_harmony/index.html","title":"ayon_harmony","text":""},{"location":"autoapi/client/ayon_harmony/index.html#client.ayon_harmony.HarmonyAddon","title":"<code>HarmonyAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_harmony/addon.py</code> <pre><code>class HarmonyAddon(AYONAddon, IHostAddon):\n    name = \"harmony\"\n    version = __version__\n    host_name = \"harmony\"\n\n    def add_implementation_envs(self, env, _app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n        openharmony_path = os.path.join(\n            HARMONY_ADDON_ROOT, \"vendor\", \"OpenHarmony\"\n        )\n        # TODO check if is already set? What to do if is already set?\n        env[\"LIB_OPENHARMONY_PATH\"] = openharmony_path\n\n    def get_workfile_extensions(self):\n        return [\".zip\"]\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(HARMONY_ADDON_ROOT, \"hooks\")\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/index.html#client.ayon_harmony.HarmonyAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_harmony/addon.py</code> <pre><code>def add_implementation_envs(self, env, _app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n    openharmony_path = os.path.join(\n        HARMONY_ADDON_ROOT, \"vendor\", \"OpenHarmony\"\n    )\n    # TODO check if is already set? What to do if is already set?\n    env[\"LIB_OPENHARMONY_PATH\"] = openharmony_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_harmony/addon.html#client.ayon_harmony.addon.HarmonyAddon","title":"<code>HarmonyAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_harmony/addon.py</code> <pre><code>class HarmonyAddon(AYONAddon, IHostAddon):\n    name = \"harmony\"\n    version = __version__\n    host_name = \"harmony\"\n\n    def add_implementation_envs(self, env, _app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n        openharmony_path = os.path.join(\n            HARMONY_ADDON_ROOT, \"vendor\", \"OpenHarmony\"\n        )\n        # TODO check if is already set? What to do if is already set?\n        env[\"LIB_OPENHARMONY_PATH\"] = openharmony_path\n\n    def get_workfile_extensions(self):\n        return [\".zip\"]\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(HARMONY_ADDON_ROOT, \"hooks\")\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/addon.html#client.ayon_harmony.addon.HarmonyAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_harmony/addon.py</code> <pre><code>def add_implementation_envs(self, env, _app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n    openharmony_path = os.path.join(\n        HARMONY_ADDON_ROOT, \"vendor\", \"OpenHarmony\"\n    )\n    # TODO check if is already set? What to do if is already set?\n    env[\"LIB_OPENHARMONY_PATH\"] = openharmony_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/version.html","title":"version","text":"<p>Package declaring AYON addon 'harmony' version.</p>"},{"location":"autoapi/client/ayon_harmony/api/index.html","title":"api","text":"<p>Public API</p> <p>Anything that isn't defined here is INTERNAL and unreliable for external use.</p>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.HarmonyHost","title":"<code>HarmonyHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>class HarmonyHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"harmony\"\n\n    _context_key = \"AYON_context\"\n\n    def install(self):\n        \"\"\"Install Pype as host config.\"\"\"\n        print(\"Installing AYON Harmony Host ...\")\n\n        pyblish.api.register_host(\"harmony\")\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n\n        register_event_callback(\"application.launched\", application_launch)\n\n    def uninstall(self):\n        pyblish.api.deregister_plugin_path(PUBLISH_PATH)\n        deregister_loader_plugin_path(LOAD_PATH)\n        deregister_creator_plugin_path(CREATE_PATH)\n\n    def open_workfile(self, filepath):\n        return open_file(filepath)\n\n    def save_workfile(self, filepath=None):\n        return save_file(filepath)\n\n    def work_root(self, session):\n        return work_root(session)\n\n    def get_current_workfile(self):\n        return current_file()\n\n    def workfile_has_unsaved_changes(self):\n        return has_unsaved_changes()\n\n    def get_workfile_extensions(self):\n        return file_extensions()\n\n    def get_containers(self):\n        return ls()\n\n    def get_context_data(self):\n        return get_scene_data().get(self._context_key, {})\n\n    def update_context_data(self, data, changes):\n        scene_data = get_scene_data()\n        context_data = scene_data.setdefault(self._context_key, {})\n        context_data.update(data)\n        set_scene_data(scene_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.HarmonyHost.install","title":"<code>install()</code>","text":"<p>Install Pype as host config.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Install Pype as host config.\"\"\"\n    print(\"Installing AYON Harmony Host ...\")\n\n    pyblish.api.register_host(\"harmony\")\n    pyblish.api.register_plugin_path(PUBLISH_PATH)\n    register_loader_plugin_path(LOAD_PATH)\n    register_creator_plugin_path(CREATE_PATH)\n\n    register_event_callback(\"application.launched\", application_launch)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.application_launch","title":"<code>application_launch(event)</code>","text":"<p>Event that is executed after Harmony is launched.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def application_launch(event):\n    \"\"\"Event that is executed after Harmony is launched.\"\"\"\n    # fills AYON_HARMONY_JS\n    ayon_harmony_path = Path(__file__).parent.parent / \"js\" / \"AyonHarmony.js\"\n    ayon_harmony_js = ayon_harmony_path.read_text()\n\n    # go through js/creators, loaders and publish folders and load all scripts\n    script = \"\"\n    for item in [\"creators\", \"loaders\", \"publish\"]:\n        dir_to_scan = Path(__file__).parent.parent / \"js\" / item\n        for child in dir_to_scan.iterdir():\n            script += child.read_text()\n\n    # send scripts to Harmony\n    harmony.send({\"script\": ayon_harmony_js})\n    harmony.send({\"script\": script})\n    inject_ayon_js()\n\n    # ensure_scene_settings()\n    check_inventory()\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.check_inventory","title":"<code>check_inventory()</code>","text":"<p>Check is scene contains outdated containers.</p> <p>If it does it will colorize outdated nodes and display warning message in Harmony.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def check_inventory():\n    \"\"\"Check is scene contains outdated containers.\n\n    If it does it will colorize outdated nodes and display warning message\n    in Harmony.\n    \"\"\"\n\n    outdated_containers = get_outdated_containers()\n    if not outdated_containers:\n        return\n\n    # Colour nodes.\n    outdated_nodes = []\n    for container in outdated_containers:\n        if container[\"loader\"] == \"ImageSequenceLoader\":\n            outdated_nodes.append(\n                harmony.find_node_by_name(container[\"name\"], \"READ\")\n            )\n    harmony.send({\"function\": \"AyonHarmony.setColor\", \"args\": outdated_nodes})\n\n    # Warn about outdated containers.\n    msg = \"There are outdated containers in the scene.\"\n    harmony.send({\"function\": \"AyonHarmony.message\", \"args\": msg})\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.containerise","title":"<code>containerise(name, namespace, node, context, loader=None, suffix=None, nodes=None)</code>","text":"<p>Imprint node with metadata.</p> <p>Containerisation enables a tracking of version, author and origin for loaded product representations.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly.</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container.</p> required <code>node</code> <code>str</code> <p>Node to containerise.</p> required <code>context</code> <code>dict</code> <p>Loaded representation full context information.</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>container</code> <code>str</code> <p>Path of container assembly.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def containerise(name,\n                 namespace,\n                 node,\n                 context,\n                 loader=None,\n                 suffix=None,\n                 nodes=None):\n    \"\"\"Imprint node with metadata.\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded product representations.\n\n    Arguments:\n        name (str): Name of resulting assembly.\n        namespace (str): Namespace under which to host container.\n        node (str): Node to containerise.\n        context (dict): Loaded representation full context information.\n        loader (str, optional): Name of loader used to produce this container.\n        suffix (str, optional): Suffix of container, defaults to `_CON`.\n\n    Returns:\n        container (str): Path of container assembly.\n    \"\"\"\n    if not nodes:\n        nodes = []\n\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace,\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"nodes\": nodes\n    }\n\n    harmony.imprint(node, data)\n\n    return node\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.current_file","title":"<code>current_file()</code>","text":"<p>Returning None to make Workfiles app look at first file extension.</p> Source code in <code>client/ayon_harmony/api/workio.py</code> <pre><code>def current_file():\n    \"\"\"Returning None to make Workfiles app look at first file extension.\"\"\"\n    return ProcessContext.workfile_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.delete_node","title":"<code>delete_node(node)</code>","text":"<p>Physically delete node from scene.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def delete_node(node):\n    \"\"\" Physically delete node from scene. \"\"\"\n    send(\n        {\n            \"function\": \"AyonHarmonyAPI.deleteNode\",\n            \"args\": node\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.ensure_scene_settings","title":"<code>ensure_scene_settings()</code>","text":"<p>Validate if Harmony scene has valid settings.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def ensure_scene_settings():\n    \"\"\"Validate if Harmony scene has valid settings.\"\"\"\n    settings = get_current_context_settings()\n\n    invalid_settings = []\n    valid_settings = {}\n    for key, value in settings.items():\n        if value is None:\n            invalid_settings.append(key)\n        else:\n            valid_settings[key] = value\n\n    # Warn about missing attributes.\n    if invalid_settings:\n        msg = \"Missing attributes:\"\n        for item in invalid_settings:\n            msg += f\"\\n{item}\"\n\n        harmony.send(\n            {\"function\": \"AyonHarmony.message\", \"args\": msg})\n\n    set_scene_settings(valid_settings)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.export_backdrop_as_template","title":"<code>export_backdrop_as_template(backdrop, filepath)</code>","text":"<p>Export Backdrop as Template (.tpl) file.</p> <p>Parameters:</p> Name Type Description Default <code>backdrop</code> <code>list</code> <p>Backdrop to export.</p> required <code>filepath</code> <code>str</code> <p>Path where to save Template.</p> required Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def export_backdrop_as_template(backdrop, filepath):\n    \"\"\"Export Backdrop as Template (.tpl) file.\n\n    Args:\n        backdrop (list): Backdrop to export.\n        filepath (str): Path where to save Template.\n    \"\"\"\n    harmony.send({\n        \"function\": \"AyonHarmony.exportBackdropAsTemplate\",\n        \"args\": [\n            backdrop,\n            os.path.basename(filepath),\n            os.path.dirname(filepath)\n        ]\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.find_backdrop_by_name","title":"<code>find_backdrop_by_name(name)</code>","text":"<p>Find backdrop by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the backdrop.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Backdrop.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def find_backdrop_by_name(name: str) -&gt; dict:\n    \"\"\"Find backdrop by its name.\n\n    Args:\n        name (str): Name of the backdrop.\n\n    Returns:\n        dict: Backdrop.\n    \"\"\"\n    backdrops = send(\n        {\"function\": \"Backdrop.backdrops\", \"args\": [\"Top\"]}\n    )[\"result\"]\n    for backdrop in backdrops:\n        if backdrop[\"title\"][\"text\"] == name:\n            return backdrop\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.find_node_by_name","title":"<code>find_node_by_name(name, node_type)</code>","text":"<p>Find node by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the Node. (without part before '/')</p> required <code>node_type</code> <code>str</code> <p>Type of the Node. 'READ' - for loaded data with Loaders (background) 'GROUP' - for loaded data with Loaders (templates) 'WRITE' - render nodes</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>FQ Node name.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def find_node_by_name(name, node_type):\n    \"\"\"Find node by its name.\n\n    Args:\n        name (str): Name of the Node. (without part before '/')\n        node_type (str): Type of the Node.\n            'READ' - for loaded data with Loaders (background)\n            'GROUP' - for loaded data with Loaders (templates)\n            'WRITE' - render nodes\n\n    Returns:\n        str: FQ Node name.\n\n    \"\"\"\n    nodes = send(\n        {\"function\": \"node.getNodes\", \"args\": [[node_type]]}\n    )[\"result\"]\n    for node in nodes:\n        node_name = node.split(\"/\")[-1]\n        if name == node_name:\n            return node\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.get_all_top_names","title":"<code>get_all_top_names()</code>","text":"<p>Get all top node and backdrop names in the scene.</p> <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>Set of top node names.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def get_all_top_names() -&gt; set:\n    \"\"\"Get all top node and backdrop names in the scene.\n\n    Returns:\n        set: Set of top node names.\n    \"\"\"\n    return set(send({\"function\": \"node.subNodes\", \"args\": [\"Top\"]})[\"result\"]) | {\n        backdrop[\"title\"][\"text\"]\n        for backdrop in send({\"function\": \"Backdrop.backdrops\", \"args\": [\"Top\"]})[\n            \"result\"\n        ]\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.get_current_context_settings","title":"<code>get_current_context_settings()</code>","text":"<p>Get settings on current task from server.</p> <p>Returns:</p> Type Description <p>dict[str, Any]: Scene data.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def get_current_context_settings():\n    \"\"\"Get settings on current task from server.\n\n    Returns:\n        dict[str, Any]: Scene data.\n\n    \"\"\"\n\n    task_entity = get_current_task_entity()\n    task_attributes = task_entity[\"attrib\"]\n\n    fps = task_attributes.get(\"fps\")\n    frame_start = task_attributes.get(\"frameStart\")\n    frame_end = task_attributes.get(\"frameEnd\")\n    handle_start = task_attributes.get(\"handleStart\")\n    handle_end = task_attributes.get(\"handleEnd\")\n    resolution_width = task_attributes.get(\"resolutionWidth\")\n    resolution_height = task_attributes.get(\"resolutionHeight\")\n\n    scene_data = {\n        \"fps\": fps,\n        \"frameStart\": frame_start,\n        \"frameEnd\": frame_end,\n        \"handleStart\": handle_start,\n        \"handleEnd\": handle_end,\n        \"resolutionWidth\": resolution_width,\n        \"resolutionHeight\": resolution_height\n    }\n\n    return scene_data\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.imprint","title":"<code>imprint(node_id, data, remove=False)</code>","text":"<p>Write <code>data</code> to the <code>node</code> as json.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>Path to node or id of object.</p> required <code>data</code> <code>dict</code> <p>Dictionary of key/value pairs.</p> required <code>remove</code> <code>bool</code> <p>Removes the data from the scene.</p> <code>False</code> Example <p>from ayon_harmony.api import lib node = \"Top/Display\" data = {\"str\": \"something\", \"int\": 1, \"float\": 0.32, \"bool\": True} lib.imprint(layer, data)</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def imprint(node_id, data, remove=False):\n    \"\"\"Write `data` to the `node` as json.\n\n    Arguments:\n        node_id (str): Path to node or id of object.\n        data (dict): Dictionary of key/value pairs.\n        remove (bool): Removes the data from the scene.\n\n    Example:\n        &gt;&gt;&gt; from ayon_harmony.api import lib\n        &gt;&gt;&gt; node = \"Top/Display\"\n        &gt;&gt;&gt; data = {\"str\": \"something\", \"int\": 1, \"float\": 0.32, \"bool\": True}\n        &gt;&gt;&gt; lib.imprint(layer, data)\n    \"\"\"\n    scene_data = get_scene_data()\n\n    if remove and (node_id in scene_data):\n        scene_data.pop(node_id, None)\n    else:\n        if node_id in scene_data:\n            scene_data[node_id].update(data)\n        else:\n            scene_data[node_id] = data\n\n    set_scene_data(scene_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.inject_ayon_js","title":"<code>inject_ayon_js()</code>","text":"<p>Inject AyonHarmonyAPI.js into Harmony.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def inject_ayon_js():\n    \"\"\"Inject AyonHarmonyAPI.js into Harmony.\"\"\"\n    ayon_harmony_js = Path(__file__).parent.joinpath(\"js/AyonHarmonyAPI.js\")\n    script = ayon_harmony_js.read_text()\n    # send AyonHarmonyAPI.js to Harmony\n    harmony.send({\"script\": script})\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.launch","title":"<code>launch(application_path, *args)</code>","text":"<p>Set Harmony for launch.</p> <p>Launches Harmony and the server, then starts listening on the main thread for callbacks from the server. This is to have Qt applications run in the main thread.</p> <p>Parameters:</p> Name Type Description Default <code>application_path</code> <code>str</code> <p>Path to Harmony.</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def launch(application_path, *args):\n    \"\"\"Set Harmony for launch.\n\n    Launches Harmony and the server, then starts listening on the main thread\n    for callbacks from the server. This is to have Qt applications run in the\n    main thread.\n\n    Args:\n        application_path (str): Path to Harmony.\n\n    \"\"\"\n    from ayon_core.pipeline import install_host\n    from ayon_harmony.api import HarmonyHost\n\n    install_host(HarmonyHost())\n\n    ProcessContext.port = random.randrange(49152, 65535)\n    os.environ[\"AYON_HARMONY_PORT\"] = str(ProcessContext.port)\n    ProcessContext.application_path = application_path\n\n    # Launch Harmony.\n    setup_startup_scripts()\n    check_libs()\n\n    if not os.environ.get(\"AYON_HARMONY_WORKFILES_ON_LAUNCH\", False):\n        open_empty_workfile()\n        return\n\n    ProcessContext.workfile_tool = host_tools.get_tool_by_name(\"workfiles\")\n    host_tools.show_workfiles(save=False)\n    ProcessContext.execute_in_main_thread(check_workfiles_tool)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.ls","title":"<code>ls()</code>","text":"<p>Yields containers from Harmony scene.</p> <p>Clean up scene data from orphaned containers.</p> <p>Yields:</p> Name Type Description <code>dict</code> <p>container</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"Yields containers from Harmony scene.\n\n    Clean up scene data from orphaned containers.\n\n    Yields:\n        dict: container\n    \"\"\"\n    scene_data = harmony.get_scene_data() or dict()\n    all_top_names = harmony.get_all_top_names()\n    cleaned_scene_data = True\n    for entity_name, entity_data in scene_data.copy().items():\n        if not is_container_data(entity_data):\n            continue\n\n        # Filter orphaned containers\n        if entity_name not in all_top_names:\n            del scene_data[entity_name]\n            cleaned_scene_data = True\n            continue\n\n        if not entity_data.get(\"objectName\"):  # backward compatibility\n            entity_data[\"objectName\"] = entity_data[\"name\"]\n        yield entity_data\n\n    # Update scene data if cleaned\n    if cleaned_scene_data:\n        harmony.set_scene_data(scene_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.maintained_nodes_state","title":"<code>maintained_nodes_state(nodes)</code>","text":"<p>Maintain nodes states during context.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_nodes_state(nodes):\n    \"\"\"Maintain nodes states during context.\"\"\"\n    # Collect current state.\n    states = send(\n        {\n            \"function\": \"AyonHarmonyAPI.areEnabled\", \"args\": nodes\n        })[\"result\"]\n\n    # Disable all nodes.\n    send(\n        {\n            \"function\": \"AyonHarmonyAPI.disableNodes\", \"args\": nodes\n        })\n\n    try:\n        yield\n    finally:\n        send(\n            {\n                \"function\": \"AyonHarmonyAPI.setState\",\n                \"args\": [nodes, states]\n            })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.read","title":"<code>read(node_id)</code>","text":"<p>Read object metadata in to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>Path to node or id of object.</p> required <p>Returns:</p> Type Description <p>dict</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def read(node_id):\n    \"\"\"Read object metadata in to a dictionary.\n\n    Args:\n        node_id (str): Path to node or id of object.\n\n    Returns:\n        dict\n    \"\"\"\n    scene_data = get_scene_data()\n    if node_id in scene_data:\n        return scene_data[node_id]\n\n    return {}\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.remove","title":"<code>remove(node_id)</code>","text":"<p>Remove node data from scene metadata.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>full name (eg. 'Top/renderAnimation')</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def remove(node_id):\n    \"\"\"\n        Remove node data from scene metadata.\n\n        Args:\n            node_id (str): full name (eg. 'Top/renderAnimation')\n    \"\"\"\n    data = get_scene_data()\n    del data[node_id]\n    set_scene_data(data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.save_scene","title":"<code>save_scene()</code>","text":"<p>Save the Harmony scene safely.</p> <p>The built-in (to AYON) background zip and moving of the Harmony scene folder, interferes with server/client communication by sending two requests at the same time. This only happens when sending \"scene.saveAll()\". This method prevents this double request and safely saves the scene.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def save_scene():\n    \"\"\"Save the Harmony scene safely.\n\n    The built-in (to AYON) background zip and moving of the Harmony scene\n    folder, interferes with server/client communication by sending two requests\n    at the same time. This only happens when sending \"scene.saveAll()\". This\n    method prevents this double request and safely saves the scene.\n\n    \"\"\"\n    # Need to turn off the background watcher else the communication with\n    # the server gets spammed with two requests at the same time.\n    scene_path = send(\n        {\"function\": \"AyonHarmonyAPI.saveScene\"})[\"result\"]\n\n    # Manually update the remote file.\n    on_file_changed(scene_path, threaded=False)\n\n    # Re-enable the background watcher.\n    send({\"function\": \"AyonHarmonyAPI.enableFileWather\"})\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.save_scene_as","title":"<code>save_scene_as(filepath)</code>","text":"<p>Save Harmony scene as <code>filepath</code>.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def save_scene_as(filepath):\n    \"\"\"Save Harmony scene as `filepath`.\"\"\"\n    scene_dir = os.path.dirname(filepath)\n    destination = os.path.join(\n        os.path.dirname(ProcessContext.workfile_path),\n        os.path.splitext(os.path.basename(filepath))[0] + \".zip\"\n    )\n\n    if os.path.exists(scene_dir):\n        try:\n            shutil.rmtree(scene_dir)\n        except Exception as e:\n            log.error(f\"Cannot remove {scene_dir}\")\n            raise Exception(f\"Cannot remove {scene_dir}\") from e\n\n    send(\n        {\"function\": \"scene.saveAs\", \"args\": [scene_dir]}\n    )[\"result\"]\n\n    zip_and_move(scene_dir, destination)\n\n    ProcessContext.workfile_path = destination\n\n    send(\n        {\"function\": \"AyonHarmonyAPI.addPathToWatcher\", \"args\": filepath}\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.select_nodes","title":"<code>select_nodes(nodes)</code>","text":"<p>Selects nodes in Node View</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def select_nodes(nodes):\n    \"\"\" Selects nodes in Node View \"\"\"\n    _ = send(\n        {\n            \"function\": \"AyonHarmonyAPI.selectNodes\",\n            \"args\": nodes\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.send","title":"<code>send(request)</code>","text":"<p>Public method for sending requests to Harmony.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def send(request):\n    \"\"\"Public method for sending requests to Harmony.\"\"\"\n    return ProcessContext.server.send(request)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.set_scene_data","title":"<code>set_scene_data(data)</code>","text":"<p>Write scene data to metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Data to write.</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def set_scene_data(data):\n    \"\"\"Write scene data to metadata.\n\n    Args:\n        data (dict): Data to write.\n\n    \"\"\"\n    # Write scene data.\n    send(\n        {\n            \"function\": \"AyonHarmonyAPI.setSceneData\",\n            \"args\": data\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.set_scene_settings","title":"<code>set_scene_settings(settings)</code>","text":"<p>Set correct scene settings in Harmony.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>dict</code> <p>Scene settings.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary of settings to set.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def set_scene_settings(settings):\n    \"\"\"Set correct scene settings in Harmony.\n\n    Args:\n        settings (dict): Scene settings.\n\n    Returns:\n        dict: Dictionary of settings to set.\n\n    \"\"\"\n    harmony.send(\n        {\"function\": \"AyonHarmony.setSceneSettings\", \"args\": settings})\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.signature","title":"<code>signature(postfix='func')</code>","text":"<p>Return random ECMA6 compatible function name.</p> <p>Parameters:</p> Name Type Description Default <code>postfix</code> <code>str</code> <p>name to append to random string.</p> <code>'func'</code> <p>Returns:     str: random function name.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def signature(postfix=\"func\") -&gt; str:\n    \"\"\"Return random ECMA6 compatible function name.\n\n    Args:\n        postfix (str): name to append to random string.\n    Returns:\n        str: random function name.\n\n    \"\"\"\n    return \"f{}_{}\".format(str(uuid4()).replace(\"-\", \"_\"), postfix)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/launch_script.html","title":"launch_script","text":"<p>Script wraps launch mechanism of Harmony implementations.</p> <p>Arguments passed to the script are passed to launch function in host implementation. In all cases requires host app executable and may contain workfile or others.</p>"},{"location":"autoapi/client/ayon_harmony/api/launch_script.html#client.ayon_harmony.api.launch_script.on_invalid_args","title":"<code>on_invalid_args(script_not_found)</code>","text":"<p>Show to user message box saying that something went wrong.</p> <p>Tell user that arguments to launch implementation are invalid with arguments details.</p> <p>Parameters:</p> Name Type Description Default <code>script_not_found</code> <code>bool</code> <p>Use different message based on this value.</p> required Source code in <code>client/ayon_harmony/api/launch_script.py</code> <pre><code>def on_invalid_args(script_not_found):\n    \"\"\"Show to user message box saying that something went wrong.\n\n    Tell user that arguments to launch implementation are invalid with\n    arguments details.\n\n    Args:\n        script_not_found (bool): Use different message based on this value.\n    \"\"\"\n\n    title = \"Invalid arguments\"\n    joined_args = \", \".join(\"\\\"{}\\\"\".format(arg) for arg in sys.argv)\n    if script_not_found:\n        submsg = \"Where couldn't find script path:\\n\\\"{}\\\"\"\n    else:\n        submsg = \"Expected Host executable after script path:\\n\\\"{}\\\"\"\n\n    message = \"BUG: Got invalid arguments so can't launch Host application.\"\n    detail_message = \"Process was launched with arguments:\\n{}\\n\\n{}\".format(\n        joined_args,\n        submsg.format(CURRENT_FILE)\n    )\n\n    show_error_messagebox(title, message, detail_message)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/launch_script.html#client.ayon_harmony.api.launch_script.show_error_messagebox","title":"<code>show_error_messagebox(title, message, detail_message=None)</code>","text":"<p>Function will show message and process ends after closing it.</p> Source code in <code>client/ayon_harmony/api/launch_script.py</code> <pre><code>def show_error_messagebox(title, message, detail_message=None):\n    \"\"\"Function will show message and process ends after closing it.\"\"\"\n    from qtpy import QtWidgets, QtCore\n    from ayon_core import style\n\n    app = QtWidgets.QApplication([])\n    app.setStyleSheet(style.load_stylesheet())\n\n    msgbox = QtWidgets.QMessageBox()\n    msgbox.setWindowTitle(title)\n    msgbox.setText(message)\n\n    if detail_message:\n        msgbox.setDetailedText(detail_message)\n\n    msgbox.setWindowModality(QtCore.Qt.ApplicationModal)\n    msgbox.show()\n\n    sys.exit(app.exec_())\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html","title":"lib","text":"<p>Utility functions used for AYON - Harmony integration.</p>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.check_libs","title":"<code>check_libs()</code>","text":"<p>Check if <code>OpenHarmony</code>_ is available.</p> <p>AYON expects either path in <code>LIB_OPENHARMONY_PATH</code> or <code>openHarmony.js</code> present in <code>TOONBOOM_GLOBAL_SCRIPT_LOCATION</code>.</p> Throws <p>RuntimeError: If openHarmony is not found.</p> <p>.. _OpenHarmony:     https://github.com/cfourney/OpenHarmony</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def check_libs():\n    \"\"\"Check if `OpenHarmony`_ is available.\n\n    AYON expects either path in `LIB_OPENHARMONY_PATH` or `openHarmony.js`\n    present in `TOONBOOM_GLOBAL_SCRIPT_LOCATION`.\n\n    Throws:\n        RuntimeError: If openHarmony is not found.\n\n    .. _OpenHarmony:\n        https://github.com/cfourney/OpenHarmony\n\n    \"\"\"\n    if not os.getenv(\"LIB_OPENHARMONY_PATH\"):\n\n        if os.getenv(\"TOONBOOM_GLOBAL_SCRIPT_LOCATION\"):\n            if os.path.exists(\n                os.path.join(\n                    os.getenv(\"TOONBOOM_GLOBAL_SCRIPT_LOCATION\"),\n                    \"openHarmony.js\")):\n\n                os.environ[\"LIB_OPENHARMONY_PATH\"] = \\\n                    os.getenv(\"TOONBOOM_GLOBAL_SCRIPT_LOCATION\")\n                return\n\n        else:\n            log.error((\"Cannot find OpenHarmony library. \"\n                       \"Please set path to it in LIB_OPENHARMONY_PATH \"\n                       \"environment variable.\"))\n            raise RuntimeError(\"Missing OpenHarmony library.\")\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.delete_node","title":"<code>delete_node(node)</code>","text":"<p>Physically delete node from scene.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def delete_node(node):\n    \"\"\" Physically delete node from scene. \"\"\"\n    send(\n        {\n            \"function\": \"AyonHarmonyAPI.deleteNode\",\n            \"args\": node\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.find_backdrop_by_name","title":"<code>find_backdrop_by_name(name)</code>","text":"<p>Find backdrop by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the backdrop.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Backdrop.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def find_backdrop_by_name(name: str) -&gt; dict:\n    \"\"\"Find backdrop by its name.\n\n    Args:\n        name (str): Name of the backdrop.\n\n    Returns:\n        dict: Backdrop.\n    \"\"\"\n    backdrops = send(\n        {\"function\": \"Backdrop.backdrops\", \"args\": [\"Top\"]}\n    )[\"result\"]\n    for backdrop in backdrops:\n        if backdrop[\"title\"][\"text\"] == name:\n            return backdrop\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.find_node_by_name","title":"<code>find_node_by_name(name, node_type)</code>","text":"<p>Find node by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the Node. (without part before '/')</p> required <code>node_type</code> <code>str</code> <p>Type of the Node. 'READ' - for loaded data with Loaders (background) 'GROUP' - for loaded data with Loaders (templates) 'WRITE' - render nodes</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>FQ Node name.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def find_node_by_name(name, node_type):\n    \"\"\"Find node by its name.\n\n    Args:\n        name (str): Name of the Node. (without part before '/')\n        node_type (str): Type of the Node.\n            'READ' - for loaded data with Loaders (background)\n            'GROUP' - for loaded data with Loaders (templates)\n            'WRITE' - render nodes\n\n    Returns:\n        str: FQ Node name.\n\n    \"\"\"\n    nodes = send(\n        {\"function\": \"node.getNodes\", \"args\": [[node_type]]}\n    )[\"result\"]\n    for node in nodes:\n        node_name = node.split(\"/\")[-1]\n        if name == node_name:\n            return node\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.get_all_top_names","title":"<code>get_all_top_names()</code>","text":"<p>Get all top node and backdrop names in the scene.</p> <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>Set of top node names.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def get_all_top_names() -&gt; set:\n    \"\"\"Get all top node and backdrop names in the scene.\n\n    Returns:\n        set: Set of top node names.\n    \"\"\"\n    return set(send({\"function\": \"node.subNodes\", \"args\": [\"Top\"]})[\"result\"]) | {\n        backdrop[\"title\"][\"text\"]\n        for backdrop in send({\"function\": \"Backdrop.backdrops\", \"args\": [\"Top\"]})[\n            \"result\"\n        ]\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.get_local_harmony_path","title":"<code>get_local_harmony_path(filepath)</code>","text":"<p>From the provided path get the equivalent local Harmony path.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def get_local_harmony_path(filepath):\n    \"\"\"From the provided path get the equivalent local Harmony path.\"\"\"\n    basename = os.path.splitext(os.path.basename(filepath))[0]\n    harmony_path = os.path.join(os.path.expanduser(\"~\"), \".ayon\", \"harmony\")\n    return os.path.join(harmony_path, basename)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.imprint","title":"<code>imprint(node_id, data, remove=False)</code>","text":"<p>Write <code>data</code> to the <code>node</code> as json.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>Path to node or id of object.</p> required <code>data</code> <code>dict</code> <p>Dictionary of key/value pairs.</p> required <code>remove</code> <code>bool</code> <p>Removes the data from the scene.</p> <code>False</code> Example <p>from ayon_harmony.api import lib node = \"Top/Display\" data = {\"str\": \"something\", \"int\": 1, \"float\": 0.32, \"bool\": True} lib.imprint(layer, data)</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def imprint(node_id, data, remove=False):\n    \"\"\"Write `data` to the `node` as json.\n\n    Arguments:\n        node_id (str): Path to node or id of object.\n        data (dict): Dictionary of key/value pairs.\n        remove (bool): Removes the data from the scene.\n\n    Example:\n        &gt;&gt;&gt; from ayon_harmony.api import lib\n        &gt;&gt;&gt; node = \"Top/Display\"\n        &gt;&gt;&gt; data = {\"str\": \"something\", \"int\": 1, \"float\": 0.32, \"bool\": True}\n        &gt;&gt;&gt; lib.imprint(layer, data)\n    \"\"\"\n    scene_data = get_scene_data()\n\n    if remove and (node_id in scene_data):\n        scene_data.pop(node_id, None)\n    else:\n        if node_id in scene_data:\n            scene_data[node_id].update(data)\n        else:\n            scene_data[node_id] = data\n\n    set_scene_data(scene_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.launch","title":"<code>launch(application_path, *args)</code>","text":"<p>Set Harmony for launch.</p> <p>Launches Harmony and the server, then starts listening on the main thread for callbacks from the server. This is to have Qt applications run in the main thread.</p> <p>Parameters:</p> Name Type Description Default <code>application_path</code> <code>str</code> <p>Path to Harmony.</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def launch(application_path, *args):\n    \"\"\"Set Harmony for launch.\n\n    Launches Harmony and the server, then starts listening on the main thread\n    for callbacks from the server. This is to have Qt applications run in the\n    main thread.\n\n    Args:\n        application_path (str): Path to Harmony.\n\n    \"\"\"\n    from ayon_core.pipeline import install_host\n    from ayon_harmony.api import HarmonyHost\n\n    install_host(HarmonyHost())\n\n    ProcessContext.port = random.randrange(49152, 65535)\n    os.environ[\"AYON_HARMONY_PORT\"] = str(ProcessContext.port)\n    ProcessContext.application_path = application_path\n\n    # Launch Harmony.\n    setup_startup_scripts()\n    check_libs()\n\n    if not os.environ.get(\"AYON_HARMONY_WORKFILES_ON_LAUNCH\", False):\n        open_empty_workfile()\n        return\n\n    ProcessContext.workfile_tool = host_tools.get_tool_by_name(\"workfiles\")\n    host_tools.show_workfiles(save=False)\n    ProcessContext.execute_in_main_thread(check_workfiles_tool)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.launch_zip_file","title":"<code>launch_zip_file(filepath)</code>","text":"<p>Launch a Harmony application instance with the provided zip file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to file.</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def launch_zip_file(filepath):\n    \"\"\"Launch a Harmony application instance with the provided zip file.\n\n    Args:\n        filepath (str): Path to file.\n    \"\"\"\n    print(f\"Localizing {filepath}\")\n\n    temp_path = get_local_harmony_path(filepath)\n    scene_name = os.path.basename(temp_path)\n    if os.path.exists(os.path.join(temp_path, scene_name)):\n        # unzipped with duplicated scene_name\n        temp_path = os.path.join(temp_path, scene_name)\n\n    scene_path = os.path.join(\n        temp_path, scene_name + \".xstage\"\n    )\n\n    unzip = False\n    if os.path.exists(scene_path):\n        # Check remote scene is newer than local.\n        if os.path.getmtime(scene_path) &lt; os.path.getmtime(filepath):\n            try:\n                shutil.rmtree(temp_path)\n            except Exception as e:\n                log.error(e)\n                raise Exception(\"Cannot delete working folder\") from e\n            unzip = True\n    else:\n        unzip = True\n\n    if unzip:\n        with _ZipFile(filepath, \"r\") as zip_ref:\n            zip_ref.extractall(temp_path)\n\n        if os.path.exists(os.path.join(temp_path, scene_name)):\n            # unzipped with duplicated scene_name\n            temp_path = os.path.join(temp_path, scene_name)\n\n    # Close existing scene.\n    if ProcessContext.pid:\n        os.kill(ProcessContext.pid, signal.SIGTERM)\n\n    # Stop server.\n    if ProcessContext.server:\n        ProcessContext.server.stop()\n\n    # Launch AYON server.\n    ProcessContext.server = Server(ProcessContext.port)\n    ProcessContext.server.start()\n    # thread = threading.Thread(target=self.server.start)\n    # thread.daemon = True\n    # thread.start()\n\n    # Save workfile path for later.\n    ProcessContext.workfile_path = filepath\n\n    # find any xstage files is directory, prefer the one with the same name\n    # as directory (plus extension)\n    xstage_files = []\n    for _, _, files in os.walk(temp_path):\n        for file in files:\n            if os.path.splitext(file)[1] == \".xstage\":\n                xstage_files.append(file)\n\n    if not os.path.basename(\"temp.zip\"):\n        if not xstage_files:\n            ProcessContext.server.stop()\n            print(\"no xstage file was found\")\n            return\n\n    # try to use first available\n    scene_path = os.path.join(\n        temp_path, xstage_files[0]\n    )\n\n    # prefer the one named as zip file\n    zip_based_name = \"{}.xstage\".format(\n        os.path.splitext(os.path.basename(filepath))[0])\n\n    if zip_based_name in xstage_files:\n        scene_path = os.path.join(\n            temp_path, zip_based_name\n        )\n\n    if not os.path.exists(scene_path):\n        print(\"error: cannot determine scene file {}\".format(scene_path))\n        ProcessContext.server.stop()\n        return\n\n    print(\"Launching {}\".format(scene_path))\n    # QUESTION Could we use 'run_detached_process' from 'ayon_core.lib'?\n    kwargs = {}\n    if (\n        platform.system().lower() == \"windows\"\n        and not is_using_ayon_console()\n    ):\n        kwargs.update({\n            \"creationflags\": subprocess.CREATE_NO_WINDOW,\n            \"stdout\": subprocess.DEVNULL,\n            \"stderr\": subprocess.DEVNULL\n        })\n\n    process = subprocess.Popen(\n        [ProcessContext.application_path, scene_path],\n        **kwargs\n    )\n    ProcessContext.pid = process.pid\n    ProcessContext.process = process\n    ProcessContext.stdout_broker.host_connected()\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.maintained_nodes_state","title":"<code>maintained_nodes_state(nodes)</code>","text":"<p>Maintain nodes states during context.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_nodes_state(nodes):\n    \"\"\"Maintain nodes states during context.\"\"\"\n    # Collect current state.\n    states = send(\n        {\n            \"function\": \"AyonHarmonyAPI.areEnabled\", \"args\": nodes\n        })[\"result\"]\n\n    # Disable all nodes.\n    send(\n        {\n            \"function\": \"AyonHarmonyAPI.disableNodes\", \"args\": nodes\n        })\n\n    try:\n        yield\n    finally:\n        send(\n            {\n                \"function\": \"AyonHarmonyAPI.setState\",\n                \"args\": [nodes, states]\n            })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.on_file_changed","title":"<code>on_file_changed(path, threaded=True)</code>","text":"<p>Threaded zipping and move of the project directory.</p> <p>This method is called when the <code>.xstage</code> file is changed.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def on_file_changed(path, threaded=True):\n    \"\"\"Threaded zipping and move of the project directory.\n\n    This method is called when the `.xstage` file is changed.\n    \"\"\"\n    log.debug(\"File changed: \" + path)\n\n    if ProcessContext.workfile_path is None:\n        return\n\n    if threaded:\n        thread = threading.Thread(\n            target=zip_and_move,\n            args=(os.path.dirname(path), ProcessContext.workfile_path)\n        )\n        thread.start()\n    else:\n        zip_and_move(os.path.dirname(path), ProcessContext.workfile_path)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.read","title":"<code>read(node_id)</code>","text":"<p>Read object metadata in to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>Path to node or id of object.</p> required <p>Returns:</p> Type Description <p>dict</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def read(node_id):\n    \"\"\"Read object metadata in to a dictionary.\n\n    Args:\n        node_id (str): Path to node or id of object.\n\n    Returns:\n        dict\n    \"\"\"\n    scene_data = get_scene_data()\n    if node_id in scene_data:\n        return scene_data[node_id]\n\n    return {}\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.remove","title":"<code>remove(node_id)</code>","text":"<p>Remove node data from scene metadata.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>full name (eg. 'Top/renderAnimation')</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def remove(node_id):\n    \"\"\"\n        Remove node data from scene metadata.\n\n        Args:\n            node_id (str): full name (eg. 'Top/renderAnimation')\n    \"\"\"\n    data = get_scene_data()\n    del data[node_id]\n    set_scene_data(data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.save_scene","title":"<code>save_scene()</code>","text":"<p>Save the Harmony scene safely.</p> <p>The built-in (to AYON) background zip and moving of the Harmony scene folder, interferes with server/client communication by sending two requests at the same time. This only happens when sending \"scene.saveAll()\". This method prevents this double request and safely saves the scene.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def save_scene():\n    \"\"\"Save the Harmony scene safely.\n\n    The built-in (to AYON) background zip and moving of the Harmony scene\n    folder, interferes with server/client communication by sending two requests\n    at the same time. This only happens when sending \"scene.saveAll()\". This\n    method prevents this double request and safely saves the scene.\n\n    \"\"\"\n    # Need to turn off the background watcher else the communication with\n    # the server gets spammed with two requests at the same time.\n    scene_path = send(\n        {\"function\": \"AyonHarmonyAPI.saveScene\"})[\"result\"]\n\n    # Manually update the remote file.\n    on_file_changed(scene_path, threaded=False)\n\n    # Re-enable the background watcher.\n    send({\"function\": \"AyonHarmonyAPI.enableFileWather\"})\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.save_scene_as","title":"<code>save_scene_as(filepath)</code>","text":"<p>Save Harmony scene as <code>filepath</code>.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def save_scene_as(filepath):\n    \"\"\"Save Harmony scene as `filepath`.\"\"\"\n    scene_dir = os.path.dirname(filepath)\n    destination = os.path.join(\n        os.path.dirname(ProcessContext.workfile_path),\n        os.path.splitext(os.path.basename(filepath))[0] + \".zip\"\n    )\n\n    if os.path.exists(scene_dir):\n        try:\n            shutil.rmtree(scene_dir)\n        except Exception as e:\n            log.error(f\"Cannot remove {scene_dir}\")\n            raise Exception(f\"Cannot remove {scene_dir}\") from e\n\n    send(\n        {\"function\": \"scene.saveAs\", \"args\": [scene_dir]}\n    )[\"result\"]\n\n    zip_and_move(scene_dir, destination)\n\n    ProcessContext.workfile_path = destination\n\n    send(\n        {\"function\": \"AyonHarmonyAPI.addPathToWatcher\", \"args\": filepath}\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.select_nodes","title":"<code>select_nodes(nodes)</code>","text":"<p>Selects nodes in Node View</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def select_nodes(nodes):\n    \"\"\" Selects nodes in Node View \"\"\"\n    _ = send(\n        {\n            \"function\": \"AyonHarmonyAPI.selectNodes\",\n            \"args\": nodes\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.send","title":"<code>send(request)</code>","text":"<p>Public method for sending requests to Harmony.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def send(request):\n    \"\"\"Public method for sending requests to Harmony.\"\"\"\n    return ProcessContext.server.send(request)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.set_scene_data","title":"<code>set_scene_data(data)</code>","text":"<p>Write scene data to metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Data to write.</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def set_scene_data(data):\n    \"\"\"Write scene data to metadata.\n\n    Args:\n        data (dict): Data to write.\n\n    \"\"\"\n    # Write scene data.\n    send(\n        {\n            \"function\": \"AyonHarmonyAPI.setSceneData\",\n            \"args\": data\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.setup_startup_scripts","title":"<code>setup_startup_scripts()</code>","text":"<p>Manages installation of ayon's TB_sceneOpened.js for Harmony launch.</p> <p>If a studio already has defined \"TOONBOOM_GLOBAL_SCRIPT_LOCATION\", copies the TB_sceneOpened.js to that location if the file is different. Otherwise, will set the env var to point to the ayon/harmony folder.</p> <p>Admins should be aware that this will overwrite TB_sceneOpened in the \"TOONBOOM_GLOBAL_SCRIPT_LOCATION\", and that if they want to have additional logic, they will need to one of the following:     * Create a Harmony package to manage startup logic     * Use TB_sceneOpenedUI.js instead to manage startup logic     * Add their startup logic to ayon/harmony/TB_sceneOpened.js</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def setup_startup_scripts():\n    \"\"\"Manages installation of ayon's TB_sceneOpened.js for Harmony launch.\n\n    If a studio already has defined \"TOONBOOM_GLOBAL_SCRIPT_LOCATION\", copies\n    the TB_sceneOpened.js to that location if the file is different.\n    Otherwise, will set the env var to point to the ayon/harmony folder.\n\n    Admins should be aware that this will overwrite TB_sceneOpened in the\n    \"TOONBOOM_GLOBAL_SCRIPT_LOCATION\", and that if they want to have additional\n    logic, they will need to one of the following:\n        * Create a Harmony package to manage startup logic\n        * Use TB_sceneOpenedUI.js instead to manage startup logic\n        * Add their startup logic to ayon/harmony/TB_sceneOpened.js\n    \"\"\"\n    ayon_dcc_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)),\n                                  \"api\")\n    startup_js = \"TB_sceneOpened.js\"\n\n    if os.getenv(\"TOONBOOM_GLOBAL_SCRIPT_LOCATION\"):\n\n        ayon_harmony_startup = os.path.join(ayon_dcc_dir, startup_js)\n\n        env_harmony_startup = os.path.join(\n            os.getenv(\"TOONBOOM_GLOBAL_SCRIPT_LOCATION\"), startup_js)\n\n        if not filecmp.cmp(ayon_harmony_startup, env_harmony_startup):\n            try:\n                shutil.copy(ayon_harmony_startup, env_harmony_startup)\n            except Exception as e:\n                log.error(e)\n                log.warning(\n                    \"Failed to copy {0} to {1}! \"\n                    \"Defaulting to AYON TOONBOOM_GLOBAL_SCRIPT_LOCATION.\"\n                    .format(ayon_harmony_startup, env_harmony_startup))\n\n                os.environ[\"TOONBOOM_GLOBAL_SCRIPT_LOCATION\"] = ayon_dcc_dir\n    else:\n        os.environ[\"TOONBOOM_GLOBAL_SCRIPT_LOCATION\"] = ayon_dcc_dir\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.show","title":"<code>show(tool_name)</code>","text":"<p>Call show on \"module_name\".</p> <p>This allows to make a QApplication ahead of time and always \"exec_\" to prevent crashing.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Name of module to call \"show\" on.</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def show(tool_name):\n    \"\"\"Call show on \"module_name\".\n\n    This allows to make a QApplication ahead of time and always \"exec_\" to\n    prevent crashing.\n\n    Args:\n        module_name (str): Name of module to call \"show\" on.\n\n    \"\"\"\n    # Requests often get doubled up when showing tools, so we wait a second for\n    # requests to be received properly.\n    time.sleep(1)\n\n    kwargs = {}\n    if tool_name == \"loader\":\n        kwargs[\"use_context\"] = True\n    elif tool_name == \"publisher\":\n        kwargs[\"tab\"] = \"publish\"\n    elif tool_name == \"creator\":\n        tool_name = \"publisher\"\n        kwargs[\"tab\"] = \"create\"\n\n    ProcessContext.execute_in_main_thread(\n        lambda: host_tools.show_tool_by_name(tool_name, **kwargs)\n    )\n\n    # Required return statement.\n    return \"nothing\"\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.signature","title":"<code>signature(postfix='func')</code>","text":"<p>Return random ECMA6 compatible function name.</p> <p>Parameters:</p> Name Type Description Default <code>postfix</code> <code>str</code> <p>name to append to random string.</p> <code>'func'</code> <p>Returns:     str: random function name.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def signature(postfix=\"func\") -&gt; str:\n    \"\"\"Return random ECMA6 compatible function name.\n\n    Args:\n        postfix (str): name to append to random string.\n    Returns:\n        str: random function name.\n\n    \"\"\"\n    return \"f{}_{}\".format(str(uuid4()).replace(\"-\", \"_\"), postfix)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.zip_and_move","title":"<code>zip_and_move(source, destination)</code>","text":"<p>Zip a directory and move to <code>destination</code>.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Directory to zip and move to destination.</p> required <code>destination</code> <code>str</code> <p>Destination file path to zip file.</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def zip_and_move(source, destination):\n    \"\"\"Zip a directory and move to `destination`.\n\n    Args:\n        source (str): Directory to zip and move to destination.\n        destination (str): Destination file path to zip file.\n\n    \"\"\"\n    os.chdir(os.path.dirname(source))\n    shutil.make_archive(os.path.basename(source), \"zip\", source)\n    with _ZipFile(os.path.basename(source) + \".zip\") as zr:\n        if zr.testzip() is not None:\n            raise Exception(\"File archive is corrupted.\")\n    shutil.move(os.path.basename(source) + \".zip\", destination)\n    log.debug(f\"Saved '{source}' to '{destination}'\")\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html","title":"pipeline","text":""},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.HarmonyHost","title":"<code>HarmonyHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>class HarmonyHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"harmony\"\n\n    _context_key = \"AYON_context\"\n\n    def install(self):\n        \"\"\"Install Pype as host config.\"\"\"\n        print(\"Installing AYON Harmony Host ...\")\n\n        pyblish.api.register_host(\"harmony\")\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n\n        register_event_callback(\"application.launched\", application_launch)\n\n    def uninstall(self):\n        pyblish.api.deregister_plugin_path(PUBLISH_PATH)\n        deregister_loader_plugin_path(LOAD_PATH)\n        deregister_creator_plugin_path(CREATE_PATH)\n\n    def open_workfile(self, filepath):\n        return open_file(filepath)\n\n    def save_workfile(self, filepath=None):\n        return save_file(filepath)\n\n    def work_root(self, session):\n        return work_root(session)\n\n    def get_current_workfile(self):\n        return current_file()\n\n    def workfile_has_unsaved_changes(self):\n        return has_unsaved_changes()\n\n    def get_workfile_extensions(self):\n        return file_extensions()\n\n    def get_containers(self):\n        return ls()\n\n    def get_context_data(self):\n        return get_scene_data().get(self._context_key, {})\n\n    def update_context_data(self, data, changes):\n        scene_data = get_scene_data()\n        context_data = scene_data.setdefault(self._context_key, {})\n        context_data.update(data)\n        set_scene_data(scene_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.HarmonyHost.install","title":"<code>install()</code>","text":"<p>Install Pype as host config.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Install Pype as host config.\"\"\"\n    print(\"Installing AYON Harmony Host ...\")\n\n    pyblish.api.register_host(\"harmony\")\n    pyblish.api.register_plugin_path(PUBLISH_PATH)\n    register_loader_plugin_path(LOAD_PATH)\n    register_creator_plugin_path(CREATE_PATH)\n\n    register_event_callback(\"application.launched\", application_launch)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.application_launch","title":"<code>application_launch(event)</code>","text":"<p>Event that is executed after Harmony is launched.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def application_launch(event):\n    \"\"\"Event that is executed after Harmony is launched.\"\"\"\n    # fills AYON_HARMONY_JS\n    ayon_harmony_path = Path(__file__).parent.parent / \"js\" / \"AyonHarmony.js\"\n    ayon_harmony_js = ayon_harmony_path.read_text()\n\n    # go through js/creators, loaders and publish folders and load all scripts\n    script = \"\"\n    for item in [\"creators\", \"loaders\", \"publish\"]:\n        dir_to_scan = Path(__file__).parent.parent / \"js\" / item\n        for child in dir_to_scan.iterdir():\n            script += child.read_text()\n\n    # send scripts to Harmony\n    harmony.send({\"script\": ayon_harmony_js})\n    harmony.send({\"script\": script})\n    inject_ayon_js()\n\n    # ensure_scene_settings()\n    check_inventory()\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.check_inventory","title":"<code>check_inventory()</code>","text":"<p>Check is scene contains outdated containers.</p> <p>If it does it will colorize outdated nodes and display warning message in Harmony.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def check_inventory():\n    \"\"\"Check is scene contains outdated containers.\n\n    If it does it will colorize outdated nodes and display warning message\n    in Harmony.\n    \"\"\"\n\n    outdated_containers = get_outdated_containers()\n    if not outdated_containers:\n        return\n\n    # Colour nodes.\n    outdated_nodes = []\n    for container in outdated_containers:\n        if container[\"loader\"] == \"ImageSequenceLoader\":\n            outdated_nodes.append(\n                harmony.find_node_by_name(container[\"name\"], \"READ\")\n            )\n    harmony.send({\"function\": \"AyonHarmony.setColor\", \"args\": outdated_nodes})\n\n    # Warn about outdated containers.\n    msg = \"There are outdated containers in the scene.\"\n    harmony.send({\"function\": \"AyonHarmony.message\", \"args\": msg})\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.containerise","title":"<code>containerise(name, namespace, node, context, loader=None, suffix=None, nodes=None)</code>","text":"<p>Imprint node with metadata.</p> <p>Containerisation enables a tracking of version, author and origin for loaded product representations.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly.</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container.</p> required <code>node</code> <code>str</code> <p>Node to containerise.</p> required <code>context</code> <code>dict</code> <p>Loaded representation full context information.</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>container</code> <code>str</code> <p>Path of container assembly.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def containerise(name,\n                 namespace,\n                 node,\n                 context,\n                 loader=None,\n                 suffix=None,\n                 nodes=None):\n    \"\"\"Imprint node with metadata.\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded product representations.\n\n    Arguments:\n        name (str): Name of resulting assembly.\n        namespace (str): Namespace under which to host container.\n        node (str): Node to containerise.\n        context (dict): Loaded representation full context information.\n        loader (str, optional): Name of loader used to produce this container.\n        suffix (str, optional): Suffix of container, defaults to `_CON`.\n\n    Returns:\n        container (str): Path of container assembly.\n    \"\"\"\n    if not nodes:\n        nodes = []\n\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace,\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"nodes\": nodes\n    }\n\n    harmony.imprint(node, data)\n\n    return node\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.ensure_scene_settings","title":"<code>ensure_scene_settings()</code>","text":"<p>Validate if Harmony scene has valid settings.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def ensure_scene_settings():\n    \"\"\"Validate if Harmony scene has valid settings.\"\"\"\n    settings = get_current_context_settings()\n\n    invalid_settings = []\n    valid_settings = {}\n    for key, value in settings.items():\n        if value is None:\n            invalid_settings.append(key)\n        else:\n            valid_settings[key] = value\n\n    # Warn about missing attributes.\n    if invalid_settings:\n        msg = \"Missing attributes:\"\n        for item in invalid_settings:\n            msg += f\"\\n{item}\"\n\n        harmony.send(\n            {\"function\": \"AyonHarmony.message\", \"args\": msg})\n\n    set_scene_settings(valid_settings)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.export_backdrop_as_template","title":"<code>export_backdrop_as_template(backdrop, filepath)</code>","text":"<p>Export Backdrop as Template (.tpl) file.</p> <p>Parameters:</p> Name Type Description Default <code>backdrop</code> <code>list</code> <p>Backdrop to export.</p> required <code>filepath</code> <code>str</code> <p>Path where to save Template.</p> required Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def export_backdrop_as_template(backdrop, filepath):\n    \"\"\"Export Backdrop as Template (.tpl) file.\n\n    Args:\n        backdrop (list): Backdrop to export.\n        filepath (str): Path where to save Template.\n    \"\"\"\n    harmony.send({\n        \"function\": \"AyonHarmony.exportBackdropAsTemplate\",\n        \"args\": [\n            backdrop,\n            os.path.basename(filepath),\n            os.path.dirname(filepath)\n        ]\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.get_current_context_settings","title":"<code>get_current_context_settings()</code>","text":"<p>Get settings on current task from server.</p> <p>Returns:</p> Type Description <p>dict[str, Any]: Scene data.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def get_current_context_settings():\n    \"\"\"Get settings on current task from server.\n\n    Returns:\n        dict[str, Any]: Scene data.\n\n    \"\"\"\n\n    task_entity = get_current_task_entity()\n    task_attributes = task_entity[\"attrib\"]\n\n    fps = task_attributes.get(\"fps\")\n    frame_start = task_attributes.get(\"frameStart\")\n    frame_end = task_attributes.get(\"frameEnd\")\n    handle_start = task_attributes.get(\"handleStart\")\n    handle_end = task_attributes.get(\"handleEnd\")\n    resolution_width = task_attributes.get(\"resolutionWidth\")\n    resolution_height = task_attributes.get(\"resolutionHeight\")\n\n    scene_data = {\n        \"fps\": fps,\n        \"frameStart\": frame_start,\n        \"frameEnd\": frame_end,\n        \"handleStart\": handle_start,\n        \"handleEnd\": handle_end,\n        \"resolutionWidth\": resolution_width,\n        \"resolutionHeight\": resolution_height\n    }\n\n    return scene_data\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.inject_ayon_js","title":"<code>inject_ayon_js()</code>","text":"<p>Inject AyonHarmonyAPI.js into Harmony.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def inject_ayon_js():\n    \"\"\"Inject AyonHarmonyAPI.js into Harmony.\"\"\"\n    ayon_harmony_js = Path(__file__).parent.joinpath(\"js/AyonHarmonyAPI.js\")\n    script = ayon_harmony_js.read_text()\n    # send AyonHarmonyAPI.js to Harmony\n    harmony.send({\"script\": script})\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.is_container_data","title":"<code>is_container_data(data)</code>","text":"<p>Return whether data is container data.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def is_container_data(data: dict) -&gt; bool:\n    \"\"\"Return whether data is container data.\"\"\"\n    return data and data.get(\"id\") in {AYON_CONTAINER_ID, AVALON_CONTAINER_ID}\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.ls","title":"<code>ls()</code>","text":"<p>Yields containers from Harmony scene.</p> <p>Clean up scene data from orphaned containers.</p> <p>Yields:</p> Name Type Description <code>dict</code> <p>container</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"Yields containers from Harmony scene.\n\n    Clean up scene data from orphaned containers.\n\n    Yields:\n        dict: container\n    \"\"\"\n    scene_data = harmony.get_scene_data() or dict()\n    all_top_names = harmony.get_all_top_names()\n    cleaned_scene_data = True\n    for entity_name, entity_data in scene_data.copy().items():\n        if not is_container_data(entity_data):\n            continue\n\n        # Filter orphaned containers\n        if entity_name not in all_top_names:\n            del scene_data[entity_name]\n            cleaned_scene_data = True\n            continue\n\n        if not entity_data.get(\"objectName\"):  # backward compatibility\n            entity_data[\"objectName\"] = entity_data[\"name\"]\n        yield entity_data\n\n    # Update scene data if cleaned\n    if cleaned_scene_data:\n        harmony.set_scene_data(scene_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.set_scene_settings","title":"<code>set_scene_settings(settings)</code>","text":"<p>Set correct scene settings in Harmony.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>dict</code> <p>Scene settings.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary of settings to set.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def set_scene_settings(settings):\n    \"\"\"Set correct scene settings in Harmony.\n\n    Args:\n        settings (dict): Scene settings.\n\n    Returns:\n        dict: Dictionary of settings to set.\n\n    \"\"\"\n    harmony.send(\n        {\"function\": \"AyonHarmony.setSceneSettings\", \"args\": settings})\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_harmony/api/plugin.html#client.ayon_harmony.api.plugin.HarmonyCreator","title":"<code>HarmonyCreator</code>","text":"<p>               Bases: <code>Creator</code>, <code>HarmonyCreatorBase</code></p> <p>Creator plugin to create instances in Harmony.</p> <p>By default a Composite node is created to support any number of nodes in an instance, but any node type is supported. If the selection is used, the selected nodes will be connected to the created node.</p> Source code in <code>client/ayon_harmony/api/plugin.py</code> <pre><code>class HarmonyCreator(Creator, HarmonyCreatorBase):\n    \"\"\"Creator plugin to create instances in Harmony.\n\n    By default a Composite node is created to support any number of nodes in\n    an instance, but any node type is supported.\n    If the selection is used, the selected nodes will be connected to the\n    created node.\n    \"\"\"\n\n    settings_category = \"harmony\"\n\n\n    def create(self, product_name, instance_data, pre_create_data):\n        # Create the node\n        node = self.product_impl(product_name, instance_data, pre_create_data)\n\n        instance = CreatedInstance(\n            self.product_type,\n            product_name,\n            instance_data,\n            self\n        )\n        instance.transient_data[\"node\"] = node\n        harmony.imprint(node, instance.data_to_store())\n\n        self._add_instance_to_context(instance)\n\n    def update_instances(self, update_list):\n        for created_inst, _changes in update_list:\n            node = created_inst.transient_data[\"node\"]\n            new_data = created_inst.data_to_store()\n\n            # Use the node's active state to store the instance's active state\n            active = new_data.pop(\"active\", True)\n            harmony.send(\n                {\"function\": \"AyonHarmonyAPI.setState\",\n                 \"args\": [[node], [active]]}\n            )\n\n            harmony.imprint(node, new_data)\n\n    def remove_instances(self, instances):\n        for instance in instances:\n            # There is only ever one workfile instance\n            harmony.delete_node(instance.transient_data[\"node\"])\n            self._remove_instance_from_context(instance)\n\n    def collect_instances(self):\n        cache = self.cache_instance_data(self.collection_shared_data)\n        for node_name in cache.get(\"harmony_cached_instance_data\").get(\n                self.identifier, []):\n            data = cache.get(\"harmony_cached_scene_data\")[node_name]\n\n            product_type = data.get(\"productType\")\n            if product_type is None:\n                product_type = data[\"family\"]\n                data[\"productType\"] = product_type\n            data[\"family\"] = product_type\n\n            instance = CreatedInstance.from_existing(instance_data=data,\n                                                     creator=self)\n            instance.transient_data[\"node\"] = node_name\n\n            # Active state is based of the node's active state\n            instance.data[\"active\"] = harmony.send(\n                {\"function\": \"AyonHarmonyAPI.isEnabled\", \"args\": [node_name]}\n            )[\"result\"]\n\n            self._add_instance_to_context(instance)\n\n    def setup_node(self, node):\n        \"\"\"Prepare node as container.\n\n        Args:\n            node (str): Path to node.\n        \"\"\"\n        harmony.send(\n            {\n                \"function\": \"AyonHarmonyAPI.setupNodeForCreator\",\n                \"args\": node\n            }\n        )\n\n    def product_impl(self, name, instance_data: dict, pre_create_data: dict):\n        raise NotImplementedError\n\n    def get_pre_create_attr_defs(self):\n        output = [\n            BoolDef(\n                \"use_selection\",\n                tooltip=\"Composition for publishable instance should be \"\n                        \"selected by default.\",\n                default=True,\n                label=\"Use selection\"\n            ),\n        ]\n        return output\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/plugin.html#client.ayon_harmony.api.plugin.HarmonyCreator.setup_node","title":"<code>setup_node(node)</code>","text":"<p>Prepare node as container.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>Path to node.</p> required Source code in <code>client/ayon_harmony/api/plugin.py</code> <pre><code>def setup_node(self, node):\n    \"\"\"Prepare node as container.\n\n    Args:\n        node (str): Path to node.\n    \"\"\"\n    harmony.send(\n        {\n            \"function\": \"AyonHarmonyAPI.setupNodeForCreator\",\n            \"args\": node\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/plugin.html#client.ayon_harmony.api.plugin.HarmonyCreatorBase","title":"<code>HarmonyCreatorBase</code>","text":"Source code in <code>client/ayon_harmony/api/plugin.py</code> <pre><code>class HarmonyCreatorBase:\n    @staticmethod\n    def cache_instance_data(shared_data):\n        \"\"\"Cache instances for Creators to shared data.\n\n        Create `maya_cached_instance_data` key when needed in shared data and\n        fill it with all collected instances from the scene under its\n        respective creator identifiers.\n\n        If legacy instances are detected in the scene, create\n        `maya_cached_legacy_instances` there and fill it with\n        all legacy products under product type as a key.\n\n        Args:\n            Dict[str, Any]: Shared data.\n\n        \"\"\"\n        if shared_data.get(\"harmony_cached_instance_data\") is None:\n            cache = dict()\n            cache_legacy = dict()\n\n            # Collect scene data once instead of calling `read()` per node\n            scene_data = harmony.get_scene_data()\n            all_top_names = harmony.get_all_top_names()\n            cleaned_scene_data = False\n            for entity_name, entity_data in reversed(scene_data.copy().items()):\n                # Filter orphaned instances\n                if entity_name not in all_top_names:\n                    del scene_data[entity_name]\n                    cleaned_scene_data = True\n                    continue\n\n                if entity_data.get(\"id\") not in {\n                    AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n                }:\n                    continue\n\n                creator_id = entity_data.get(\"creator_identifier\")\n                if creator_id is not None:\n                    # creator instance\n                    cache.setdefault(creator_id, []).append(entity_name)\n                else:\n                    # legacy instance\n                    product_type = entity_data.get(\n                        \"productType\") or entity_data.get(\"family\")\n\n                    if product_type is None:\n                        # must be a broken instance\n                        continue\n\n                    cache_legacy.setdefault(product_type, []).append(entity_name)\n\n            shared_data[\"harmony_cached_scene_data\"] = scene_data\n            shared_data[\"harmony_cached_instance_data\"] = cache\n            shared_data[\"harmony_cached_legacy_instances_names\"] = cache_legacy\n\n            # Update scene data if cleaned\n            if cleaned_scene_data:\n                harmony.set_scene_data(scene_data)\n\n        return shared_data\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/plugin.html#client.ayon_harmony.api.plugin.HarmonyCreatorBase.cache_instance_data","title":"<code>cache_instance_data(shared_data)</code>  <code>staticmethod</code>","text":"<p>Cache instances for Creators to shared data.</p> <p>Create <code>maya_cached_instance_data</code> key when needed in shared data and fill it with all collected instances from the scene under its respective creator identifiers.</p> <p>If legacy instances are detected in the scene, create <code>maya_cached_legacy_instances</code> there and fill it with all legacy products under product type as a key.</p> <p>Parameters:</p> Name Type Description Default <code>Dict[str,</code> <code>Any]</code> <p>Shared data.</p> required Source code in <code>client/ayon_harmony/api/plugin.py</code> <pre><code>@staticmethod\ndef cache_instance_data(shared_data):\n    \"\"\"Cache instances for Creators to shared data.\n\n    Create `maya_cached_instance_data` key when needed in shared data and\n    fill it with all collected instances from the scene under its\n    respective creator identifiers.\n\n    If legacy instances are detected in the scene, create\n    `maya_cached_legacy_instances` there and fill it with\n    all legacy products under product type as a key.\n\n    Args:\n        Dict[str, Any]: Shared data.\n\n    \"\"\"\n    if shared_data.get(\"harmony_cached_instance_data\") is None:\n        cache = dict()\n        cache_legacy = dict()\n\n        # Collect scene data once instead of calling `read()` per node\n        scene_data = harmony.get_scene_data()\n        all_top_names = harmony.get_all_top_names()\n        cleaned_scene_data = False\n        for entity_name, entity_data in reversed(scene_data.copy().items()):\n            # Filter orphaned instances\n            if entity_name not in all_top_names:\n                del scene_data[entity_name]\n                cleaned_scene_data = True\n                continue\n\n            if entity_data.get(\"id\") not in {\n                AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n            }:\n                continue\n\n            creator_id = entity_data.get(\"creator_identifier\")\n            if creator_id is not None:\n                # creator instance\n                cache.setdefault(creator_id, []).append(entity_name)\n            else:\n                # legacy instance\n                product_type = entity_data.get(\n                    \"productType\") or entity_data.get(\"family\")\n\n                if product_type is None:\n                    # must be a broken instance\n                    continue\n\n                cache_legacy.setdefault(product_type, []).append(entity_name)\n\n        shared_data[\"harmony_cached_scene_data\"] = scene_data\n        shared_data[\"harmony_cached_instance_data\"] = cache\n        shared_data[\"harmony_cached_legacy_instances_names\"] = cache_legacy\n\n        # Update scene data if cleaned\n        if cleaned_scene_data:\n            harmony.set_scene_data(scene_data)\n\n    return shared_data\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/plugin.html#client.ayon_harmony.api.plugin.HarmonyRenderCreator","title":"<code>HarmonyRenderCreator</code>","text":"<p>               Bases: <code>HarmonyCreator</code></p> <p>Creator plugin to create render instances in Harmony.</p> <p>It creates new Composite type node from which it is rendered.</p> Source code in <code>client/ayon_harmony/api/plugin.py</code> <pre><code>class HarmonyRenderCreator(HarmonyCreator):\n    \"\"\"Creator plugin to create render instances in Harmony.\n\n    It creates new Composite type node from which it is rendered.\n    \"\"\"\n    node_type = \"COMPOSITE\"\n    # should node be auto connected to main Composite node for Harmony Advanced\n    auto_connect = False\n    # regex to find main Composite node\n    composition_node_pattern = \"\"\n\n    rendering_targets = {\n        \"local\": \"Local machine rendering\",\n        \"farm\": \"Farm rendering\",\n    }\n\n    def product_impl(self, name, instance_data: dict, pre_create_data: dict):\n        existing_node_names = harmony.send(\n            {\n                \"function\": \"AyonHarmonyAPI.getNodesNamesByType\",\n                \"args\": self.node_type\n            })[\"result\"]\n\n        # Don't allow instances with the same name.\n        name_lower = name.lower()\n        for existing_name in existing_node_names:\n            if name_lower == existing_name.lower():\n                msg = f\"Instance with name \\\"{name}\\\" already exists.\"\n                raise CreatorError(msg)\n\n        use_selection = pre_create_data.get(\"use_selection\", False)\n        if self.auto_connect:\n            existing_comp_names = harmony.send(\n                {\n                    \"function\": \"AyonHarmonyAPI.getNodesNamesByType\",\n                    \"args\": \"COMPOSITE\"\n                })[\"result\"]\n            name_pattern = self.composition_node_pattern\n            if not name_pattern:\n                raise CreatorError(\"Composition name regex pattern \"\n                                   \"must be filled\")\n            compiled_pattern = re.compile(name_pattern)\n            matching_nodes = [name for name in existing_comp_names\n                              if compiled_pattern.match(name)]\n            if len(matching_nodes) &gt; 1:\n                self.log.warning(\"Multiple composition node found, \"\n                                 \"picked first\")\n            elif len(matching_nodes) &lt;= 0:\n                raise CreatorError(\"No matching composition \"\n                                   \"node found\")\n            node_name = f\"/Top/{matching_nodes[0]}\"\n\n            use_selection = True\n            harmony.send(\n                {\n                    \"function\": \"AyonHarmonyAPI.selectNodes\",\n                    \"args\": [node_name]\n                }\n            )\n\n        node = harmony.send(\n            {\n                \"function\": \"AyonHarmonyAPI.createNodeContainer\",\n                \"args\": [name, self.node_type, use_selection]\n            }\n        )[\"result\"]\n        self.setup_node(node)\n\n        instance_data[\"creator_attributes\"] = {\n            \"render_target\": pre_create_data[\"render_target\"]\n        }\n\n        return node\n\n    def get_pre_create_attr_defs(self):\n        output = super().get_pre_create_attr_defs()\n        output.extend([\n            EnumDef(\n                \"render_target\",\n                items=self.rendering_targets,\n                label=\"Render target\"\n            ),\n        ])\n        return output\n\n    def get_instance_attr_defs(self):\n        return [\n            EnumDef(\n                \"render_target\",\n                items=self.rendering_targets,\n                label=\"Render target\"\n            )\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/server.html","title":"server","text":"<p>Server-side implementation of Toon Boon Harmony communication.</p>"},{"location":"autoapi/client/ayon_harmony/api/server.html#client.ayon_harmony.api.server.Server","title":"<code>Server</code>","text":"<p>               Bases: <code>Thread</code></p> <p>Class for communication with Toon Boon Harmony.</p> <p>Attributes:</p> Name Type Description <code>connection</code> <code>Socket</code> <p>connection holding object.</p> <code>received</code> <code>str</code> <p>received data buffer.any(iterable)</p> <code>port</code> <code>int</code> <p>port number.</p> <code>message_id</code> <code>int</code> <p>index of last message going out.</p> <code>queue</code> <code>dict</code> <p>dictionary holding queue of incoming messages.</p> Source code in <code>client/ayon_harmony/api/server.py</code> <pre><code>class Server(threading.Thread):\n    \"\"\"Class for communication with Toon Boon Harmony.\n\n    Attributes:\n        connection (Socket): connection holding object.\n        received (str): received data buffer.any(iterable)\n        port (int): port number.\n        message_id (int): index of last message going out.\n        queue (dict): dictionary holding queue of incoming messages.\n\n    \"\"\"\n\n    def __init__(self, port):\n        \"\"\"Constructor.\"\"\"\n        super(Server, self).__init__()\n        self.daemon = True\n        self.connection = None\n        self.received = \"\"\n        self.port = port\n        self.message_id = 1\n\n        # Setup logging.\n        self.log = logging.getLogger(__name__)\n        self.log.setLevel(logging.DEBUG)\n\n        # Create a TCP/IP socket\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n        # Bind the socket to the port\n        server_address = (\"127.0.0.1\", port)\n        self.log.debug(\n            f\"[{self.timestamp()}] Starting up on \"\n            f\"{server_address[0]}:{server_address[1]}\")\n        self.socket.bind(server_address)\n\n        # Listen for incoming connections\n        self.socket.listen(1)\n        self.queue = {}\n\n    def process_request(self, request):\n        \"\"\"Process incoming request.\n\n        Args:\n            request (dict): {\n                \"module\": (str),  # Module of method.\n                \"method\" (str),  # Name of method in module.\n                \"args\" (list),  # Arguments to pass to method.\n                \"kwargs\" (dict),  # Keyword arguments to pass to method.\n                \"reply\" (bool),  # Optional wait for method completion.\n            }\n        \"\"\"\n        pretty = self._pretty(request)\n        self.log.debug(\n            f\"[{self.timestamp()}] Processing request:\\n{pretty}\")\n\n        # TODO javascript should not define which module is imported and\n        #   which function is called. It should send predefined requests.\n        try:\n            module = importlib.import_module(request[\"module\"])\n            method = getattr(module, request[\"method\"])\n\n            args = request.get(\"args\", [])\n            kwargs = request.get(\"kwargs\", {})\n            partial_method = functools.partial(method, *args, **kwargs)\n\n            lib.ProcessContext.execute_in_main_thread(partial_method)\n        except Exception:\n            self.log.error(traceback.format_exc())\n\n    def receive(self):\n        \"\"\"Receives data from `self.connection`.\n\n        When the data is a json serializable string, a reply is sent then\n        processing of the request.\n        \"\"\"\n        current_time = time.time()\n        while True:\n            # Receive the data in small chunks and retransmit it\n            request = None\n            try:\n                header = self.connection.recv(10)\n            except OSError:\n                # could happen on MacOS\n                self.log.info(\"\")\n                break\n\n            if len(header) == 0:\n                # null data received, socket is closing.\n                self.log.info(f\"[{self.timestamp()}] Connection closing.\")\n                break\n\n            if header[0:2] != b\"AH\":\n                self.log.error(\"INVALID HEADER\")\n            content_length_str = header[2:].decode()\n\n            length = int(content_length_str, 16)\n            data = self.connection.recv(length)\n            while (len(data) &lt; length):\n                # we didn't received everything in first try, lets wait for\n                # all data.\n                self.log.info(\"loop\")\n                time.sleep(0.1)\n                if self.connection is None:\n                    self.log.error(f\"[{self.timestamp()}] \"\n                                   \"Connection is broken\")\n                    break\n                if time.time() &gt; current_time + 30:\n                    self.log.error(f\"[{self.timestamp()}] Connection timeout.\")\n                    break\n\n                data += self.connection.recv(length - len(data))\n            self.log.debug(\"data:: {} {}\".format(data, type(data)))\n            self.received += data.decode(\"utf-8\")\n            pretty = self._pretty(self.received)\n            self.log.debug(\n                f\"[{self.timestamp()}] Received:\\n{pretty}\")\n\n            try:\n                request = json.loads(self.received)\n            except json.decoder.JSONDecodeError as e:\n                self.log.error(f\"[{self.timestamp()}] \"\n                               f\"Invalid message received.\\n{e}\",\n                               exc_info=True)\n\n            self.received = \"\"\n            if request is None:\n                continue\n\n            if \"message_id\" in request.keys():\n                message_id = request[\"message_id\"]\n                self.message_id = message_id + 1\n                self.log.debug(f\"--- storing request as {message_id}\")\n                self.queue[message_id] = request\n            if \"reply\" not in request.keys():\n                request[\"reply\"] = True\n                self.send(request)\n                self.process_request(request)\n\n                if \"message_id\" in request.keys():\n                    try:\n                        self.log.debug(f\"[{self.timestamp()}] \"\n                                       f\"Removing from the queue {message_id}\")\n                        del self.queue[message_id]\n                    except IndexError:\n                        self.log.debug(f\"[{self.timestamp()}] \"\n                                       f\"{message_id} is no longer in queue\")\n            else:\n                self.log.debug(f\"[{self.timestamp()}] \"\n                               \"received data was just a reply.\")\n\n    def run(self):\n        \"\"\"Entry method for server.\n\n        Waits for a connection on `self.port` before going into listen mode.\n        \"\"\"\n        # Wait for a connection\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n        self.log.debug(f\"[{timestamp}] Waiting for a connection.\")\n        self.connection, client_address = self.socket.accept()\n\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n        self.log.debug(f\"[{timestamp}] Connection from: {client_address}\")\n\n        self.receive()\n\n    def stop(self):\n        \"\"\"Shutdown socket server gracefully.\"\"\"\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n        self.log.debug(f\"[{timestamp}] Shutting down server.\")\n        if self.connection is None:\n            self.log.debug(\"Connect to shutdown.\")\n            socket.socket(\n                socket.AF_INET, socket.SOCK_STREAM\n            ).connect((\"localhost\", self.port))\n\n        self.connection.close()\n        self.connection = None\n\n        self.socket.close()\n\n    def _send(self, message):\n        \"\"\"Send a message to Harmony.\n\n        Args:\n            message (str): Data to send to Harmony.\n        \"\"\"\n        # Wait for a connection.\n        while not self.connection:\n            pass\n\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n        encoded = message.encode(\"utf-8\")\n        coded_message = b\"AH\" + struct.pack('&gt;I', len(encoded)) + encoded\n        pretty = self._pretty(coded_message)\n        self.log.debug(\n            f\"[{timestamp}] Sending [{self.message_id}]:\\n{pretty}\")\n        self.log.debug(f\"--- Message length: {len(encoded)}\")\n        self.connection.sendall(coded_message)\n        self.message_id += 1\n\n    def send(self, request):\n        \"\"\"Send a request in dictionary to Harmony.\n\n        Waits for a reply from Harmony.\n\n        Args:\n            request (dict): Data to send to Harmony.\n        \"\"\"\n        request[\"message_id\"] = self.message_id\n        self._send(json.dumps(request))\n        if request.get(\"reply\"):\n            timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n            self.log.debug(\n                f\"[{timestamp}] sent reply, not waiting for anything.\")\n            return None\n        result = None\n        current_time = time.time()\n        try_index = 1\n        while True:\n            time.sleep(0.1)\n            if time.time() &gt; current_time + 30:\n                timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n                self.log.error((f\"[{timestamp}][{self.message_id}] \"\n                                \"No reply from Harmony in 30s. \"\n                                f\"Retrying {try_index}\"))\n                try_index += 1\n                current_time = time.time()\n            if try_index &gt; 30:\n                break\n            try:\n                result = self.queue[request[\"message_id\"]]\n                timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n                self.log.debug((f\"[{timestamp}] Got request \"\n                                f\"id {self.message_id}, \"\n                                \"removing from queue\"))\n                del self.queue[request[\"message_id\"]]\n                break\n            except KeyError:\n                # response not in received queue yey\n                pass\n            try:\n                result = json.loads(self.received)\n                break\n            except json.decoder.JSONDecodeError:\n                pass\n\n        self.received = \"\"\n\n        return result\n\n    def _pretty(self, message) -&gt; str:\n        # result = pformat(message, indent=2)\n        # return result.replace(\"\\\\n\", \"\\n\")\n        return \"{}{}\".format(4 * \" \", message)\n\n    def timestamp(self):\n        \"\"\"Return current timestamp as a string.\n\n        Returns:\n            str: current timestamp.\n\n        \"\"\"\n        return datetime.now().strftime(\"%H:%M:%S.%f\")\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/server.html#client.ayon_harmony.api.server.Server.__init__","title":"<code>__init__(port)</code>","text":"<p>Constructor.</p> Source code in <code>client/ayon_harmony/api/server.py</code> <pre><code>def __init__(self, port):\n    \"\"\"Constructor.\"\"\"\n    super(Server, self).__init__()\n    self.daemon = True\n    self.connection = None\n    self.received = \"\"\n    self.port = port\n    self.message_id = 1\n\n    # Setup logging.\n    self.log = logging.getLogger(__name__)\n    self.log.setLevel(logging.DEBUG)\n\n    # Create a TCP/IP socket\n    self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n    # Bind the socket to the port\n    server_address = (\"127.0.0.1\", port)\n    self.log.debug(\n        f\"[{self.timestamp()}] Starting up on \"\n        f\"{server_address[0]}:{server_address[1]}\")\n    self.socket.bind(server_address)\n\n    # Listen for incoming connections\n    self.socket.listen(1)\n    self.queue = {}\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/server.html#client.ayon_harmony.api.server.Server.process_request","title":"<code>process_request(request)</code>","text":"<p>Process incoming request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>dict</code> <p>{ \"module\": (str),  # Module of method. \"method\" (str),  # Name of method in module. \"args\" (list),  # Arguments to pass to method. \"kwargs\" (dict),  # Keyword arguments to pass to method. \"reply\" (bool),  # Optional wait for method completion.</p> required Source code in <code>client/ayon_harmony/api/server.py</code> <pre><code>def process_request(self, request):\n    \"\"\"Process incoming request.\n\n    Args:\n        request (dict): {\n            \"module\": (str),  # Module of method.\n            \"method\" (str),  # Name of method in module.\n            \"args\" (list),  # Arguments to pass to method.\n            \"kwargs\" (dict),  # Keyword arguments to pass to method.\n            \"reply\" (bool),  # Optional wait for method completion.\n        }\n    \"\"\"\n    pretty = self._pretty(request)\n    self.log.debug(\n        f\"[{self.timestamp()}] Processing request:\\n{pretty}\")\n\n    # TODO javascript should not define which module is imported and\n    #   which function is called. It should send predefined requests.\n    try:\n        module = importlib.import_module(request[\"module\"])\n        method = getattr(module, request[\"method\"])\n\n        args = request.get(\"args\", [])\n        kwargs = request.get(\"kwargs\", {})\n        partial_method = functools.partial(method, *args, **kwargs)\n\n        lib.ProcessContext.execute_in_main_thread(partial_method)\n    except Exception:\n        self.log.error(traceback.format_exc())\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/server.html#client.ayon_harmony.api.server.Server.receive","title":"<code>receive()</code>","text":"<p>Receives data from <code>self.connection</code>.</p> <p>When the data is a json serializable string, a reply is sent then processing of the request.</p> Source code in <code>client/ayon_harmony/api/server.py</code> <pre><code>def receive(self):\n    \"\"\"Receives data from `self.connection`.\n\n    When the data is a json serializable string, a reply is sent then\n    processing of the request.\n    \"\"\"\n    current_time = time.time()\n    while True:\n        # Receive the data in small chunks and retransmit it\n        request = None\n        try:\n            header = self.connection.recv(10)\n        except OSError:\n            # could happen on MacOS\n            self.log.info(\"\")\n            break\n\n        if len(header) == 0:\n            # null data received, socket is closing.\n            self.log.info(f\"[{self.timestamp()}] Connection closing.\")\n            break\n\n        if header[0:2] != b\"AH\":\n            self.log.error(\"INVALID HEADER\")\n        content_length_str = header[2:].decode()\n\n        length = int(content_length_str, 16)\n        data = self.connection.recv(length)\n        while (len(data) &lt; length):\n            # we didn't received everything in first try, lets wait for\n            # all data.\n            self.log.info(\"loop\")\n            time.sleep(0.1)\n            if self.connection is None:\n                self.log.error(f\"[{self.timestamp()}] \"\n                               \"Connection is broken\")\n                break\n            if time.time() &gt; current_time + 30:\n                self.log.error(f\"[{self.timestamp()}] Connection timeout.\")\n                break\n\n            data += self.connection.recv(length - len(data))\n        self.log.debug(\"data:: {} {}\".format(data, type(data)))\n        self.received += data.decode(\"utf-8\")\n        pretty = self._pretty(self.received)\n        self.log.debug(\n            f\"[{self.timestamp()}] Received:\\n{pretty}\")\n\n        try:\n            request = json.loads(self.received)\n        except json.decoder.JSONDecodeError as e:\n            self.log.error(f\"[{self.timestamp()}] \"\n                           f\"Invalid message received.\\n{e}\",\n                           exc_info=True)\n\n        self.received = \"\"\n        if request is None:\n            continue\n\n        if \"message_id\" in request.keys():\n            message_id = request[\"message_id\"]\n            self.message_id = message_id + 1\n            self.log.debug(f\"--- storing request as {message_id}\")\n            self.queue[message_id] = request\n        if \"reply\" not in request.keys():\n            request[\"reply\"] = True\n            self.send(request)\n            self.process_request(request)\n\n            if \"message_id\" in request.keys():\n                try:\n                    self.log.debug(f\"[{self.timestamp()}] \"\n                                   f\"Removing from the queue {message_id}\")\n                    del self.queue[message_id]\n                except IndexError:\n                    self.log.debug(f\"[{self.timestamp()}] \"\n                                   f\"{message_id} is no longer in queue\")\n        else:\n            self.log.debug(f\"[{self.timestamp()}] \"\n                           \"received data was just a reply.\")\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/server.html#client.ayon_harmony.api.server.Server.run","title":"<code>run()</code>","text":"<p>Entry method for server.</p> <p>Waits for a connection on <code>self.port</code> before going into listen mode.</p> Source code in <code>client/ayon_harmony/api/server.py</code> <pre><code>def run(self):\n    \"\"\"Entry method for server.\n\n    Waits for a connection on `self.port` before going into listen mode.\n    \"\"\"\n    # Wait for a connection\n    timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n    self.log.debug(f\"[{timestamp}] Waiting for a connection.\")\n    self.connection, client_address = self.socket.accept()\n\n    timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n    self.log.debug(f\"[{timestamp}] Connection from: {client_address}\")\n\n    self.receive()\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/server.html#client.ayon_harmony.api.server.Server.send","title":"<code>send(request)</code>","text":"<p>Send a request in dictionary to Harmony.</p> <p>Waits for a reply from Harmony.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>dict</code> <p>Data to send to Harmony.</p> required Source code in <code>client/ayon_harmony/api/server.py</code> <pre><code>def send(self, request):\n    \"\"\"Send a request in dictionary to Harmony.\n\n    Waits for a reply from Harmony.\n\n    Args:\n        request (dict): Data to send to Harmony.\n    \"\"\"\n    request[\"message_id\"] = self.message_id\n    self._send(json.dumps(request))\n    if request.get(\"reply\"):\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n        self.log.debug(\n            f\"[{timestamp}] sent reply, not waiting for anything.\")\n        return None\n    result = None\n    current_time = time.time()\n    try_index = 1\n    while True:\n        time.sleep(0.1)\n        if time.time() &gt; current_time + 30:\n            timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n            self.log.error((f\"[{timestamp}][{self.message_id}] \"\n                            \"No reply from Harmony in 30s. \"\n                            f\"Retrying {try_index}\"))\n            try_index += 1\n            current_time = time.time()\n        if try_index &gt; 30:\n            break\n        try:\n            result = self.queue[request[\"message_id\"]]\n            timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n            self.log.debug((f\"[{timestamp}] Got request \"\n                            f\"id {self.message_id}, \"\n                            \"removing from queue\"))\n            del self.queue[request[\"message_id\"]]\n            break\n        except KeyError:\n            # response not in received queue yey\n            pass\n        try:\n            result = json.loads(self.received)\n            break\n        except json.decoder.JSONDecodeError:\n            pass\n\n    self.received = \"\"\n\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/server.html#client.ayon_harmony.api.server.Server.stop","title":"<code>stop()</code>","text":"<p>Shutdown socket server gracefully.</p> Source code in <code>client/ayon_harmony/api/server.py</code> <pre><code>def stop(self):\n    \"\"\"Shutdown socket server gracefully.\"\"\"\n    timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n    self.log.debug(f\"[{timestamp}] Shutting down server.\")\n    if self.connection is None:\n        self.log.debug(\"Connect to shutdown.\")\n        socket.socket(\n            socket.AF_INET, socket.SOCK_STREAM\n        ).connect((\"localhost\", self.port))\n\n    self.connection.close()\n    self.connection = None\n\n    self.socket.close()\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/server.html#client.ayon_harmony.api.server.Server.timestamp","title":"<code>timestamp()</code>","text":"<p>Return current timestamp as a string.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>current timestamp.</p> Source code in <code>client/ayon_harmony/api/server.py</code> <pre><code>def timestamp(self):\n    \"\"\"Return current timestamp as a string.\n\n    Returns:\n        str: current timestamp.\n\n    \"\"\"\n    return datetime.now().strftime(\"%H:%M:%S.%f\")\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/workio.html","title":"workio","text":"<p>Host API required Work Files tool</p>"},{"location":"autoapi/client/ayon_harmony/api/workio.html#client.ayon_harmony.api.workio.current_file","title":"<code>current_file()</code>","text":"<p>Returning None to make Workfiles app look at first file extension.</p> Source code in <code>client/ayon_harmony/api/workio.py</code> <pre><code>def current_file():\n    \"\"\"Returning None to make Workfiles app look at first file extension.\"\"\"\n    return ProcessContext.workfile_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_harmony/hooks/pre_launch_args.html","title":"pre_launch_args","text":""},{"location":"autoapi/client/ayon_harmony/hooks/pre_launch_args.html#client.ayon_harmony.hooks.pre_launch_args.HarmonyPrelaunchHook","title":"<code>HarmonyPrelaunchHook</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Launch arguments preparation.</p> <p>Hook add python executable and script path to Harmony implementation before Harmony executable and add last workfile path to launch arguments.</p> <p>Existence of last workfile is checked. If workfile does not exists tries to copy templated workfile from predefined path.</p> Source code in <code>client/ayon_harmony/hooks/pre_launch_args.py</code> <pre><code>class HarmonyPrelaunchHook(PreLaunchHook):\n    \"\"\"Launch arguments preparation.\n\n    Hook add python executable and script path to Harmony implementation\n    before Harmony executable and add last workfile path to launch arguments.\n\n    Existence of last workfile is checked. If workfile does not exists tries\n    to copy templated workfile from predefined path.\n    \"\"\"\n    app_groups = {\"harmony\"}\n\n    order = 20\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Pop executable\n        executable_path = self.launch_context.launch_args.pop(0)\n\n        # Pop rest of launch arguments - There should not be other arguments!\n        remainders = []\n        while self.launch_context.launch_args:\n            remainders.append(self.launch_context.launch_args.pop(0))\n\n        script_path = get_launch_script_path()\n\n        new_launch_args = get_ayon_launcher_args(\n            \"run\", script_path, executable_path\n        )\n        # Add workfile path if exists\n        workfile_path = self.data[\"last_workfile_path\"]\n        if (\n            self.data.get(\"start_last_workfile\")\n            and workfile_path\n            and os.path.exists(workfile_path)\n        ):\n            new_launch_args.append(workfile_path)\n\n        # Append as whole list as these arguments should not be separated\n        self.launch_context.launch_args.append(new_launch_args)\n\n        if remainders:\n            self.launch_context.launch_args.extend(remainders)\n\n        self.launch_context.kwargs = get_launch_kwargs(\n            self.launch_context.kwargs\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/hooks/pre_launch_args.html#client.ayon_harmony.hooks.pre_launch_args.get_launch_kwargs","title":"<code>get_launch_kwargs(kwargs)</code>","text":"<p>Explicit setting of kwargs for Popen for Harmony.</p> <p>Expected behavior - ayon_console opens window with logs - ayon has stdout/stderr available for capturing</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Union[dict, None]</code> <p>Current kwargs or None.</p> required Source code in <code>client/ayon_harmony/hooks/pre_launch_args.py</code> <pre><code>def get_launch_kwargs(kwargs):\n    \"\"\"Explicit setting of kwargs for Popen for Harmony.\n\n    Expected behavior\n    - ayon_console opens window with logs\n    - ayon has stdout/stderr available for capturing\n\n    Args:\n        kwargs (Union[dict, None]): Current kwargs or None.\n\n    \"\"\"\n    if kwargs is None:\n        kwargs = {}\n\n    if platform.system().lower() != \"windows\":\n        return kwargs\n\n    if is_using_ayon_console():\n        kwargs.update({\n            \"creationflags\": subprocess.CREATE_NEW_CONSOLE\n        })\n    else:\n        kwargs.update({\n            \"creationflags\": subprocess.CREATE_NO_WINDOW,\n            \"stdout\": subprocess.DEVNULL,\n            \"stderr\": subprocess.DEVNULL\n        })\n    return kwargs\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_harmony/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_harmony/plugins/create/convert_legacy.html","title":"convert_legacy","text":"<p>Converter for legacy Harmony products.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/create/convert_legacy.html#client.ayon_harmony.plugins.create.convert_legacy.HarmonyLegacyConvertor","title":"<code>HarmonyLegacyConvertor</code>","text":"<p>               Bases: <code>ProductConvertorPlugin</code></p> <p>Find and convert any legacy products in the scene.</p> <p>This Converter will find all legacy products in the scene and will transform them to the current system. Since the old products doesn't retain any information about their original creators, the only mapping we can do is based on their product types.</p> <p>Its limitation is that you can have multiple creators creating product of the same product type and there is no way to handle it. This code should nevertheless cover all creators that came with OpenPype.</p> Source code in <code>client/ayon_harmony/plugins/create/convert_legacy.py</code> <pre><code>class HarmonyLegacyConvertor(ProductConvertorPlugin):\n    \"\"\"Find and convert any legacy products in the scene.\n\n    This Converter will find all legacy products in the scene and will\n    transform them to the current system. Since the old products doesn't\n    retain any information about their original creators, the only mapping\n    we can do is based on their product types.\n\n    Its limitation is that you can have multiple creators creating product\n    of the same product type and there is no way to handle it. This code\n    should nevertheless cover all creators that came with OpenPype.\n\n    \"\"\"\n    identifier = \"io.ayon.creators.harmony.legacy\"\n    product_type_to_id = {\n        \"render\": \"io.ayon.creators.harmony.render\",\n        \"renderFarm\": \"io.ayon.creators.harmony.render\",\n        \"template\": \"io.ayon.creators.harmony.template\",\n        \"workfile\": \"io.ayon.creators.harmony.workfile\",\n    }\n\n    def __init__(self, *args, **kwargs):\n        super(HarmonyLegacyConvertor, self).__init__(*args, **kwargs)\n        self.legacy_instances = {}\n        self.scene_metadata = {}\n\n    def find_instances(self):\n        \"\"\"Find legacy products in the scene.\n\n        Legacy products are the ones that doesn't have `creator_identifier`\n        parameter on them.\n\n        This is using cached entries done in\n        :py:meth:`~HarmonyCreatorBase.cache_instance_data()`\n\n        \"\"\"\n        self.legacy_instances = self.collection_shared_data.get(\n            \"harmony_cached_legacy_instances_names\")\n        if not self.legacy_instances:\n            return\n        # harmony_cached_scene_data is not accessible in `convert` directly\n        self.scene_metadata = self.collection_shared_data.get(\n            \"harmony_cached_scene_data\")\n        self.add_convertor_item(\n            \"Found {} incompatible product{}\".format(\n                len(self.legacy_instances),\n                \"s\" if len(self.legacy_instances) &gt; 1 else \"\"\n            )\n        )\n\n    def convert(self):\n        \"\"\"Convert all legacy products to current.\n\n        It is enough to add `creator_identifier` and `instance_node`.\n\n        \"\"\"\n        if not self.legacy_instances:\n            return\n\n        for product_type, node_names in self.legacy_instances.items():\n            if product_type not in self.product_type_to_id:\n                continue\n\n            for node_name in node_names:\n                creator_identifier = self.product_type_to_id[product_type]\n                self.log.info(\n                    \"Converting {} to {}\".format(node_name,\n                                                 creator_identifier)\n                )\n                changed_data = {\n                    \"creator_identifier\": creator_identifier,\n                    \"id\": AYON_INSTANCE_ID,\n                    \"creator_attributes\": {\"render_target\": \"local\"}\n                }\n                if product_type == \"renderFarm\":\n                    node_meta = self.scene_metadata[node_name]\n                    changed_data[\"productType\"] = \"render\"\n                    changed_data[\"productName\"] = (\n                        node_meta[\"productName\"].replace(\"Farm\", \"\"))\n                    changed_data[\"creator_attributes\"][\"render_target\"] = \\\n                        \"farm\"\n\n                harmony.imprint(node_name, data=changed_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/convert_legacy.html#client.ayon_harmony.plugins.create.convert_legacy.HarmonyLegacyConvertor.convert","title":"<code>convert()</code>","text":"<p>Convert all legacy products to current.</p> <p>It is enough to add <code>creator_identifier</code> and <code>instance_node</code>.</p> Source code in <code>client/ayon_harmony/plugins/create/convert_legacy.py</code> <pre><code>def convert(self):\n    \"\"\"Convert all legacy products to current.\n\n    It is enough to add `creator_identifier` and `instance_node`.\n\n    \"\"\"\n    if not self.legacy_instances:\n        return\n\n    for product_type, node_names in self.legacy_instances.items():\n        if product_type not in self.product_type_to_id:\n            continue\n\n        for node_name in node_names:\n            creator_identifier = self.product_type_to_id[product_type]\n            self.log.info(\n                \"Converting {} to {}\".format(node_name,\n                                             creator_identifier)\n            )\n            changed_data = {\n                \"creator_identifier\": creator_identifier,\n                \"id\": AYON_INSTANCE_ID,\n                \"creator_attributes\": {\"render_target\": \"local\"}\n            }\n            if product_type == \"renderFarm\":\n                node_meta = self.scene_metadata[node_name]\n                changed_data[\"productType\"] = \"render\"\n                changed_data[\"productName\"] = (\n                    node_meta[\"productName\"].replace(\"Farm\", \"\"))\n                changed_data[\"creator_attributes\"][\"render_target\"] = \\\n                    \"farm\"\n\n            harmony.imprint(node_name, data=changed_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/convert_legacy.html#client.ayon_harmony.plugins.create.convert_legacy.HarmonyLegacyConvertor.find_instances","title":"<code>find_instances()</code>","text":"<p>Find legacy products in the scene.</p> <p>Legacy products are the ones that doesn't have <code>creator_identifier</code> parameter on them.</p> <p>This is using cached entries done in :py:meth:<code>~HarmonyCreatorBase.cache_instance_data()</code></p> Source code in <code>client/ayon_harmony/plugins/create/convert_legacy.py</code> <pre><code>def find_instances(self):\n    \"\"\"Find legacy products in the scene.\n\n    Legacy products are the ones that doesn't have `creator_identifier`\n    parameter on them.\n\n    This is using cached entries done in\n    :py:meth:`~HarmonyCreatorBase.cache_instance_data()`\n\n    \"\"\"\n    self.legacy_instances = self.collection_shared_data.get(\n        \"harmony_cached_legacy_instances_names\")\n    if not self.legacy_instances:\n        return\n    # harmony_cached_scene_data is not accessible in `convert` directly\n    self.scene_metadata = self.collection_shared_data.get(\n        \"harmony_cached_scene_data\")\n    self.add_convertor_item(\n        \"Found {} incompatible product{}\".format(\n            len(self.legacy_instances),\n            \"s\" if len(self.legacy_instances) &gt; 1 else \"\"\n        )\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_render.html","title":"create_render","text":"<p>Create render node.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_render.html#client.ayon_harmony.plugins.create.create_render.CreateRender","title":"<code>CreateRender</code>","text":"<p>               Bases: <code>HarmonyRenderCreator</code></p> <p>Composite node for publishing renders.</p> Source code in <code>client/ayon_harmony/plugins/create/create_render.py</code> <pre><code>class CreateRender(plugin.HarmonyRenderCreator):\n    \"\"\"Composite node for publishing renders.\"\"\"\n\n    identifier = \"io.ayon.creators.harmony.render\"\n    label = \"Render\"\n    product_type = \"render\"\n    icon = \"eye\"\n\n    node_type = \"WRITE\"\n\n    def setup_node(self, node):\n        \"\"\"Set render node.\"\"\"\n        self_name = self.__class__.__name__\n        path = \"render/{0}/{0}.\".format(node.split(\"/\")[-1])\n        harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Creators.{self_name}.create\",\n                \"args\": [node, path]\n            })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_render.html#client.ayon_harmony.plugins.create.create_render.CreateRender.setup_node","title":"<code>setup_node(node)</code>","text":"<p>Set render node.</p> Source code in <code>client/ayon_harmony/plugins/create/create_render.py</code> <pre><code>def setup_node(self, node):\n    \"\"\"Set render node.\"\"\"\n    self_name = self.__class__.__name__\n    path = \"render/{0}/{0}.\".format(node.split(\"/\")[-1])\n    harmony.send(\n        {\n            \"function\": f\"AyonHarmony.Creators.{self_name}.create\",\n            \"args\": [node, path]\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_template.html","title":"create_template","text":""},{"location":"autoapi/client/ayon_harmony/plugins/create/create_template.html#client.ayon_harmony.plugins.create.create_template.CreateTemplate","title":"<code>CreateTemplate</code>","text":"<p>               Bases: <code>HarmonyCreator</code></p> <p>Use existing Backdrop or create new one around selected nodes.</p> <p>Publishable template is marked as Backdrop wrapping node(s)</p> Source code in <code>client/ayon_harmony/plugins/create/create_template.py</code> <pre><code>class CreateTemplate(plugin.HarmonyCreator):\n    \"\"\"Use existing Backdrop or create new one around selected nodes.\n\n    Publishable template is marked as Backdrop wrapping node(s)\n    \"\"\"\n\n    identifier = \"io.ayon.creators.harmony.template\"\n    label = \"Template\"\n    product_type = \"harmony.template\"\n    icon = \"cubes\"\n\n    def product_impl(self, name, instance_data: dict, pre_create_data: dict):\n        args = [name, pre_create_data.get(\"use_selection\") ]\n        backdrop = harmony.send(\n            {\n                \"function\": \"AyonHarmonyAPI.createBackdropContainer\",\n                \"args\": args\n            }\n        )[\"result\"]\n\n        return backdrop[\"title\"][\"text\"]\n\n    def remove_instances(self, instances):\n        for instance in instances:\n            container_name = instance.transient_data[\"node\"]\n            container_backdrop = harmony.find_backdrop_by_name(container_name)\n            harmony.send(\n                {\"function\": \"AyonHarmony.removeBackdropWithContents\", \"args\": container_backdrop}\n            )\n            harmony.remove(container_name)\n            self._remove_instance_from_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_workfile.html","title":"create_workfile","text":"<p>Creator plugin for creating workfiles.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_workfile.html#client.ayon_harmony.plugins.create.create_workfile.CreateWorkfile","title":"<code>CreateWorkfile</code>","text":"<p>               Bases: <code>HarmonyCreatorBase</code>, <code>AutoCreator</code></p> <p>Workfile auto-creator.</p> Source code in <code>client/ayon_harmony/plugins/create/create_workfile.py</code> <pre><code>class CreateWorkfile(plugin.HarmonyCreatorBase, AutoCreator):\n    \"\"\"Workfile auto-creator.\"\"\"\n    identifier = \"io.ayon.creators.harmony.workfile\"\n    label = \"Workfile\"\n    product_type = \"workfile\"\n    icon = \"fa5.file\"\n\n    default_variant = \"Main\"\n\n    # Placeholder node name for where we store the workfile data.\n    # This does not create an actual Harmony node, but just uses this name\n    # as key in the AYON Harmony scene data.\n    _node_name = \"__workfile__\"\n\n    def create(self):\n\n        variant = self.default_variant\n        current_instance = next(\n            (\n                instance for instance in self.create_context.instances\n                if instance.creator_identifier == self.identifier\n            ), None)\n\n        project_name = self.project_name\n        folder_entity = self.create_context.get_current_folder_entity()\n        task_entity = self.create_context.get_current_task_entity()\n        host_name = self.create_context.host_name\n\n        if current_instance is None:\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                variant,\n                host_name,\n            )\n            data = {\n                \"folderPath\": folder_entity[\"path\"],\n                \"task\": task_entity[\"name\"],\n                \"variant\": variant\n            }\n            data.update(\n                self.get_dynamic_data(\n                    project_name,\n                    folder_entity,\n                    task_entity,\n                    variant,\n                    host_name,\n                    current_instance)\n            )\n            self.log.info(\"Auto-creating workfile instance...\")\n            current_instance = CreatedInstance(\n                self.product_type, product_name, data, self\n            )\n            self._add_instance_to_context(current_instance)\n        elif (\n            current_instance[\"folderPath\"] != folder_entity[\"path\"]\n            or current_instance[\"task\"] != task_entity[\"name\"]\n        ):\n            # Update instance context if is not the same\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                variant,\n                host_name,\n            )\n\n            current_instance[\"folderPath\"] = folder_entity[\"path\"]\n            current_instance[\"task\"] = task_entity[\"name\"]\n            current_instance[\"productName\"] = product_name\n\n        current_instance.transient_data[\"node\"] = self._node_name\n\n    def collect_instances(self):\n        cache = self.cache_instance_data(self.collection_shared_data)\n        for node in cache.get(\"harmony_cached_instance_data\").get(\n                self.identifier, []):\n            data = cache.get(\"harmony_cached_scene_data\")[node]\n            created_instance = CreatedInstance.from_existing(data, self)\n            created_instance.transient_data[\"node\"] = self._node_name\n            self._add_instance_to_context(created_instance)\n\n    def update_instances(self, update_list):\n        for created_inst, _changes in update_list:\n            lib.imprint(self._node_name, created_inst.data_to_store())\n\n    def remove_instances(self, instances):\n        for instance in instances:\n            scene_data = lib.get_scene_data()\n            scene_data.pop(self._node_name, None)\n            lib.set_scene_data(scene_data)\n\n            self._remove_instance_from_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_harmony/plugins/load/load_audio.html","title":"load_audio","text":""},{"location":"autoapi/client/ayon_harmony/plugins/load/load_audio.html#client.ayon_harmony.plugins.load.load_audio.ImportAudioLoader","title":"<code>ImportAudioLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Import audio.</p> Source code in <code>client/ayon_harmony/plugins/load/load_audio.py</code> <pre><code>class ImportAudioLoader(load.LoaderPlugin):\n    \"\"\"Import audio.\"\"\"\n\n    product_types = {\"shot\", \"audio\"}\n    representations = {\"wav\"}\n    label = \"Import Audio\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        wav_file = get_representation_path(context[\"representation\"])\n        harmony.send(\n            {\"function\": func, \"args\": [context[\"product\"][\"name\"], wav_file]}\n        )\n\n        product_name = context[\"product\"][\"name\"]\n\n        return harmony.containerise(\n            product_name,\n            namespace,\n            product_name,\n            context,\n            self.__class__.__name__\n        )\n\n    def update(self, container, context):\n        pass\n\n    def remove(self, container):\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_background.html","title":"load_background","text":""},{"location":"autoapi/client/ayon_harmony/plugins/load/load_background.html#client.ayon_harmony.plugins.load.load_background.BackgroundLoader","title":"<code>BackgroundLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load images Stores the imported product in a container named after the product.</p> Source code in <code>client/ayon_harmony/plugins/load/load_background.py</code> <pre><code>class BackgroundLoader(load.LoaderPlugin):\n    \"\"\"Load images\n    Stores the imported product in a container named after the product.\n    \"\"\"\n    product_types = {\"background\"}\n    representations = {\"json\"}\n\n    def load(self, context, name=None, namespace=None, data=None):\n\n        path = self.filepath_from_context(context)\n        with open(path) as json_file:\n            data = json.load(json_file)\n\n        layers = list()\n\n        for child in data['children']:\n            if child.get(\"filename\"):\n                layers.append(child[\"filename\"])\n            else:\n                for layer in child['children']:\n                    if layer.get(\"filename\"):\n                        layers.append(layer[\"filename\"])\n\n        bg_folder = os.path.dirname(path)\n\n        product_name = context[\"product\"][\"name\"]\n        # read_node_name += \"_{}\".format(uuid.uuid4())\n        container_nodes = []\n\n        for layer in sorted(layers):\n            file_to_import = [\n                os.path.join(bg_folder, layer).replace(\"\\\\\", \"/\")\n            ]\n\n            read_node = harmony.send(\n                {\n                    \"function\": copy_files + import_files,\n                    \"args\": [\"Top\", file_to_import, layer, 1]\n                }\n            )[\"result\"]\n            container_nodes.append(read_node)\n\n        return harmony.containerise(\n            product_name,\n            namespace,\n            product_name,\n            context,\n            self.__class__.__name__,\n            nodes=container_nodes\n        )\n\n    def update(self, container, context):\n        repre_entity = context[\"representation\"]\n        path = get_representation_path(repre_entity)\n        with open(path) as json_file:\n            data = json.load(json_file)\n\n        layers = list()\n\n        for child in data['children']:\n            if child.get(\"filename\"):\n                print(child[\"filename\"])\n                layers.append(child[\"filename\"])\n            else:\n                for layer in child['children']:\n                    if layer.get(\"filename\"):\n                        print(layer[\"filename\"])\n                        layers.append(layer[\"filename\"])\n\n        bg_folder = os.path.dirname(path)\n\n        print(container)\n\n        is_latest = is_representation_from_latest(repre_entity)\n        for layer in sorted(layers):\n            file_to_import = [\n                os.path.join(bg_folder, layer).replace(\"\\\\\", \"/\")\n            ]\n            print(20 * \"#\")\n            print(f\"FILE TO REPLACE: {file_to_import}\")\n            print(f\"LAYER: {layer}\")\n            node = harmony.find_node_by_name(layer, \"READ\")\n            print(f\"{node}\")\n\n            if node in container['nodes']:\n                harmony.send(\n                    {\n                        \"function\": copy_files + replace_files,\n                        \"args\": [file_to_import, node, 1]\n                    }\n                )\n            else:\n                read_node = harmony.send(\n                    {\n                        \"function\": copy_files + import_files,\n                        \"args\": [\"Top\", file_to_import, layer, 1]\n                    }\n                )[\"result\"]\n                container['nodes'].append(read_node)\n\n            # Colour node.\n            sig = harmony.signature(\"set_color\")\n            func = \"\"\"function %s(args){\n                for( var i =0; i &lt;= args[0].length - 1; ++i)\n                {\n                    var red_color = new ColorRGBA(255, 0, 0, 255);\n                    var green_color = new ColorRGBA(0, 255, 0, 255);\n                    if (args[1] == \"red\"){\n                        node.setColor(args[0], red_color);\n                    }\n                    if (args[1] == \"green\"){\n                        node.setColor(args[0], green_color);\n                    }\n                }\n            }\n            %s\n            \"\"\" % (sig, sig)\n            if is_latest:\n                harmony.send({\"function\": func, \"args\": [node, \"green\"]})\n            else:\n                harmony.send({\"function\": func, \"args\": [node, \"red\"]})\n\n        harmony.imprint(\n            container['name'],\n            {\n                \"representation\": repre_entity[\"id\"],\n                \"nodes\": container[\"nodes\"]\n            }\n        )\n\n    def remove(self, container):\n        for node in container.get(\"nodes\"):\n\n            func = \"\"\"function deleteNode(_node)\n            {\n                node.deleteNode(_node, true, true);\n            }\n            deleteNode\n            \"\"\"\n            harmony.send(\n                {\"function\": func, \"args\": [node]}\n            )\n            harmony.imprint(container['name'], {}, remove=True)\n\n    def switch(self, container, context):\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_imagesequence.html","title":"load_imagesequence","text":"<p>Loader for image sequences.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_imagesequence.html#client.ayon_harmony.plugins.load.load_imagesequence.ImageSequenceLoader","title":"<code>ImageSequenceLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load image sequences.</p> <p>Stores the imported product in a container named after the product.</p> Source code in <code>client/ayon_harmony/plugins/load/load_imagesequence.py</code> <pre><code>class ImageSequenceLoader(load.LoaderPlugin):\n    \"\"\"Load image sequences.\n\n    Stores the imported product in a container named after the product.\n    \"\"\"\n\n    product_types = {\n        \"shot\",\n        \"render\",\n        \"image\",\n        \"plate\",\n        \"reference\",\n        \"review\",\n    }\n    representations = {\"*\"}\n    extensions = {\"jpeg\", \"png\", \"jpg\"}\n    settings_category = \"harmony\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        \"\"\"Plugin entry point.\n\n        Args:\n            context (:class:`pyblish.api.Context`): Context.\n            name (str, optional): Container name.\n            namespace (str, optional): Container namespace.\n            data (dict, optional): Additional data passed into loader.\n\n        \"\"\"\n        fname = Path(self.filepath_from_context(context))\n        self_name = self.__class__.__name__\n        collections, remainder = clique.assemble(\n            os.listdir(fname.parent.as_posix())\n        )\n        files = []\n        if collections:\n            for f in list(collections[0]):\n                files.append(fname.parent.joinpath(f).as_posix())\n        else:\n            files.append(fname.parent.joinpath(remainder[0]).as_posix())\n\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        group_id = str(uuid.uuid4())\n        read_node = harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Loaders.{self_name}.importFiles\",  # noqa: E501\n                \"args\": [\n                    files,\n                    folder_name,\n                    product_name,\n                    1,\n                    group_id\n                ]\n            }\n        )[\"result\"]\n\n        return harmony.containerise(\n            f\"{folder_name}_{product_name}\",\n            namespace,\n            read_node,\n            context,\n            self_name,\n            nodes=[read_node]\n        )\n\n    def update(self, container, context):\n        \"\"\"Update loaded containers.\n\n        Args:\n            container (dict): Container data.\n            context (dict): Representation context data.\n\n        \"\"\"\n        self_name = self.__class__.__name__\n        node = container.get(\"nodes\").pop()\n\n        repre_entity = context[\"representation\"]\n        path = get_representation_path(repre_entity)\n        collections, remainder = clique.assemble(\n            os.listdir(os.path.dirname(path))\n        )\n        files = []\n        if collections:\n            for f in list(collections[0]):\n                files.append(\n                    os.path.join(\n                        os.path.dirname(path), f\n                    ).replace(\"\\\\\", \"/\")\n                )\n        else:\n            files.append(\n                os.path.join(\n                    os.path.dirname(path), remainder[0]\n                ).replace(\"\\\\\", \"/\")\n            )\n\n        harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Loaders.{self_name}.replaceFiles\",\n                \"args\": [files, node, 1]\n            }\n        )\n\n        # Colour node.\n        if is_representation_from_latest(repre_entity):\n            harmony.send(\n                {\n                    \"function\": \"AyonHarmony.setColor\",\n                    \"args\": [node, [0, 255, 0, 255]]\n                })\n        else:\n            harmony.send(\n                {\n                    \"function\": \"AyonHarmony.setColor\",\n                    \"args\": [node, [255, 0, 0, 255]]\n                })\n\n        harmony.imprint(\n            node, {\"representation\": repre_entity[\"id\"]}\n        )\n\n    def remove(self, container):\n        \"\"\"Remove loaded container.\n\n        Args:\n            container (dict): Container data.\n\n        \"\"\"\n        node = container.get(\"nodes\").pop()\n        harmony.send(\n            {\"function\": \"AyonHarmony.deleteNode\", \"args\": [node]}\n        )\n        harmony.imprint(node, {}, remove=True)\n\n    def switch(self, container, context):\n        \"\"\"Switch loaded representations.\"\"\"\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_imagesequence.html#client.ayon_harmony.plugins.load.load_imagesequence.ImageSequenceLoader.load","title":"<code>load(context, name=None, namespace=None, data=None)</code>","text":"<p>Plugin entry point.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <p>class:<code>pyblish.api.Context</code>): Context.</p> required <code>name</code> <code>str</code> <p>Container name.</p> <code>None</code> <code>namespace</code> <code>str</code> <p>Container namespace.</p> <code>None</code> <code>data</code> <code>dict</code> <p>Additional data passed into loader.</p> <code>None</code> Source code in <code>client/ayon_harmony/plugins/load/load_imagesequence.py</code> <pre><code>def load(self, context, name=None, namespace=None, data=None):\n    \"\"\"Plugin entry point.\n\n    Args:\n        context (:class:`pyblish.api.Context`): Context.\n        name (str, optional): Container name.\n        namespace (str, optional): Container namespace.\n        data (dict, optional): Additional data passed into loader.\n\n    \"\"\"\n    fname = Path(self.filepath_from_context(context))\n    self_name = self.__class__.__name__\n    collections, remainder = clique.assemble(\n        os.listdir(fname.parent.as_posix())\n    )\n    files = []\n    if collections:\n        for f in list(collections[0]):\n            files.append(fname.parent.joinpath(f).as_posix())\n    else:\n        files.append(fname.parent.joinpath(remainder[0]).as_posix())\n\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    group_id = str(uuid.uuid4())\n    read_node = harmony.send(\n        {\n            \"function\": f\"AyonHarmony.Loaders.{self_name}.importFiles\",  # noqa: E501\n            \"args\": [\n                files,\n                folder_name,\n                product_name,\n                1,\n                group_id\n            ]\n        }\n    )[\"result\"]\n\n    return harmony.containerise(\n        f\"{folder_name}_{product_name}\",\n        namespace,\n        read_node,\n        context,\n        self_name,\n        nodes=[read_node]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_imagesequence.html#client.ayon_harmony.plugins.load.load_imagesequence.ImageSequenceLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove loaded container.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>dict</code> <p>Container data.</p> required Source code in <code>client/ayon_harmony/plugins/load/load_imagesequence.py</code> <pre><code>def remove(self, container):\n    \"\"\"Remove loaded container.\n\n    Args:\n        container (dict): Container data.\n\n    \"\"\"\n    node = container.get(\"nodes\").pop()\n    harmony.send(\n        {\"function\": \"AyonHarmony.deleteNode\", \"args\": [node]}\n    )\n    harmony.imprint(node, {}, remove=True)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_imagesequence.html#client.ayon_harmony.plugins.load.load_imagesequence.ImageSequenceLoader.switch","title":"<code>switch(container, context)</code>","text":"<p>Switch loaded representations.</p> Source code in <code>client/ayon_harmony/plugins/load/load_imagesequence.py</code> <pre><code>def switch(self, container, context):\n    \"\"\"Switch loaded representations.\"\"\"\n    self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_imagesequence.html#client.ayon_harmony.plugins.load.load_imagesequence.ImageSequenceLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update loaded containers.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>dict</code> <p>Container data.</p> required <code>context</code> <code>dict</code> <p>Representation context data.</p> required Source code in <code>client/ayon_harmony/plugins/load/load_imagesequence.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update loaded containers.\n\n    Args:\n        container (dict): Container data.\n        context (dict): Representation context data.\n\n    \"\"\"\n    self_name = self.__class__.__name__\n    node = container.get(\"nodes\").pop()\n\n    repre_entity = context[\"representation\"]\n    path = get_representation_path(repre_entity)\n    collections, remainder = clique.assemble(\n        os.listdir(os.path.dirname(path))\n    )\n    files = []\n    if collections:\n        for f in list(collections[0]):\n            files.append(\n                os.path.join(\n                    os.path.dirname(path), f\n                ).replace(\"\\\\\", \"/\")\n            )\n    else:\n        files.append(\n            os.path.join(\n                os.path.dirname(path), remainder[0]\n            ).replace(\"\\\\\", \"/\")\n        )\n\n    harmony.send(\n        {\n            \"function\": f\"AyonHarmony.Loaders.{self_name}.replaceFiles\",\n            \"args\": [files, node, 1]\n        }\n    )\n\n    # Colour node.\n    if is_representation_from_latest(repre_entity):\n        harmony.send(\n            {\n                \"function\": \"AyonHarmony.setColor\",\n                \"args\": [node, [0, 255, 0, 255]]\n            })\n    else:\n        harmony.send(\n            {\n                \"function\": \"AyonHarmony.setColor\",\n                \"args\": [node, [255, 0, 0, 255]]\n            })\n\n    harmony.imprint(\n        node, {\"representation\": repre_entity[\"id\"]}\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_palette.html","title":"load_palette","text":""},{"location":"autoapi/client/ayon_harmony/plugins/load/load_palette.html#client.ayon_harmony.plugins.load.load_palette.ImportPaletteLoader","title":"<code>ImportPaletteLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Import palettes.</p> Source code in <code>client/ayon_harmony/plugins/load/load_palette.py</code> <pre><code>class ImportPaletteLoader(load.LoaderPlugin):\n    \"\"\"Import palettes.\"\"\"\n\n    product_types = {\"palette\", \"harmony.palette\"}\n    representations = {\"plt\"}\n    label = \"Import Palette\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        name = self.load_palette(context[\"representation\"])\n\n        return harmony.containerise(\n            name,\n            namespace,\n            name,\n            context,\n            self.__class__.__name__\n        )\n\n    def load_palette(self, context):\n        product_name = context[\"product\"][\"name\"]\n        repre_entity = context[\"representation\"]\n        name = product_name.replace(\"palette\", \"\")\n\n        # Overwrite palette on disk.\n        scene_path = harmony.send(\n            {\"function\": \"scene.currentProjectPath\"}\n        )[\"result\"]\n        src = get_representation_path(repre_entity)\n        dst = os.path.join(\n            scene_path,\n            \"palette-library\",\n            \"{}.plt\".format(name)\n        )\n        shutil.copy(src, dst)\n\n        harmony.save_scene()\n\n        msg = \"Updated {}.\".format(product_name)\n        msg += \" You need to reload the scene to see the changes.\\n\"\n        msg += \"Please save workfile when ready and use Workfiles \"\n        msg += \"to reopen it.\"\n\n        harmony.send(\n            {\n                \"function\": \"AyonHarmony.message\",\n                \"args\": msg\n            })\n        return name\n\n    def remove(self, container):\n        harmony.remove(container[\"name\"])\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def update(self, container, context):\n        self.remove(container)\n        name = self.load_palette(context)\n\n        repre_entity = context[\"representation\"]\n        container[\"representation\"] = repre_entity[\"id\"]\n        container[\"name\"] = name\n        harmony.imprint(name, container)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_template.html","title":"load_template","text":"<p>Load template.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_template.html#client.ayon_harmony.plugins.load.load_template.TemplateLoader","title":"<code>TemplateLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load Harmony template as Backdrop container.</p> Source code in <code>client/ayon_harmony/plugins/load/load_template.py</code> <pre><code>class TemplateLoader(load.LoaderPlugin):\n    \"\"\"Load Harmony template as Backdrop container.\"\"\"\n\n    product_types = {\"harmony.template\"}\n    representations = {\"tpl\"}\n    label = \"Load Template\"\n    icon = \"gift\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        \"\"\"Plugin entry point.\n\n        Args:\n            context (:class:`pyblish.api.Context`): Context.\n            name (str, optional): Container name.\n            namespace (str, optional): Container namespace.\n            data (dict, optional): Additional data passed into loader.\n\n        \"\"\"\n        # Load template.\n        self_name = self.__class__.__name__\n        temp_dir = tempfile.mkdtemp()\n        zip_file = get_representation_path(context[\"representation\"])\n        template_path = os.path.join(temp_dir)\n        with zipfile.ZipFile(zip_file, \"r\") as zip_ref:\n            zip_ref.extractall(template_path)\n\n        backdrop_name = harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Loaders.{self_name}.loadContainer\",\n                \"args\": os.path.join(template_path, \"harmony.tpl\")\n            }\n        )[\"result\"]\n\n        # Cleanup the temp directory\n        shutil.rmtree(temp_dir)\n\n        # We must validate the group_node\n        return harmony.containerise(\n            name,\n            namespace,\n            backdrop_name,\n            context,\n            self_name\n        )\n\n    def remove(self, container):\n        \"\"\"Remove container.\n\n        Args:\n            container (dict): container definition.\n        \"\"\"\n        container_backdrop = harmony.find_backdrop_by_name(container[\"name\"])\n        harmony.send(\n            {\"function\": \"AyonHarmony.removeBackdropWithContents\", \"args\": container_backdrop}\n        )\n        harmony.remove(container[\"name\"])\n\n    def update(self, container, context):\n        \"\"\"Update loaded containers.\n\n        Args:\n            container (dict): Container data.\n            context (dict): Representation context data.\n\n        \"\"\"\n        return self.switch(container, context)\n\n    def switch(self, container, context):\n        \"\"\"Switch representation containers.\"\"\"\n        backdrop_name = container[\"name\"]\n        backdrop = harmony.find_backdrop_by_name(backdrop_name)\n\n        # Keep backdrop links\n        backdrop_links = harmony.send(\n            {\n                \"function\": \"AyonHarmony.getBackdropLinks\",\n                \"args\": backdrop,\n            }\n        )[\"result\"]\n\n        # Replace template container\n        self.remove(container)  # Before load to avoid node name incrementation\n        container = self.load(context, container[\"name\"], container[\"namespace\"])\n\n        # Restore backdrop links\n        harmony.send(\n            {\n                \"function\": \"AyonHarmony.setNodesLinks\",\n                \"args\": backdrop_links\n            }\n        )\n\n        return container\n\n    def _set_green(self, node): # TODO refactor for backdrop\n        \"\"\"Set node color to green `rgba(0, 255, 0, 255)`.\"\"\"\n        harmony.send(\n            {\n                \"function\": \"AyonHarmony.setColor\",\n                \"args\": [node, [0, 255, 0, 255]]\n            })\n\n    def _set_red(self, node): # TODO refactor for backdrop\n        \"\"\"Set node color to red `rgba(255, 0, 0, 255)`.\"\"\"\n        harmony.send(\n            {\n                \"function\": \"AyonHarmony.setColor\",\n                \"args\": [node, [255, 0, 0, 255]]\n            })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_template.html#client.ayon_harmony.plugins.load.load_template.TemplateLoader.load","title":"<code>load(context, name=None, namespace=None, data=None)</code>","text":"<p>Plugin entry point.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <p>class:<code>pyblish.api.Context</code>): Context.</p> required <code>name</code> <code>str</code> <p>Container name.</p> <code>None</code> <code>namespace</code> <code>str</code> <p>Container namespace.</p> <code>None</code> <code>data</code> <code>dict</code> <p>Additional data passed into loader.</p> <code>None</code> Source code in <code>client/ayon_harmony/plugins/load/load_template.py</code> <pre><code>def load(self, context, name=None, namespace=None, data=None):\n    \"\"\"Plugin entry point.\n\n    Args:\n        context (:class:`pyblish.api.Context`): Context.\n        name (str, optional): Container name.\n        namespace (str, optional): Container namespace.\n        data (dict, optional): Additional data passed into loader.\n\n    \"\"\"\n    # Load template.\n    self_name = self.__class__.__name__\n    temp_dir = tempfile.mkdtemp()\n    zip_file = get_representation_path(context[\"representation\"])\n    template_path = os.path.join(temp_dir)\n    with zipfile.ZipFile(zip_file, \"r\") as zip_ref:\n        zip_ref.extractall(template_path)\n\n    backdrop_name = harmony.send(\n        {\n            \"function\": f\"AyonHarmony.Loaders.{self_name}.loadContainer\",\n            \"args\": os.path.join(template_path, \"harmony.tpl\")\n        }\n    )[\"result\"]\n\n    # Cleanup the temp directory\n    shutil.rmtree(temp_dir)\n\n    # We must validate the group_node\n    return harmony.containerise(\n        name,\n        namespace,\n        backdrop_name,\n        context,\n        self_name\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_template.html#client.ayon_harmony.plugins.load.load_template.TemplateLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove container.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>dict</code> <p>container definition.</p> required Source code in <code>client/ayon_harmony/plugins/load/load_template.py</code> <pre><code>def remove(self, container):\n    \"\"\"Remove container.\n\n    Args:\n        container (dict): container definition.\n    \"\"\"\n    container_backdrop = harmony.find_backdrop_by_name(container[\"name\"])\n    harmony.send(\n        {\"function\": \"AyonHarmony.removeBackdropWithContents\", \"args\": container_backdrop}\n    )\n    harmony.remove(container[\"name\"])\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_template.html#client.ayon_harmony.plugins.load.load_template.TemplateLoader.switch","title":"<code>switch(container, context)</code>","text":"<p>Switch representation containers.</p> Source code in <code>client/ayon_harmony/plugins/load/load_template.py</code> <pre><code>def switch(self, container, context):\n    \"\"\"Switch representation containers.\"\"\"\n    backdrop_name = container[\"name\"]\n    backdrop = harmony.find_backdrop_by_name(backdrop_name)\n\n    # Keep backdrop links\n    backdrop_links = harmony.send(\n        {\n            \"function\": \"AyonHarmony.getBackdropLinks\",\n            \"args\": backdrop,\n        }\n    )[\"result\"]\n\n    # Replace template container\n    self.remove(container)  # Before load to avoid node name incrementation\n    container = self.load(context, container[\"name\"], container[\"namespace\"])\n\n    # Restore backdrop links\n    harmony.send(\n        {\n            \"function\": \"AyonHarmony.setNodesLinks\",\n            \"args\": backdrop_links\n        }\n    )\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_template.html#client.ayon_harmony.plugins.load.load_template.TemplateLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update loaded containers.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>dict</code> <p>Container data.</p> required <code>context</code> <code>dict</code> <p>Representation context data.</p> required Source code in <code>client/ayon_harmony/plugins/load/load_template.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update loaded containers.\n\n    Args:\n        container (dict): Container data.\n        context (dict): Representation context data.\n\n    \"\"\"\n    return self.switch(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_template_workfile.html","title":"load_template_workfile","text":""},{"location":"autoapi/client/ayon_harmony/plugins/load/load_template_workfile.html#client.ayon_harmony.plugins.load.load_template_workfile.ImportTemplateLoader","title":"<code>ImportTemplateLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Import Harmony workfiles.</p> Source code in <code>client/ayon_harmony/plugins/load/load_template_workfile.py</code> <pre><code>class ImportTemplateLoader(load.LoaderPlugin):\n    \"\"\"Import Harmony workfiles.\"\"\"\n\n    product_types = {\"workfile\"}\n    representations = {\"tpl\"}\n    label = \"Import Template\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        # Import template.\n        temp_dir = tempfile.mkdtemp()\n        zip_file = get_representation_path(context[\"representation\"])\n        template_path = os.path.join(temp_dir, \"temp.tpl\")\n        with zipfile.ZipFile(zip_file, \"r\") as zip_ref:\n            zip_ref.extractall(template_path)\n\n        sig = harmony.signature(\"paste\")\n        func = \"\"\"function %s(args)\n        {\n            var template_path = args[0];\n            var drag_object = copyPaste.pasteTemplateIntoGroup(\n                template_path, \"Top\", 1\n            );\n        }\n        %s\n        \"\"\" % (sig, sig)\n\n        harmony.send({\"function\": func, \"args\": [template_path]})\n\n        shutil.rmtree(temp_dir)\n\n        product_name = context[\"product\"][\"name\"]\n\n        return harmony.containerise(\n            product_name,\n            namespace,\n            product_name,\n            context,\n            self.__class__.__name__\n        )\n\n    def update(self, container, context):\n        pass\n\n    def remove(self, container):\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_template_workfile.html#client.ayon_harmony.plugins.load.load_template_workfile.ImportWorkfileLoader","title":"<code>ImportWorkfileLoader</code>","text":"<p>               Bases: <code>ImportTemplateLoader</code></p> <p>Import workfiles.</p> Source code in <code>client/ayon_harmony/plugins/load/load_template_workfile.py</code> <pre><code>class ImportWorkfileLoader(ImportTemplateLoader):\n    \"\"\"Import workfiles.\"\"\"\n\n    product_types = {\"workfile\"}\n    representations = {\"zip\"}\n    label = \"Import Workfile\"\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_audio.html","title":"collect_audio","text":""},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_audio.html#client.ayon_harmony.plugins.publish.collect_audio.CollectAudio","title":"<code>CollectAudio</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect relative path for audio file to instance.</p> <p>Harmony api <code>getSoundtrackAll</code> returns useless path to temp folder, for render on farm we look into 'audio' folder and select first file.</p> <p>Correct path needs to be calculated in <code>submit_harmony_deadline.py</code></p> Source code in <code>client/ayon_harmony/plugins/publish/collect_audio.py</code> <pre><code>class CollectAudio(pyblish.api.InstancePlugin):\n    \"\"\"\n        Collect relative path for audio file to instance.\n\n        Harmony api `getSoundtrackAll` returns useless path to temp folder,\n        for render on farm we look into 'audio' folder and select first file.\n\n        Correct path needs to be calculated in `submit_harmony_deadline.py`\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.499\n    label = \"Collect Audio\"\n    hosts = [\"harmony\"]\n    families = [\"render.farm\"]\n\n    def process(self, instance):\n        full_file_name = None\n        audio_dir = os.path.join(\n            os.path.dirname(instance.context.data.get(\"currentFile\")), 'audio')\n        if os.path.isdir(audio_dir):\n            for full_file_name in os.listdir(audio_dir):\n                file_name, file_ext = os.path.splitext(full_file_name)\n\n                if file_ext not in ['.wav', '.mp3', '.aiff']:\n                    self.log.error(\"Unsupported file {}.{}\".format(file_name,\n                                                                   file_ext))\n                    full_file_name = None\n\n        if full_file_name:\n            audio_file_path = os.path.join('audio', full_file_name)\n            self.log.debug(\"audio_file_path {}\".format(audio_file_path))\n            instance.data[\"audioFile\"] = audio_file_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_current_file.html","title":"collect_current_file","text":"<p>Collect information about current file.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_current_file.html#client.ayon_harmony.plugins.publish.collect_current_file.CollectCurrentFile","title":"<code>CollectCurrentFile</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Inject the current working file into context.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_current_file.py</code> <pre><code>class CollectCurrentFile(pyblish.api.ContextPlugin):\n    \"\"\"Inject the current working file into context.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.5\n    label = \"Current File\"\n    hosts = [\"harmony\"]\n\n    def process(self, context):\n        \"\"\"Inject the current working file.\"\"\"\n        self_name = self.__class__.__name__\n\n        current_file = harmony.send(\n            {\"function\": f\"AyonHarmony.Publish.{self_name}.collect\"})[\"result\"]\n        context.data[\"currentFile\"] = os.path.normpath(current_file)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_current_file.html#client.ayon_harmony.plugins.publish.collect_current_file.CollectCurrentFile.process","title":"<code>process(context)</code>","text":"<p>Inject the current working file.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_current_file.py</code> <pre><code>def process(self, context):\n    \"\"\"Inject the current working file.\"\"\"\n    self_name = self.__class__.__name__\n\n    current_file = harmony.send(\n        {\"function\": f\"AyonHarmony.Publish.{self_name}.collect\"})[\"result\"]\n    context.data[\"currentFile\"] = os.path.normpath(current_file)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_farm_render.html","title":"collect_farm_render","text":"<p>Collect data to render from scene.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_farm_render.html#client.ayon_harmony.plugins.publish.collect_farm_render.CollectFarmRender","title":"<code>CollectFarmRender</code>","text":"<p>               Bases: <code>AbstractCollectRender</code></p> <p>Gather all publishable renders.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_farm_render.py</code> <pre><code>class CollectFarmRender(publish.AbstractCollectRender):\n    \"\"\"Gather all publishable renders.\"\"\"\n\n    # https://docs.toonboom.com/help/harmony-17/premium/reference/node/output/write-node-image-formats.html\n    ext_mapping = {\n        \"tvg\": [\"TVG\"],\n        \"tga\": [\"TGA\", \"TGA4\", \"TGA3\", \"TGA1\"],\n        \"sgi\": [\"SGI\", \"SGI4\", \"SGA3\", \"SGA1\", \"SGIDP\", \"SGIDP4\", \"SGIDP3\"],\n        \"psd\": [\"PSD\", \"PSD1\", \"PSD3\", \"PSD4\", \"PSDDP\", \"PSDDP1\", \"PSDDP3\",\n                \"PSDDP4\"],\n        \"yuv\": [\"YUV\"],\n        \"pal\": [\"PAL\"],\n        \"scan\": [\"SCAN\"],\n        \"png\": [\"PNG\", \"PNG4\", \"PNGDP\", \"PNGDP3\", \"PNGDP4\"],\n        \"jpg\": [\"JPG\"],\n        \"bmp\": [\"BMP\", \"BMP4\"],\n        \"opt\": [\"OPT\", \"OPT1\", \"OPT3\", \"OPT4\"],\n        \"var\": [\"VAR\"],\n        \"tif\": [\"TIF\"],\n        \"dpx\": [\"DPX\", \"DPX3_8\", \"DPX3_10\", \"DPX3_12\", \"DPX3_16\",\n                \"DPX3_10_INVERTED_CHANNELS\", \"DPX3_12_INVERTED_CHANNELS\",\n                \"DPX3_16_INVERTED_CHANNELS\"],\n        \"exr\": [\"EXR\"],\n        \"pdf\": [\"PDF\"],\n        \"dtext\": [\"DTEX\"]\n    }\n\n    def get_expected_files(self, render_instance):\n        \"\"\"Get list of expected files to be rendered from Harmony.\n\n        This returns full path with file name determined by Write node\n        settings.\n        \"\"\"\n        start = render_instance.frameStart - render_instance.handleStart\n        end = render_instance.frameEnd + render_instance.handleEnd\n        node = render_instance.setMembers[0]\n        self_name = self.__class__.__name__\n        # 0 - filename / 1 - type / 2 - zeros / 3 - start\n        info = harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Publish.{self_name}.\"\n                            \"getRenderNodeSettings\",\n                \"args\": node\n            })[\"result\"]\n\n        ext = None\n        for k, v in self.ext_mapping.items():\n            if info[1] in v:\n                ext = k\n\n        if not ext:\n            raise AssertionError(\n                f\"Cannot determine file extension for {info[1]}\")\n\n        path = Path(render_instance.source).parent\n        # is sequence start node on write node offsetting whole sequence?\n        expected_files = []\n\n        # '-' in name is important for Harmony17\n        for frame in range(start, end + 1):\n            expected_files.append(\n                path / \"{}-{}.{}\".format(\n                    render_instance.productName,\n                    str(frame).rjust(int(info[2]) + 1, \"0\"),\n                    ext\n                )\n            )\n        self.log.debug(\"expected_files::{}\".format(expected_files))\n        return expected_files\n\n    def get_instances(self, context):\n        \"\"\"Get instances per Write node in `renderFarm` product type.\"\"\"\n        version = None\n        if self.sync_workfile_version:\n            version = context.data[\"version\"]\n\n        instances = []\n\n        self_name = self.__class__.__name__\n\n        folder_path = context.data[\"folderPath\"]\n\n        for inst in context:\n            if not inst.data.get(\"active\", True):\n                continue\n            creator_attributes = inst.data.get(\"creator_attributes\", {})\n            if creator_attributes.get(\"render_target\") != \"farm\":\n                continue\n\n            node = inst.data[\"transientData\"][\"node\"]\n            # 0 - filename / 1 - type / 2 - zeros / 3 - start / 4 - enabled\n            info = harmony.send(\n                {\n                    \"function\": f\"AyonHarmony.Publish.{self_name}.\"\n                                \"getRenderNodeSettings\",\n                    \"args\": node\n                })[\"result\"]\n\n            # TODO: handle pixel aspect and frame step\n            product_name = inst.data[\"productName\"]\n            task_name = inst.data.get(\"task\")\n\n            product_type = inst.data(\"productType\")\n            instance_families = inst.data.get(\"families\", [])\n\n            render_instance = HarmonyRenderInstance(\n                version=version,\n                time=get_formatted_current_time(),\n                source=context.data[\"currentFile\"],\n                name=product_name,\n                label=\"{} - {}\".format(product_name, product_type),\n                productName=product_name,\n                productType=product_type,\n                family=product_type,\n                families=instance_families,\n                farm=True,\n                folderPath=folder_path,\n                task=task_name,\n                attachTo=False,\n                setMembers=[node],\n                publish=info[4],\n                renderer=None,\n                priority=50,\n                resolutionWidth=context.data[\"resolutionWidth\"],\n                resolutionHeight=context.data[\"resolutionHeight\"],\n                pixelAspect=1.0,\n                multipartExr=False,\n                tileRendering=False,\n                tilesX=0,\n                tilesY=0,\n                convertToScanline=False,\n\n                # time settings\n                frameStart=context.data[\"frameStart\"],\n                frameEnd=context.data[\"frameEnd\"],\n                handleStart=context.data[\"handleStart\"],  # from DB\n                handleEnd=context.data[\"handleEnd\"],      # from DB\n                frameStep=1,\n                outputType=\"Image\",\n                outputFormat=info[1],\n                outputStartFrame=info[3],\n                leadingZeros=info[2],\n                ignoreFrameHandleCheck=True,\n                # The source instance this render instance replaces\n                source_instance=inst\n            )\n            render_instance.context = context\n            self.log.debug(render_instance)\n            instances.append(render_instance)\n\n        return instances\n\n    def add_additional_data(self, instance):\n        instance[\"FOV\"] = self._context.data[\"FOV\"]\n\n        return instance\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_farm_render.html#client.ayon_harmony.plugins.publish.collect_farm_render.CollectFarmRender.get_expected_files","title":"<code>get_expected_files(render_instance)</code>","text":"<p>Get list of expected files to be rendered from Harmony.</p> <p>This returns full path with file name determined by Write node settings.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_farm_render.py</code> <pre><code>def get_expected_files(self, render_instance):\n    \"\"\"Get list of expected files to be rendered from Harmony.\n\n    This returns full path with file name determined by Write node\n    settings.\n    \"\"\"\n    start = render_instance.frameStart - render_instance.handleStart\n    end = render_instance.frameEnd + render_instance.handleEnd\n    node = render_instance.setMembers[0]\n    self_name = self.__class__.__name__\n    # 0 - filename / 1 - type / 2 - zeros / 3 - start\n    info = harmony.send(\n        {\n            \"function\": f\"AyonHarmony.Publish.{self_name}.\"\n                        \"getRenderNodeSettings\",\n            \"args\": node\n        })[\"result\"]\n\n    ext = None\n    for k, v in self.ext_mapping.items():\n        if info[1] in v:\n            ext = k\n\n    if not ext:\n        raise AssertionError(\n            f\"Cannot determine file extension for {info[1]}\")\n\n    path = Path(render_instance.source).parent\n    # is sequence start node on write node offsetting whole sequence?\n    expected_files = []\n\n    # '-' in name is important for Harmony17\n    for frame in range(start, end + 1):\n        expected_files.append(\n            path / \"{}-{}.{}\".format(\n                render_instance.productName,\n                str(frame).rjust(int(info[2]) + 1, \"0\"),\n                ext\n            )\n        )\n    self.log.debug(\"expected_files::{}\".format(expected_files))\n    return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_farm_render.html#client.ayon_harmony.plugins.publish.collect_farm_render.CollectFarmRender.get_instances","title":"<code>get_instances(context)</code>","text":"<p>Get instances per Write node in <code>renderFarm</code> product type.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_farm_render.py</code> <pre><code>def get_instances(self, context):\n    \"\"\"Get instances per Write node in `renderFarm` product type.\"\"\"\n    version = None\n    if self.sync_workfile_version:\n        version = context.data[\"version\"]\n\n    instances = []\n\n    self_name = self.__class__.__name__\n\n    folder_path = context.data[\"folderPath\"]\n\n    for inst in context:\n        if not inst.data.get(\"active\", True):\n            continue\n        creator_attributes = inst.data.get(\"creator_attributes\", {})\n        if creator_attributes.get(\"render_target\") != \"farm\":\n            continue\n\n        node = inst.data[\"transientData\"][\"node\"]\n        # 0 - filename / 1 - type / 2 - zeros / 3 - start / 4 - enabled\n        info = harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Publish.{self_name}.\"\n                            \"getRenderNodeSettings\",\n                \"args\": node\n            })[\"result\"]\n\n        # TODO: handle pixel aspect and frame step\n        product_name = inst.data[\"productName\"]\n        task_name = inst.data.get(\"task\")\n\n        product_type = inst.data(\"productType\")\n        instance_families = inst.data.get(\"families\", [])\n\n        render_instance = HarmonyRenderInstance(\n            version=version,\n            time=get_formatted_current_time(),\n            source=context.data[\"currentFile\"],\n            name=product_name,\n            label=\"{} - {}\".format(product_name, product_type),\n            productName=product_name,\n            productType=product_type,\n            family=product_type,\n            families=instance_families,\n            farm=True,\n            folderPath=folder_path,\n            task=task_name,\n            attachTo=False,\n            setMembers=[node],\n            publish=info[4],\n            renderer=None,\n            priority=50,\n            resolutionWidth=context.data[\"resolutionWidth\"],\n            resolutionHeight=context.data[\"resolutionHeight\"],\n            pixelAspect=1.0,\n            multipartExr=False,\n            tileRendering=False,\n            tilesX=0,\n            tilesY=0,\n            convertToScanline=False,\n\n            # time settings\n            frameStart=context.data[\"frameStart\"],\n            frameEnd=context.data[\"frameEnd\"],\n            handleStart=context.data[\"handleStart\"],  # from DB\n            handleEnd=context.data[\"handleEnd\"],      # from DB\n            frameStep=1,\n            outputType=\"Image\",\n            outputFormat=info[1],\n            outputStartFrame=info[3],\n            leadingZeros=info[2],\n            ignoreFrameHandleCheck=True,\n            # The source instance this render instance replaces\n            source_instance=inst\n        )\n        render_instance.context = context\n        self.log.debug(render_instance)\n        instances.append(render_instance)\n\n    return instances\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_instances.html","title":"collect_instances","text":"<p>Collect instances in Harmony.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_instances.html#client.ayon_harmony.plugins.publish.collect_instances.CollectInstances","title":"<code>CollectInstances</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Gather instances by nodes metadata.</p> <p>This collector takes into account assets that are associated with a composite node and marked with a unique identifier.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_instances.py</code> <pre><code>class CollectInstances(pyblish.api.InstancePlugin):\n    \"\"\"Gather instances by nodes metadata.\n\n    This collector takes into account assets that are associated with\n    a composite node and marked with a unique identifier.\n    \"\"\"\n\n    label = \"Instances\"\n    order = pyblish.api.CollectorOrder\n    hosts = [\"harmony\"]\n\n    product_type_mapping = {\n        \"render\": [\"review\"],\n        \"harmony.template\": [],\n        \"palette\": [\"palette\"]\n    }\n    pair_media = True\n\n    def process(self, instance: pyblish.api.Instance):\n\n        # skip render farm product type as it is collected separately\n        product_type = instance.data[\"productType\"]\n        if product_type == \"workfile\":\n            return\n\n        node = instance.data[\"transientData\"][\"node\"]\n\n        instance.data[\"setMembers\"] = [node]\n\n        families = [product_type]\n        families.extend(self.product_type_mapping.get(product_type, []))\n        if product_type == \"render\":\n            creator_attributes = instance.data.get(\"creator_attributes\", {})\n            render_target = creator_attributes[\"render_target\"]\n            families.append(f\"render.{render_target}\")\n\n        instance.data[\"families\"] = families\n\n        # If set in plugin, pair the scene Version with\n        # thumbnails and review media.\n        if (self.pair_media and product_type == \"scene\"):\n            instance.context.data[\"scene_instance\"] = instance\n\n        # Produce diagnostic message for any graphical\n        # user interface interested in visualising it.\n        self.log.info(\n            \"Processed: \\\"{0}\\\": \\n{1}\".format(\n                instance.data[\"name\"], json.dumps(instance.data, indent=4)\n            )\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_palettes.html","title":"collect_palettes","text":"<p>Collect palettes from Harmony.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_palettes.html#client.ayon_harmony.plugins.publish.collect_palettes.CollectPalettes","title":"<code>CollectPalettes</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Gather palettes from scene when publishing templates.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_palettes.py</code> <pre><code>class CollectPalettes(pyblish.api.ContextPlugin):\n    \"\"\"Gather palettes from scene when publishing templates.\"\"\"\n\n    label = \"Palettes\"\n    order = pyblish.api.CollectorOrder + 0.003\n    hosts = [\"harmony\"]\n\n    settings_category = \"harmony\"\n\n    # list of regexes for task names where collecting should happen\n    allowed_tasks = []\n\n    def process(self, context):\n        \"\"\"Collector entry point.\"\"\"\n        self_name = self.__class__.__name__\n        palettes = harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Publish.{self_name}.getPalettes\",\n            })[\"result\"]\n\n        # skip collecting if not in allowed task\n        if self.allowed_tasks:\n            task_name = context.data[\"anatomyData\"][\"task\"][\"name\"].lower()\n            if (not any([re.search(pattern, task_name)\n                         for pattern in self.allowed_tasks])):\n                return\n        folder_path = context.data[\"folderPath\"]\n\n        product_type = \"harmony.palette\"\n        for name, id in palettes.items():\n            instance = context.create_instance(name)\n            instance.data.update({\n                \"id\": id,\n                \"productType\": product_type,\n                \"family\": product_type,\n                \"families\": [product_type],\n                \"folderPath\": folder_path,\n                \"productName\": \"{}{}\".format(\"palette\", name)\n            })\n            self.log.info(\n                \"Created instance:\\n\" + json.dumps(\n                    instance.data, sort_keys=True, indent=4\n                )\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_palettes.html#client.ayon_harmony.plugins.publish.collect_palettes.CollectPalettes.process","title":"<code>process(context)</code>","text":"<p>Collector entry point.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_palettes.py</code> <pre><code>def process(self, context):\n    \"\"\"Collector entry point.\"\"\"\n    self_name = self.__class__.__name__\n    palettes = harmony.send(\n        {\n            \"function\": f\"AyonHarmony.Publish.{self_name}.getPalettes\",\n        })[\"result\"]\n\n    # skip collecting if not in allowed task\n    if self.allowed_tasks:\n        task_name = context.data[\"anatomyData\"][\"task\"][\"name\"].lower()\n        if (not any([re.search(pattern, task_name)\n                     for pattern in self.allowed_tasks])):\n            return\n    folder_path = context.data[\"folderPath\"]\n\n    product_type = \"harmony.palette\"\n    for name, id in palettes.items():\n        instance = context.create_instance(name)\n        instance.data.update({\n            \"id\": id,\n            \"productType\": product_type,\n            \"family\": product_type,\n            \"families\": [product_type],\n            \"folderPath\": folder_path,\n            \"productName\": \"{}{}\".format(\"palette\", name)\n        })\n        self.log.info(\n            \"Created instance:\\n\" + json.dumps(\n                instance.data, sort_keys=True, indent=4\n            )\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_scene.html","title":"collect_scene","text":"<p>Collect scene data.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_scene.html#client.ayon_harmony.plugins.publish.collect_scene.CollectScene","title":"<code>CollectScene</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect basic scene information.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_scene.py</code> <pre><code>class CollectScene(pyblish.api.ContextPlugin):\n    \"\"\"Collect basic scene information.\"\"\"\n\n    label = \"Scene Data\"\n    order = pyblish.api.CollectorOrder\n    hosts = [\"harmony\"]\n\n    def process(self, context):\n        \"\"\"Plugin entry point.\"\"\"\n        result = harmony.send(\n            {\n                \"function\": \"AyonHarmony.getSceneSettings\",\n                \"args\": []}\n        )[\"result\"]\n\n        context.data[\"applicationPath\"] = result[0]\n        context.data[\"scenePath\"] = os.path.join(\n            result[1], result[2] + \".xstage\")\n        context.data[\"frameRate\"] = result[3]\n        context.data[\"frameStartHandle\"] = result[4]\n        context.data[\"frameEndHandle\"] = result[5]\n        context.data[\"audioPath\"] = result[6]\n        context.data[\"resolutionWidth\"] = result[7]\n        context.data[\"resolutionHeight\"] = result[8]\n        context.data[\"FOV\"] = result[9]\n\n        # harmony always starts from 1. frame\n        # 1001 - 10010 &gt;&gt; 1 - 10\n        # frameStart, frameEnd already collected by global plugin\n        offset = context.data[\"frameStart\"] - 1\n        frame_start = context.data[\"frameStart\"] - offset\n        frames_count = context.data[\"frameEnd\"] - \\\n            context.data[\"frameStart\"] + 1\n\n        # increase by handleStart - real frame range\n        # frameStart != frameStartHandle with handle presence\n        context.data[\"frameStart\"] = int(frame_start) + \\\n            context.data[\"handleStart\"]\n        context.data[\"frameEnd\"] = int(frames_count) + \\\n            context.data[\"frameStart\"] - 1\n\n        all_nodes = harmony.send(\n            {\"function\": \"node.subNodes\", \"args\": [\"Top\"]}\n        )[\"result\"]\n\n        context.data[\"allNodes\"] = all_nodes\n\n        # collect all write nodes to be able disable them in Deadline\n        all_write_nodes = harmony.send(\n            {\"function\": \"node.getNodes\", \"args\": [\"WRITE\"]}\n        )[\"result\"]\n\n        context.data[\"all_write_nodes\"] = all_write_nodes\n\n        result = harmony.send(\n            {\n                \"function\": \"AyonHarmony.getVersion\",\n                \"args\": []}\n        )[\"result\"]\n        context.data[\"harmonyVersion\"] = \"{}.{}\".format(result[0], result[1])\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_scene.html#client.ayon_harmony.plugins.publish.collect_scene.CollectScene.process","title":"<code>process(context)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_scene.py</code> <pre><code>def process(self, context):\n    \"\"\"Plugin entry point.\"\"\"\n    result = harmony.send(\n        {\n            \"function\": \"AyonHarmony.getSceneSettings\",\n            \"args\": []}\n    )[\"result\"]\n\n    context.data[\"applicationPath\"] = result[0]\n    context.data[\"scenePath\"] = os.path.join(\n        result[1], result[2] + \".xstage\")\n    context.data[\"frameRate\"] = result[3]\n    context.data[\"frameStartHandle\"] = result[4]\n    context.data[\"frameEndHandle\"] = result[5]\n    context.data[\"audioPath\"] = result[6]\n    context.data[\"resolutionWidth\"] = result[7]\n    context.data[\"resolutionHeight\"] = result[8]\n    context.data[\"FOV\"] = result[9]\n\n    # harmony always starts from 1. frame\n    # 1001 - 10010 &gt;&gt; 1 - 10\n    # frameStart, frameEnd already collected by global plugin\n    offset = context.data[\"frameStart\"] - 1\n    frame_start = context.data[\"frameStart\"] - offset\n    frames_count = context.data[\"frameEnd\"] - \\\n        context.data[\"frameStart\"] + 1\n\n    # increase by handleStart - real frame range\n    # frameStart != frameStartHandle with handle presence\n    context.data[\"frameStart\"] = int(frame_start) + \\\n        context.data[\"handleStart\"]\n    context.data[\"frameEnd\"] = int(frames_count) + \\\n        context.data[\"frameStart\"] - 1\n\n    all_nodes = harmony.send(\n        {\"function\": \"node.subNodes\", \"args\": [\"Top\"]}\n    )[\"result\"]\n\n    context.data[\"allNodes\"] = all_nodes\n\n    # collect all write nodes to be able disable them in Deadline\n    all_write_nodes = harmony.send(\n        {\"function\": \"node.getNodes\", \"args\": [\"WRITE\"]}\n    )[\"result\"]\n\n    context.data[\"all_write_nodes\"] = all_write_nodes\n\n    result = harmony.send(\n        {\n            \"function\": \"AyonHarmony.getVersion\",\n            \"args\": []}\n    )[\"result\"]\n    context.data[\"harmonyVersion\"] = \"{}.{}\".format(result[0], result[1])\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_palette.html","title":"extract_palette","text":"<p>Extract palette from Harmony.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_palette.html#client.ayon_harmony.plugins.publish.extract_palette.ExtractPalette","title":"<code>ExtractPalette</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract palette.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_palette.py</code> <pre><code>class ExtractPalette(publish.Extractor):\n    \"\"\"Extract palette.\"\"\"\n\n    label = \"Extract Palette\"\n    hosts = [\"harmony\"]\n    families = [\"harmony.palette\"]\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        self_name = self.__class__.__name__\n        result = harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Publish.{self_name}.getPalette\",\n                \"args\": instance.data[\"id\"]\n            })[\"result\"]\n\n        if not isinstance(result, list):\n            self.log.error(f\"Invalid reply: {result}\")\n            raise AssertionError(\"Invalid reply from server.\")\n        palette_name = result[0]\n        palette_file = result[1]\n        self.log.info(f\"Got palette named {palette_name} \"\n                      f\"and file {palette_file}.\")\n\n        tmp_thumb_path = os.path.join(os.path.dirname(palette_file),\n                                      os.path.basename(palette_file)\n                                      .split(\".plt\")[0] + \"_swatches.png\"\n                                      )\n        self.log.info(f\"Temporary thumbnail path {tmp_thumb_path}\")\n\n        palette_version = str(instance.data.get(\"version\")).zfill(3)\n\n        self.log.info(f\"Palette version {palette_version}\")\n\n        if not instance.data.get(\"representations\"):\n            instance.data[\"representations\"] = []\n\n        try:\n            thumbnail_path = self.create_palette_thumbnail(palette_name,\n                                                           palette_version,\n                                                           palette_file,\n                                                           tmp_thumb_path)\n        except OSError as e:\n            # FIXME: this happens on Mac where PIL cannot access fonts\n            # for some reason.\n            self.log.warning(\"Thumbnail generation failed\")\n            self.log.warning(e)\n        except ValueError:\n            self.log.error(\"Unsupported palette type for thumbnail.\")\n\n        else:\n            thumbnail = {\n                \"name\": \"thumbnail\",\n                \"ext\": \"png\",\n                \"files\": os.path.basename(thumbnail_path),\n                \"stagingDir\": os.path.dirname(thumbnail_path),\n                \"tags\": [\"thumbnail\"]\n            }\n\n            instance.data[\"representations\"].append(thumbnail)\n\n        representation = {\n            \"name\": \"plt\",\n            \"ext\": \"plt\",\n            \"files\": os.path.basename(palette_file),\n            \"stagingDir\": os.path.dirname(palette_file)\n        }\n\n        instance.data[\"representations\"].append(representation)\n\n    def create_palette_thumbnail(self,\n                                 palette_name,\n                                 palette_version,\n                                 palette_path,\n                                 dst_path):\n        \"\"\"Create thumbnail for palette file.\n\n        Args:\n            palette_name (str): Name of palette.\n            palette_version (str): Version of palette.\n            palette_path (str): Path to palette file.\n            dst_path (str): Thumbnail path.\n\n        Returns:\n            str: Thumbnail path.\n\n        \"\"\"\n        colors = {}\n\n        with open(palette_path, newline='') as plt:\n            plt_parser = csv.reader(plt, delimiter=\" \")\n            for i, line in enumerate(plt_parser):\n                if i == 0:\n                    continue\n                while (\"\" in line):\n                    line.remove(\"\")\n                # self.log.debug(line)\n                if line[0] not in [\"Solid\"]:\n                    raise ValueError(\"Unsupported palette type.\")\n                color_name = line[1].strip('\"')\n                colors[color_name] = {\"type\": line[0],\n                                      \"uuid\": line[2],\n                                      \"rgba\": (int(line[3]),\n                                               int(line[4]),\n                                               int(line[5]),\n                                               int(line[6])),\n                                      }\n            plt.close()\n\n        img_pad_top = 80\n        label_pad_name = 30\n        label_pad_rgb = 580\n        swatch_pad_left = 300\n        swatch_pad_top = 10\n        swatch_w = 120\n        swatch_h = 50\n\n        image_w = 800\n        image_h = (img_pad_top +\n                   (len(colors.keys()) *\n                    swatch_h) +\n                   (swatch_pad_top *\n                    len(colors.keys()))\n                   )\n\n        img = Image.new(\"RGBA\", (image_w, image_h), \"white\")\n\n        # For bg of colors with alpha, create checkerboard image\n        checkers = Image.new(\"RGB\", (swatch_w, swatch_h))\n        pixels = checkers.load()\n\n        # Make pixels white where (row+col) is odd\n        for i in range(swatch_w):\n            for j in range(swatch_h):\n                if (i + j) % 2:\n                    pixels[i, j] = (255, 255, 255)\n\n        draw = ImageDraw.Draw(img)\n        # TODO: This needs to be font included with AYON because\n        # arial is not available on other platforms then Windows.\n        title_font = ImageFont.truetype(\"arial.ttf\", 28)\n        label_font = ImageFont.truetype(\"arial.ttf\", 20)\n\n        draw.text((label_pad_name, 20),\n                  \"{} (v{})\".format(palette_name, palette_version),\n                  \"black\",\n                  font=title_font)\n\n        for i, name in enumerate(colors):\n            rgba = colors[name][\"rgba\"]\n            # @TODO: Fix this so alpha colors are displayed with checkboard\n            # if not rgba[3] == \"255\":\n            #     img.paste(checkers,\n            #               (swatch_pad_left,\n            #                img_pad_top + swatch_pad_top + (i * swatch_h))\n            #               )\n            #\n            #     half_y = (img_pad_top + swatch_pad_top + (i * swatch_h))/2\n            #\n            #     draw.rectangle((\n            #         swatch_pad_left,  # upper LX\n            #         img_pad_top + swatch_pad_top + (i * swatch_h), # upper LY\n            #         swatch_pad_left + (swatch_w * 2),  # lower RX\n            #         half_y),  # lower RY\n            #         fill=rgba[:-1], outline=(0, 0, 0), width=2)\n            #     draw.rectangle((\n            #         swatch_pad_left,  # upper LX\n            #         half_y,  # upper LY\n            #         swatch_pad_left + (swatch_w * 2),  # lower RX\n            #         img_pad_top + swatch_h + (i * swatch_h)),  # lower RY\n            #         fill=rgba, outline=(0, 0, 0), width=2)\n            # else:\n\n            draw.rectangle((\n                swatch_pad_left,  # upper left x\n                img_pad_top + swatch_pad_top + (i * swatch_h),  # upper left y\n                swatch_pad_left + (swatch_w * 2),  # lower right x\n                img_pad_top + swatch_h + (i * swatch_h)),  # lower right y\n                fill=rgba, outline=(0, 0, 0), width=2)\n\n            draw.text((label_pad_name, img_pad_top + (i * swatch_h) + swatch_pad_top + (swatch_h / 4)),  # noqa: E501\n                      name,\n                      \"black\",\n                      font=label_font)\n\n            draw.text((label_pad_rgb, img_pad_top + (i * swatch_h) + swatch_pad_top + (swatch_h / 4)),  # noqa: E501\n                      str(rgba),\n                      \"black\",\n                      font=label_font)\n\n        draw = ImageDraw.Draw(img)\n\n        img.save(dst_path)\n        return dst_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_palette.html#client.ayon_harmony.plugins.publish.extract_palette.ExtractPalette.create_palette_thumbnail","title":"<code>create_palette_thumbnail(palette_name, palette_version, palette_path, dst_path)</code>","text":"<p>Create thumbnail for palette file.</p> <p>Parameters:</p> Name Type Description Default <code>palette_name</code> <code>str</code> <p>Name of palette.</p> required <code>palette_version</code> <code>str</code> <p>Version of palette.</p> required <code>palette_path</code> <code>str</code> <p>Path to palette file.</p> required <code>dst_path</code> <code>str</code> <p>Thumbnail path.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Thumbnail path.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_palette.py</code> <pre><code>def create_palette_thumbnail(self,\n                             palette_name,\n                             palette_version,\n                             palette_path,\n                             dst_path):\n    \"\"\"Create thumbnail for palette file.\n\n    Args:\n        palette_name (str): Name of palette.\n        palette_version (str): Version of palette.\n        palette_path (str): Path to palette file.\n        dst_path (str): Thumbnail path.\n\n    Returns:\n        str: Thumbnail path.\n\n    \"\"\"\n    colors = {}\n\n    with open(palette_path, newline='') as plt:\n        plt_parser = csv.reader(plt, delimiter=\" \")\n        for i, line in enumerate(plt_parser):\n            if i == 0:\n                continue\n            while (\"\" in line):\n                line.remove(\"\")\n            # self.log.debug(line)\n            if line[0] not in [\"Solid\"]:\n                raise ValueError(\"Unsupported palette type.\")\n            color_name = line[1].strip('\"')\n            colors[color_name] = {\"type\": line[0],\n                                  \"uuid\": line[2],\n                                  \"rgba\": (int(line[3]),\n                                           int(line[4]),\n                                           int(line[5]),\n                                           int(line[6])),\n                                  }\n        plt.close()\n\n    img_pad_top = 80\n    label_pad_name = 30\n    label_pad_rgb = 580\n    swatch_pad_left = 300\n    swatch_pad_top = 10\n    swatch_w = 120\n    swatch_h = 50\n\n    image_w = 800\n    image_h = (img_pad_top +\n               (len(colors.keys()) *\n                swatch_h) +\n               (swatch_pad_top *\n                len(colors.keys()))\n               )\n\n    img = Image.new(\"RGBA\", (image_w, image_h), \"white\")\n\n    # For bg of colors with alpha, create checkerboard image\n    checkers = Image.new(\"RGB\", (swatch_w, swatch_h))\n    pixels = checkers.load()\n\n    # Make pixels white where (row+col) is odd\n    for i in range(swatch_w):\n        for j in range(swatch_h):\n            if (i + j) % 2:\n                pixels[i, j] = (255, 255, 255)\n\n    draw = ImageDraw.Draw(img)\n    # TODO: This needs to be font included with AYON because\n    # arial is not available on other platforms then Windows.\n    title_font = ImageFont.truetype(\"arial.ttf\", 28)\n    label_font = ImageFont.truetype(\"arial.ttf\", 20)\n\n    draw.text((label_pad_name, 20),\n              \"{} (v{})\".format(palette_name, palette_version),\n              \"black\",\n              font=title_font)\n\n    for i, name in enumerate(colors):\n        rgba = colors[name][\"rgba\"]\n        # @TODO: Fix this so alpha colors are displayed with checkboard\n        # if not rgba[3] == \"255\":\n        #     img.paste(checkers,\n        #               (swatch_pad_left,\n        #                img_pad_top + swatch_pad_top + (i * swatch_h))\n        #               )\n        #\n        #     half_y = (img_pad_top + swatch_pad_top + (i * swatch_h))/2\n        #\n        #     draw.rectangle((\n        #         swatch_pad_left,  # upper LX\n        #         img_pad_top + swatch_pad_top + (i * swatch_h), # upper LY\n        #         swatch_pad_left + (swatch_w * 2),  # lower RX\n        #         half_y),  # lower RY\n        #         fill=rgba[:-1], outline=(0, 0, 0), width=2)\n        #     draw.rectangle((\n        #         swatch_pad_left,  # upper LX\n        #         half_y,  # upper LY\n        #         swatch_pad_left + (swatch_w * 2),  # lower RX\n        #         img_pad_top + swatch_h + (i * swatch_h)),  # lower RY\n        #         fill=rgba, outline=(0, 0, 0), width=2)\n        # else:\n\n        draw.rectangle((\n            swatch_pad_left,  # upper left x\n            img_pad_top + swatch_pad_top + (i * swatch_h),  # upper left y\n            swatch_pad_left + (swatch_w * 2),  # lower right x\n            img_pad_top + swatch_h + (i * swatch_h)),  # lower right y\n            fill=rgba, outline=(0, 0, 0), width=2)\n\n        draw.text((label_pad_name, img_pad_top + (i * swatch_h) + swatch_pad_top + (swatch_h / 4)),  # noqa: E501\n                  name,\n                  \"black\",\n                  font=label_font)\n\n        draw.text((label_pad_rgb, img_pad_top + (i * swatch_h) + swatch_pad_top + (swatch_h / 4)),  # noqa: E501\n                  str(rgba),\n                  \"black\",\n                  font=label_font)\n\n    draw = ImageDraw.Draw(img)\n\n    img.save(dst_path)\n    return dst_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_palette.html#client.ayon_harmony.plugins.publish.extract_palette.ExtractPalette.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_palette.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    self_name = self.__class__.__name__\n    result = harmony.send(\n        {\n            \"function\": f\"AyonHarmony.Publish.{self_name}.getPalette\",\n            \"args\": instance.data[\"id\"]\n        })[\"result\"]\n\n    if not isinstance(result, list):\n        self.log.error(f\"Invalid reply: {result}\")\n        raise AssertionError(\"Invalid reply from server.\")\n    palette_name = result[0]\n    palette_file = result[1]\n    self.log.info(f\"Got palette named {palette_name} \"\n                  f\"and file {palette_file}.\")\n\n    tmp_thumb_path = os.path.join(os.path.dirname(palette_file),\n                                  os.path.basename(palette_file)\n                                  .split(\".plt\")[0] + \"_swatches.png\"\n                                  )\n    self.log.info(f\"Temporary thumbnail path {tmp_thumb_path}\")\n\n    palette_version = str(instance.data.get(\"version\")).zfill(3)\n\n    self.log.info(f\"Palette version {palette_version}\")\n\n    if not instance.data.get(\"representations\"):\n        instance.data[\"representations\"] = []\n\n    try:\n        thumbnail_path = self.create_palette_thumbnail(palette_name,\n                                                       palette_version,\n                                                       palette_file,\n                                                       tmp_thumb_path)\n    except OSError as e:\n        # FIXME: this happens on Mac where PIL cannot access fonts\n        # for some reason.\n        self.log.warning(\"Thumbnail generation failed\")\n        self.log.warning(e)\n    except ValueError:\n        self.log.error(\"Unsupported palette type for thumbnail.\")\n\n    else:\n        thumbnail = {\n            \"name\": \"thumbnail\",\n            \"ext\": \"png\",\n            \"files\": os.path.basename(thumbnail_path),\n            \"stagingDir\": os.path.dirname(thumbnail_path),\n            \"tags\": [\"thumbnail\"]\n        }\n\n        instance.data[\"representations\"].append(thumbnail)\n\n    representation = {\n        \"name\": \"plt\",\n        \"ext\": \"plt\",\n        \"files\": os.path.basename(palette_file),\n        \"stagingDir\": os.path.dirname(palette_file)\n    }\n\n    instance.data[\"representations\"].append(representation)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_render.html","title":"extract_render","text":""},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_render.html#client.ayon_harmony.plugins.publish.extract_render.ExtractRender","title":"<code>ExtractRender</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Produce a flattened image file from instance. This plug-in only takes into account the nodes connected to the composite.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_render.py</code> <pre><code>class ExtractRender(pyblish.api.InstancePlugin):\n    \"\"\"Produce a flattened image file from instance.\n    This plug-in only takes into account the nodes connected to the composite.\n    \"\"\"\n\n    label = \"Extract Render\"\n    order = pyblish.api.ExtractorOrder\n    hosts = [\"harmony\"]\n    families = [\"render.local\"]\n\n    def process(self, instance):\n        # Collect scene data.\n\n        application_path = instance.context.data.get(\"applicationPath\")\n        scene_path = instance.context.data.get(\"scenePath\")\n        frame_rate = instance.context.data.get(\"frameRate\")\n        # real value from timeline\n        frame_start = instance.context.data.get(\"frameStartHandle\")\n        frame_end = instance.context.data.get(\"frameEndHandle\")\n        audio_path = instance.context.data.get(\"audioPath\")\n\n        if audio_path and os.path.exists(audio_path):\n            self.log.info(f\"Using audio from {audio_path}\")\n            instance.data[\"audio\"] = [{\"filename\": audio_path}]\n\n        instance.data[\"fps\"] = frame_rate\n\n        # Set output path to temp folder.\n        path = tempfile.mkdtemp()\n        sig = harmony.signature()\n        func = \"\"\"function %s(args)\n        {\n            node.setTextAttr(args[0], \"DRAWING_NAME\", 1, args[1]);\n        }\n        %s\n        \"\"\" % (sig, sig)\n        harmony.send(\n            {\n                \"function\": func,\n                \"args\": [instance.data[\"setMembers\"][0],\n                         path + \"/\" + instance.data[\"name\"]]\n            }\n        )\n        harmony.save_scene()\n\n        # Execute rendering. Ignoring error cause Harmony returns error code\n        # always.\n\n        args = [application_path, \"-batch\",\n                \"-frames\", str(frame_start), str(frame_end),\n                scene_path]\n        self.log.info(f\"running: {' '.join(args)}\")\n        proc = subprocess.Popen(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            stdin=subprocess.PIPE\n        )\n        output, error = proc.communicate()\n        self.log.info(\"Click on the line below to see more details.\")\n        self.log.info(output.decode(\"utf-8\"))\n\n        # Collect rendered files.\n        self.log.debug(f\"collecting from: {path}\")\n        files = os.listdir(path)\n        assert files, (\n            \"No rendered files found, render failed.\"\n        )\n        self.log.debug(f\"files there: {files}\")\n        collections, remainder = clique.assemble(files, minimum_items=1)\n        assert not remainder, (\n            \"There should not be a remainder for {0}: {1}\".format(\n                instance.data[\"setMembers\"][0], remainder\n            )\n        )\n        self.log.debug(collections)\n        if len(collections) &gt; 1:\n            for col in collections:\n                if len(list(col)) &gt; 1:\n                    collection = col\n        else:\n            collection = collections[0]\n\n        # Generate thumbnail.\n        thumbnail_path = os.path.join(path, \"thumbnail.png\")\n        args = ayon_core.lib.get_ffmpeg_tool_args(\n            \"ffmpeg\",\n            \"-y\",\n            \"-i\", os.path.join(path, list(collections[0])[0]),\n            \"-vf\", \"scale=300:-1\",\n            \"-vframes\", \"1\",\n            thumbnail_path\n        )\n        process = subprocess.Popen(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            stdin=subprocess.PIPE\n        )\n\n        output = process.communicate()[0]\n\n        if process.returncode != 0:\n            raise ValueError(output.decode(\"utf-8\", errors=\"backslashreplace\"))\n\n        self.log.debug(output.decode(\"utf-8\", errors=\"backslashreplace\"))\n\n        # Generate representations.\n        extension = collection.tail[1:]\n        representation = {\n            \"name\": extension,\n            \"ext\": extension,\n            \"files\": list(collection),\n            \"stagingDir\": path,\n            \"tags\": [\"review\"],\n            \"fps\": frame_rate\n        }\n\n        thumbnail = {\n            \"name\": \"thumbnail\",\n            \"ext\": \"png\",\n            \"files\": os.path.basename(thumbnail_path),\n            \"stagingDir\": path,\n            \"tags\": [\"thumbnail\"]\n        }\n        instance.data[\"representations\"] = [representation, thumbnail]\n\n        if audio_path and os.path.exists(audio_path):\n            instance.data[\"audio\"] = [{\"filename\": audio_path}]\n\n        # Required for extract_review plugin (L222 onwards).\n        instance.data[\"frameStart\"] = frame_start\n        instance.data[\"frameEnd\"] = frame_end\n        instance.data[\"fps\"] = frame_rate\n\n        self.log.info(f\"Extracted {instance} to {path}\")\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_save_scene.html","title":"extract_save_scene","text":""},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_save_scene.html#client.ayon_harmony.plugins.publish.extract_save_scene.ExtractSaveScene","title":"<code>ExtractSaveScene</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Save scene for extraction.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_save_scene.py</code> <pre><code>class ExtractSaveScene(pyblish.api.ContextPlugin):\n    \"\"\"Save scene for extraction.\"\"\"\n\n    label = \"Extract Save Scene\"\n    order = pyblish.api.ExtractorOrder - 0.49\n    hosts = [\"harmony\"]\n\n    def process(self, context):\n        harmony.save_scene()\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_template.html","title":"extract_template","text":"<p>Extract template.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_template.html#client.ayon_harmony.plugins.publish.extract_template.ExtractTemplate","title":"<code>ExtractTemplate</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract the connected nodes to the composite instance.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_template.py</code> <pre><code>class ExtractTemplate(publish.Extractor):\n    \"\"\"Extract the connected nodes to the composite instance.\"\"\"\n\n    label = \"Extract Template\"\n    hosts = [\"harmony\"]\n    families = [\"harmony.template\"]\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        staging_dir = self.staging_dir(instance)\n        filepath = os.path.join(staging_dir, \"harmony\", f\"{instance.name}.tpl\")\n\n        self.log.info(f\"Outputting template to {staging_dir}\")\n\n        # Export template\n        self.log.info(f'{instance.data[\"setMembers\"][0]}')\n        harmony.export_backdrop_as_template(\n            instance.data[\"setMembers\"][0], filepath\n        )\n\n        # Prep representation.\n        os.chdir(staging_dir)\n        shutil.make_archive(\n            f\"{instance.name}\",\n            \"zip\",\n            os.path.join(staging_dir, \"harmony\"),\n        )\n\n        representation = {\n            \"name\": \"tpl\",\n            \"ext\": \"zip\",\n            \"files\": f\"{instance.name}.zip\",\n            \"stagingDir\": staging_dir\n        }\n\n        self.log.info(instance.data.get(\"representations\"))\n        if instance.data.get(\"representations\"):\n            instance.data[\"representations\"].extend([representation])\n        else:\n            instance.data[\"representations\"] = [representation]\n\n        instance.data[\"version_name\"] = \"{}_{}\".format(\n            instance.data[\"productName\"],\n            instance.context.data[\"task\"]\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_template.html#client.ayon_harmony.plugins.publish.extract_template.ExtractTemplate.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_template.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    staging_dir = self.staging_dir(instance)\n    filepath = os.path.join(staging_dir, \"harmony\", f\"{instance.name}.tpl\")\n\n    self.log.info(f\"Outputting template to {staging_dir}\")\n\n    # Export template\n    self.log.info(f'{instance.data[\"setMembers\"][0]}')\n    harmony.export_backdrop_as_template(\n        instance.data[\"setMembers\"][0], filepath\n    )\n\n    # Prep representation.\n    os.chdir(staging_dir)\n    shutil.make_archive(\n        f\"{instance.name}\",\n        \"zip\",\n        os.path.join(staging_dir, \"harmony\"),\n    )\n\n    representation = {\n        \"name\": \"tpl\",\n        \"ext\": \"zip\",\n        \"files\": f\"{instance.name}.zip\",\n        \"stagingDir\": staging_dir\n    }\n\n    self.log.info(instance.data.get(\"representations\"))\n    if instance.data.get(\"representations\"):\n        instance.data[\"representations\"].extend([representation])\n    else:\n        instance.data[\"representations\"] = [representation]\n\n    instance.data[\"version_name\"] = \"{}_{}\".format(\n        instance.data[\"productName\"],\n        instance.context.data[\"task\"]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_workfile.html","title":"extract_workfile","text":"<p>Extract work file.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_workfile.html#client.ayon_harmony.plugins.publish.extract_workfile.ExtractWorkfile","title":"<code>ExtractWorkfile</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract and zip complete workfile folder into zip.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_workfile.py</code> <pre><code>class ExtractWorkfile(publish.Extractor):\n    \"\"\"Extract and zip complete workfile folder into zip.\"\"\"\n\n    label = \"Extract Workfile\"\n    hosts = [\"harmony\"]\n    families = [\"workfile\"]\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        staging_dir = self.staging_dir(instance)\n        filepath = os.path.join(staging_dir, \"{}.tpl\".format(instance.name))\n        src = os.path.dirname(instance.context.data[\"currentFile\"])\n        # handle too long paths on windows\n        current_platform = platform.system().lower()\n        if current_platform == \"windows\":\n            src = fr\"\\\\?\\{src}\"\n            filepath = fr\"\\\\?\\{filepath}\"\n        self.log.info(f\"Copying to {filepath}\")\n        shutil.copytree(src, filepath)\n\n        # Prep representation.\n        os.chdir(staging_dir)\n        shutil.make_archive(\n            f\"{instance.name}\",\n            \"zip\",\n            os.path.join(staging_dir, f\"{instance.name}.tpl\")\n        )\n        # Check if archive is ok\n        with ZipFile(os.path.basename(f\"{instance.name}.zip\")) as zr:\n            if zr.testzip() is not None:\n                raise Exception(\"File archive is corrupted.\")\n\n        representation = {\n            \"name\": \"tpl\",\n            \"ext\": \"zip\",\n            \"files\": f\"{instance.name}.zip\",\n            \"stagingDir\": staging_dir\n        }\n        instance.data[\"representations\"] = [representation]\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_workfile.html#client.ayon_harmony.plugins.publish.extract_workfile.ExtractWorkfile.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_workfile.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    staging_dir = self.staging_dir(instance)\n    filepath = os.path.join(staging_dir, \"{}.tpl\".format(instance.name))\n    src = os.path.dirname(instance.context.data[\"currentFile\"])\n    # handle too long paths on windows\n    current_platform = platform.system().lower()\n    if current_platform == \"windows\":\n        src = fr\"\\\\?\\{src}\"\n        filepath = fr\"\\\\?\\{filepath}\"\n    self.log.info(f\"Copying to {filepath}\")\n    shutil.copytree(src, filepath)\n\n    # Prep representation.\n    os.chdir(staging_dir)\n    shutil.make_archive(\n        f\"{instance.name}\",\n        \"zip\",\n        os.path.join(staging_dir, f\"{instance.name}.tpl\")\n    )\n    # Check if archive is ok\n    with ZipFile(os.path.basename(f\"{instance.name}.zip\")) as zr:\n        if zr.testzip() is not None:\n            raise Exception(\"File archive is corrupted.\")\n\n    representation = {\n        \"name\": \"tpl\",\n        \"ext\": \"zip\",\n        \"files\": f\"{instance.name}.zip\",\n        \"stagingDir\": staging_dir\n    }\n    instance.data[\"representations\"] = [representation]\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/increment_workfile.html","title":"increment_workfile","text":""},{"location":"autoapi/client/ayon_harmony/plugins/publish/increment_workfile.html#client.ayon_harmony.plugins.publish.increment_workfile.IncrementWorkfile","title":"<code>IncrementWorkfile</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Increment the current workfile.</p> <p>Saves the current scene with an increased version number.</p> Source code in <code>client/ayon_harmony/plugins/publish/increment_workfile.py</code> <pre><code>class IncrementWorkfile(pyblish.api.InstancePlugin):\n    \"\"\"Increment the current workfile.\n\n    Saves the current scene with an increased version number.\n    \"\"\"\n\n    label = \"Increment Workfile\"\n    order = pyblish.api.IntegratorOrder + 9.0\n    hosts = [\"harmony\"]\n    families = [\"workfile\"]\n    optional = True\n\n    def process(self, instance):\n        errored_plugins = get_errored_plugins_from_context(instance.context)\n        if errored_plugins:\n            raise RuntimeError(\n                \"Skipping incrementing current file because publishing failed.\"\n            )\n\n        scene_dir = version_up(\n            os.path.dirname(instance.context.data[\"currentFile\"])\n        )\n        scene_path = os.path.join(\n            scene_dir, os.path.basename(scene_dir) + \".xstage\"\n        )\n\n        harmony.save_scene_as(scene_path)\n\n        self.log.info(\"Incremented workfile to: {}\".format(scene_path))\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_audio.html","title":"validate_audio","text":""},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_audio.html#client.ayon_harmony.plugins.publish.validate_audio.ValidateAudio","title":"<code>ValidateAudio</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Ensures that there is an audio file in the scene.</p> <p>If you are sure that you want to send render without audio, you can disable this validator before clicking on \"publish\"</p> Source code in <code>client/ayon_harmony/plugins/publish/validate_audio.py</code> <pre><code>class ValidateAudio(pyblish.api.InstancePlugin):\n    \"\"\"Ensures that there is an audio file in the scene.\n\n    If you are sure that you want to send render without audio, you can\n    disable this validator before clicking on \"publish\"\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Audio\"\n    families = [\"render\"]\n    hosts = [\"harmony\"]\n    settings_category = \"harmony\"\n    optional = True\n\n    def process(self, instance):\n        node = None\n        if instance.data.get(\"setMembers\"):\n            node = instance.data[\"setMembers\"][0]\n\n        if not node:\n            return\n        # Collect scene data.\n        func = \"\"\"function func(write_node)\n        {\n            return [\n                sound.getSoundtrackAll().path()\n            ]\n        }\n        func\n        \"\"\"\n        result = harmony.send(\n            {\"function\": func, \"args\": [node]}\n        )[\"result\"]\n\n        audio_path = result[0]\n\n        msg = \"You are missing audio file:\\n{}\".format(audio_path)\n\n        formatting_data = {\n            \"audio_url\": audio_path\n        }\n        if not os.path.isfile(audio_path):\n            raise PublishXmlValidationError(self, msg,\n                                            formatting_data=formatting_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_instances.html","title":"validate_instances","text":""},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_instances.html#client.ayon_harmony.plugins.publish.validate_instances.ValidateInstance","title":"<code>ValidateInstance</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate the instance folder is the current folder.</p> Source code in <code>client/ayon_harmony/plugins/publish/validate_instances.py</code> <pre><code>class ValidateInstance(pyblish.api.InstancePlugin):\n    \"\"\"Validate the instance folder is the current folder.\"\"\"\n\n    label = \"Validate Instance\"\n    hosts = [\"harmony\"]\n    actions = [ValidateInstanceRepair]\n    order = ValidateContentsOrder\n\n    def process(self, instance):\n        instance_folder_path = instance.data[\"folderPath\"]\n        current_colder_path = get_current_folder_path()\n        msg = (\n            \"Instance folder is not the same as current folder:\"\n            f\"\\nInstance: {instance_folder_path}]\"\n            f\"\\nCurrent: {current_colder_path}\"\n        )\n\n        formatting_data = {\n            \"found\": instance_folder_path,\n            \"expected\": current_colder_path\n        }\n        if instance_folder_path != current_colder_path:\n            raise PublishXmlValidationError(self, msg,\n                                            formatting_data=formatting_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_instances.html#client.ayon_harmony.plugins.publish.validate_instances.ValidateInstanceRepair","title":"<code>ValidateInstanceRepair</code>","text":"<p>               Bases: <code>Action</code></p> <p>Repair the instance.</p> Source code in <code>client/ayon_harmony/plugins/publish/validate_instances.py</code> <pre><code>class ValidateInstanceRepair(pyblish.api.Action):\n    \"\"\"Repair the instance.\"\"\"\n\n    label = \"Repair\"\n    icon = \"wrench\"\n    on = \"failed\"\n\n    def process(self, context, plugin):\n\n        # Get the errored instances\n        failed = []\n        for result in context.data[\"results\"]:\n            if (result[\"error\"] is not None and result[\"instance\"] is not None\n                    and result[\"instance\"] not in failed):\n                failed.append(result[\"instance\"])\n\n        # Apply pyblish.logic to get the instances for the plug-in\n        instances = pyblish.api.instances_by_plugin(failed, plugin)\n\n        folder_path = get_current_folder_path()\n        for instance in instances:\n            data = harmony.read(instance.data[\"setMembers\"][0])\n            data[\"folderPath\"] = folder_path\n            harmony.imprint(instance.data[\"setMembers\"][0], data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_scene_settings.html","title":"validate_scene_settings","text":"<p>Validate scene settings.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_scene_settings.html#client.ayon_harmony.plugins.publish.validate_scene_settings.ValidateSceneSettings","title":"<code>ValidateSceneSettings</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Ensure the scene settings are in sync with database.</p> Source code in <code>client/ayon_harmony/plugins/publish/validate_scene_settings.py</code> <pre><code>class ValidateSceneSettings(pyblish.api.InstancePlugin):\n    \"\"\"Ensure the scene settings are in sync with database.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Scene Settings\"\n    families = [\"workfile\"]\n    hosts = [\"harmony\"]\n    actions = [ValidateSceneSettingsRepair]\n    settings_category = \"harmony\"\n    optional = True\n\n    # skip frameEnd check if folder contains any of:\n    frame_check_filter = [\"_ch_\", \"_pr_\", \"_intd_\", \"_extd_\"]  # regex\n\n    # skip resolution check if Task name matches any of regex patterns\n    skip_resolution_check = [\"render\", \"Render\"]  # regex\n\n    # skip frameStart, frameEnd check if Task name matches any of regex patt.\n    skip_timelines_check = []  # regex\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n\n        # TODO 'get_current_context_settings' could expect folder entity\n        #   as an argument which is available on 'context.data[\"folderEntity\"]'\n        #   - the same approach can be used in 'ValidateSceneSettingsRepair'\n        expected_settings = harmony.get_current_context_settings()\n        self.log.info(\"scene settings from DB:{}\".format(expected_settings))\n\n        expected_settings = _update_frames(dict.copy(expected_settings))\n        expected_settings[\"frameEndHandle\"] = expected_settings[\"frameEnd\"] +\\\n            expected_settings[\"handleEnd\"]\n\n        task_name = instance.context.data[\"task\"]\n\n        if (any(re.search(pattern, task_name)\n                for pattern in self.skip_resolution_check)):\n            self.log.info(\"Skipping resolution check because of \"\n                          \"task name and pattern {}\".format(\n                              self.skip_resolution_check))\n            expected_settings.pop(\"resolutionWidth\")\n            expected_settings.pop(\"resolutionHeight\")\n\n        if (any(re.search(pattern, os.getenv('AYON_TASK_NAME'))\n                for pattern in self.skip_timelines_check)):\n            self.log.info(\"Skipping frames check because of \"\n                          \"task name and pattern {}\".format(\n                              self.skip_timelines_check))\n            expected_settings.pop('frameStart', None)\n            expected_settings.pop('frameEnd', None)\n            expected_settings.pop('frameStartHandle', None)\n            expected_settings.pop('frameEndHandle', None)\n\n        folder_name = instance.context.data[\"folderPath\"].rsplit(\"/\", 1)[-1]\n        if any(re.search(pattern, folder_name)\n                for pattern in self.frame_check_filter):\n            self.log.info(\"Skipping frames check because of \"\n                          \"task name and pattern {}\".format(\n                              self.frame_check_filter))\n            expected_settings.pop('frameStart', None)\n            expected_settings.pop('frameEnd', None)\n            expected_settings.pop('frameStartHandle', None)\n            expected_settings.pop('frameEndHandle', None)\n\n        # handle case when fps uses only two decimal places\n        # 23.976023976023978 vs. 23.98\n        fps = instance.context.data.get(\"frameRate\")\n        if isinstance(instance.context.data.get(\"frameRate\"), float):\n            fps = float(\n                \"{:.2f}\".format(instance.context.data.get(\"frameRate\")))\n\n        self.log.debug(\"filtered settings: {}\".format(expected_settings))\n\n        current_settings = {\n            \"fps\": fps,\n            \"frameStart\": instance.context.data[\"frameStart\"],\n            \"frameEnd\": instance.context.data[\"frameEnd\"],\n            \"handleStart\": instance.context.data.get(\"handleStart\"),\n            \"handleEnd\": instance.context.data.get(\"handleEnd\"),\n            \"frameStartHandle\": instance.context.data.get(\"frameStartHandle\"),\n            \"frameEndHandle\": instance.context.data.get(\"frameEndHandle\"),\n            \"resolutionWidth\": instance.context.data.get(\"resolutionWidth\"),\n            \"resolutionHeight\": instance.context.data.get(\"resolutionHeight\"),\n        }\n        self.log.debug(\"current scene settings {}\".format(current_settings))\n\n        invalid_settings = []\n        invalid_keys = set()\n        for key, value in expected_settings.items():\n            if value != current_settings[key]:\n                invalid_settings.append(\n                    \"{} expected: {}  found: {}\".format(key, value,\n                                                        current_settings[key]))\n                invalid_keys.add(key)\n\n        if ((expected_settings[\"handleStart\"]\n            or expected_settings[\"handleEnd\"])\n           and invalid_settings):\n            msg = \"Handles included in calculation. Remove handles in DB \" +\\\n                  \"or extend frame range in timeline.\"\n            invalid_settings[-1][\"reason\"] = msg\n\n        msg = \"Found invalid settings:\\n{}\".format(\n            json.dumps(invalid_settings, sort_keys=True, indent=4)\n        )\n\n        if invalid_settings:\n            invalid_keys_str = \",\".join(invalid_keys)\n            break_str = \"&lt;br/&gt;\"\n            invalid_setting_str = \"&lt;b&gt;Found invalid settings:&lt;/b&gt;&lt;br/&gt;{}\".\\\n                format(break_str.join(invalid_settings))\n\n            formatting_data = {\n                \"invalid_setting_str\": invalid_setting_str,\n                \"invalid_keys_str\": invalid_keys_str\n            }\n            raise PublishXmlValidationError(self, msg,\n                                            formatting_data=formatting_data)\n\n        scene_url = instance.context.data.get(\"scenePath\")\n        if not os.path.exists(scene_url):\n            msg = \"Scene file {} not found (saved under wrong name)\".format(\n                scene_url\n            )\n            formatting_data = {\n                \"scene_url\": scene_url\n            }\n            raise PublishXmlValidationError(self, msg, key=\"file_not_found\",\n                                            formatting_data=formatting_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_scene_settings.html#client.ayon_harmony.plugins.publish.validate_scene_settings.ValidateSceneSettings.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_harmony/plugins/publish/validate_scene_settings.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n\n    # TODO 'get_current_context_settings' could expect folder entity\n    #   as an argument which is available on 'context.data[\"folderEntity\"]'\n    #   - the same approach can be used in 'ValidateSceneSettingsRepair'\n    expected_settings = harmony.get_current_context_settings()\n    self.log.info(\"scene settings from DB:{}\".format(expected_settings))\n\n    expected_settings = _update_frames(dict.copy(expected_settings))\n    expected_settings[\"frameEndHandle\"] = expected_settings[\"frameEnd\"] +\\\n        expected_settings[\"handleEnd\"]\n\n    task_name = instance.context.data[\"task\"]\n\n    if (any(re.search(pattern, task_name)\n            for pattern in self.skip_resolution_check)):\n        self.log.info(\"Skipping resolution check because of \"\n                      \"task name and pattern {}\".format(\n                          self.skip_resolution_check))\n        expected_settings.pop(\"resolutionWidth\")\n        expected_settings.pop(\"resolutionHeight\")\n\n    if (any(re.search(pattern, os.getenv('AYON_TASK_NAME'))\n            for pattern in self.skip_timelines_check)):\n        self.log.info(\"Skipping frames check because of \"\n                      \"task name and pattern {}\".format(\n                          self.skip_timelines_check))\n        expected_settings.pop('frameStart', None)\n        expected_settings.pop('frameEnd', None)\n        expected_settings.pop('frameStartHandle', None)\n        expected_settings.pop('frameEndHandle', None)\n\n    folder_name = instance.context.data[\"folderPath\"].rsplit(\"/\", 1)[-1]\n    if any(re.search(pattern, folder_name)\n            for pattern in self.frame_check_filter):\n        self.log.info(\"Skipping frames check because of \"\n                      \"task name and pattern {}\".format(\n                          self.frame_check_filter))\n        expected_settings.pop('frameStart', None)\n        expected_settings.pop('frameEnd', None)\n        expected_settings.pop('frameStartHandle', None)\n        expected_settings.pop('frameEndHandle', None)\n\n    # handle case when fps uses only two decimal places\n    # 23.976023976023978 vs. 23.98\n    fps = instance.context.data.get(\"frameRate\")\n    if isinstance(instance.context.data.get(\"frameRate\"), float):\n        fps = float(\n            \"{:.2f}\".format(instance.context.data.get(\"frameRate\")))\n\n    self.log.debug(\"filtered settings: {}\".format(expected_settings))\n\n    current_settings = {\n        \"fps\": fps,\n        \"frameStart\": instance.context.data[\"frameStart\"],\n        \"frameEnd\": instance.context.data[\"frameEnd\"],\n        \"handleStart\": instance.context.data.get(\"handleStart\"),\n        \"handleEnd\": instance.context.data.get(\"handleEnd\"),\n        \"frameStartHandle\": instance.context.data.get(\"frameStartHandle\"),\n        \"frameEndHandle\": instance.context.data.get(\"frameEndHandle\"),\n        \"resolutionWidth\": instance.context.data.get(\"resolutionWidth\"),\n        \"resolutionHeight\": instance.context.data.get(\"resolutionHeight\"),\n    }\n    self.log.debug(\"current scene settings {}\".format(current_settings))\n\n    invalid_settings = []\n    invalid_keys = set()\n    for key, value in expected_settings.items():\n        if value != current_settings[key]:\n            invalid_settings.append(\n                \"{} expected: {}  found: {}\".format(key, value,\n                                                    current_settings[key]))\n            invalid_keys.add(key)\n\n    if ((expected_settings[\"handleStart\"]\n        or expected_settings[\"handleEnd\"])\n       and invalid_settings):\n        msg = \"Handles included in calculation. Remove handles in DB \" +\\\n              \"or extend frame range in timeline.\"\n        invalid_settings[-1][\"reason\"] = msg\n\n    msg = \"Found invalid settings:\\n{}\".format(\n        json.dumps(invalid_settings, sort_keys=True, indent=4)\n    )\n\n    if invalid_settings:\n        invalid_keys_str = \",\".join(invalid_keys)\n        break_str = \"&lt;br/&gt;\"\n        invalid_setting_str = \"&lt;b&gt;Found invalid settings:&lt;/b&gt;&lt;br/&gt;{}\".\\\n            format(break_str.join(invalid_settings))\n\n        formatting_data = {\n            \"invalid_setting_str\": invalid_setting_str,\n            \"invalid_keys_str\": invalid_keys_str\n        }\n        raise PublishXmlValidationError(self, msg,\n                                        formatting_data=formatting_data)\n\n    scene_url = instance.context.data.get(\"scenePath\")\n    if not os.path.exists(scene_url):\n        msg = \"Scene file {} not found (saved under wrong name)\".format(\n            scene_url\n        )\n        formatting_data = {\n            \"scene_url\": scene_url\n        }\n        raise PublishXmlValidationError(self, msg, key=\"file_not_found\",\n                                        formatting_data=formatting_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_scene_settings.html#client.ayon_harmony.plugins.publish.validate_scene_settings.ValidateSceneSettingsRepair","title":"<code>ValidateSceneSettingsRepair</code>","text":"<p>               Bases: <code>Action</code></p> <p>Repair the instance.</p> Source code in <code>client/ayon_harmony/plugins/publish/validate_scene_settings.py</code> <pre><code>class ValidateSceneSettingsRepair(pyblish.api.Action):\n    \"\"\"Repair the instance.\"\"\"\n\n    label = \"Repair\"\n    icon = \"wrench\"\n    on = \"failed\"\n\n    def process(self, context, plugin):\n        \"\"\"Repair action entry point.\"\"\"\n        expected = harmony.get_current_context_settings()\n        expected_settings = _update_frames(dict.copy(expected))\n        expected_settings[\"frameStart\"] = 1\n        expected_settings[\"frameEnd\"] = expected_settings[\"frameEnd\"] + \\\n            expected_settings[\"handleEnd\"]\n        harmony.set_scene_settings(expected_settings)\n        if not os.path.exists(context.data[\"scenePath\"]):\n            self.log.info(\"correcting scene name\")\n            scene_dir = os.path.dirname(context.data[\"currentFile\"])\n            scene_path = os.path.join(\n                scene_dir, os.path.basename(scene_dir) + \".xstage\"\n            )\n            harmony.save_scene_as(scene_path)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_scene_settings.html#client.ayon_harmony.plugins.publish.validate_scene_settings.ValidateSceneSettingsRepair.process","title":"<code>process(context, plugin)</code>","text":"<p>Repair action entry point.</p> Source code in <code>client/ayon_harmony/plugins/publish/validate_scene_settings.py</code> <pre><code>def process(self, context, plugin):\n    \"\"\"Repair action entry point.\"\"\"\n    expected = harmony.get_current_context_settings()\n    expected_settings = _update_frames(dict.copy(expected))\n    expected_settings[\"frameStart\"] = 1\n    expected_settings[\"frameEnd\"] = expected_settings[\"frameEnd\"] + \\\n        expected_settings[\"handleEnd\"]\n    harmony.set_scene_settings(expected_settings)\n    if not os.path.exists(context.data[\"scenePath\"]):\n        self.log.info(\"correcting scene name\")\n        scene_dir = os.path.dirname(context.data[\"currentFile\"])\n        scene_path = os.path.join(\n            scene_dir, os.path.basename(scene_dir) + \".xstage\"\n        )\n        harmony.save_scene_as(scene_path)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/vendor/index.html","title":"vendor","text":""},{"location":"autoapi/client/ayon_harmony/vendor/OpenHarmony/index.html","title":"OpenHarmony","text":""},{"location":"autoapi/client/ayon_harmony/vendor/OpenHarmony/openHarmony/index.html","title":"openHarmony","text":""},{"location":"autoapi/client/ayon_harmony/vendor/OpenHarmony/reference/index.html","title":"reference","text":""},{"location":"autoapi/client/ayon_harmony/vendor/OpenHarmony/tools/index.html","title":"tools","text":""},{"location":"autoapi/client/ayon_harmony/vendor/OpenHarmony/tools/OpenHarmony_basic/index.html","title":"OpenHarmony_basic","text":""},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/index.html#server.settings.HarmonySettings","title":"<code>HarmonySettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Harmony Project Settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class HarmonySettings(BaseSettingsModel):\n    \"\"\"Harmony Project Settings.\"\"\"\n\n    imageio: HarmonyImageIOModel = SettingsField(\n        default_factory=HarmonyImageIOModel,\n        title=\"OCIO config\"\n    )\n    create: HarmonyCreatePlugins = SettingsField(\n        default_factory=HarmonyCreatePlugins,\n        title=\"Creator plugins\"\n    )\n    publish: HarmonyPublishPlugins = SettingsField(\n        default_factory=HarmonyPublishPlugins,\n        title=\"Publish plugins\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html","title":"creator_plugins","text":""},{"location":"autoapi/server/settings/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/main.html#server.settings.main.HarmonySettings","title":"<code>HarmonySettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Harmony Project Settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class HarmonySettings(BaseSettingsModel):\n    \"\"\"Harmony Project Settings.\"\"\"\n\n    imageio: HarmonyImageIOModel = SettingsField(\n        default_factory=HarmonyImageIOModel,\n        title=\"OCIO config\"\n    )\n    create: HarmonyCreatePlugins = SettingsField(\n        default_factory=HarmonyCreatePlugins,\n        title=\"Creator plugins\"\n    )\n    publish: HarmonyPublishPlugins = SettingsField(\n        default_factory=HarmonyPublishPlugins,\n        title=\"Publish plugins\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html","title":"publish_plugins","text":""},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.CollectPalettesPlugin","title":"<code>CollectPalettesPlugin</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Set regular expressions to filter triggering on specific task names. '.*' means on all.</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class CollectPalettesPlugin(BaseSettingsModel):\n    \"\"\"Set regular expressions to filter triggering on specific task names. '.*' means on all.\"\"\"  # noqa\n\n    allowed_tasks: list[str] = SettingsField(\n        default_factory=list,\n        title=\"Allowed tasks\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.ValidateAudioPlugin","title":"<code>ValidateAudioPlugin</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Check if scene contains audio track.</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class ValidateAudioPlugin(BaseSettingsModel):\n    \"\"\"Check if scene contains audio track.\"\"\"  #\n    _isGroup = True\n    enabled: bool = True\n    optional: bool = SettingsField(False, title=\"Optional\")\n    active: bool = SettingsField(True, title=\"Active\")\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.ValidateSceneSettingsPlugin","title":"<code>ValidateSceneSettingsPlugin</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Validate if FrameStart, FrameEnd and Resolution match shot data in DB. Use regular expressions to limit validations only on particular folder or task names.</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class ValidateSceneSettingsPlugin(BaseSettingsModel):\n    \"\"\"Validate if FrameStart, FrameEnd and Resolution match shot data in DB.\n       Use regular expressions to limit validations only on particular folder\n       or task names.\"\"\"\n    _isGroup = True\n    enabled: bool = True\n    optional: bool = SettingsField(False, title=\"Optional\")\n    active: bool = SettingsField(True, title=\"Active\")\n\n    frame_check_filter: list[str] = SettingsField(\n        default_factory=list,\n        title=\"Skip Frame check for Folder Paths with name containing\"\n    )\n\n    skip_resolution_check: list[str] = SettingsField(\n        default_factory=list,\n        title=\"Skip Resolution Check for Tasks\"\n    )\n\n    skip_timelines_check: list[str] = SettingsField(\n        default_factory=list,\n        title=\"Skip Timeline Check for Tasks\"\n    )\n</code></pre>"}]}