{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Harmony Integration","text":""},{"location":"index.html#implemented-functionality","title":"Implemented functionality:","text":"<ul> <li>workfile management</li> <li>creators for:</li> <li>render - locally/farm</li> <li>palette - automatic during collection</li> <li>template - group of nodes wrapped in Backdrop</li> <li>loaders for:</li> <li>audio</li> <li>background - json file and list of images</li> <li>image sequences</li> <li>palette</li> <li>template</li> <li>whole Harmony workfile</li> </ul> <p>It should reasonably support even Harmony Advanced (without Node View) - templates will not work as it is required to wrap nodes that should be in a template which is not possible without Node View.</p>"},{"location":"index.html#setup","title":"Setup","text":"<p>The easiest way to setup for using Toon Boom Harmony is to use the built-in launch:</p> <pre><code>python -c \"import ayon_harmony.api as harmony;harmony.launch(\"path/to/harmony/executable\")\"\n</code></pre> <p>Communication with Harmony happens with a server/client relationship where the server is in the Python process and the client is in the Harmony process. Messages between Python and Harmony are required to be dictionaries, which are serialized to strings:</p> <pre><code>+------------+\n|            |\n|   Python   |\n|   Process  |\n|            |\n| +--------+ |\n| |        | |\n| |  Main  | |\n| | Thread | |\n| |        | |\n| +----^---+ |\n|     ||     |\n|     ||     |\n| +---v----+ |     +---------+\n| |        | |     |         |\n| | Server +-------&gt; Harmony |\n| | Thread &lt;-------+ Process |\n| |        | |     |         |\n| +--------+ |     +---------+\n+------------+\n</code></pre> <p>Server/client now uses stricter protocol to handle communication. This is necessary because of precise control over data passed between server/client. Each message is prepended with 6 bytes:</p> <pre><code>| A | H | 0x00 | 0x00 | 0x00 | 0x00 | ...\n\n</code></pre> <p>First two bytes are magic bytes stands for Ayon Harmony. Next four bytes hold length of the message <code>...</code> encoded as 32bit unsigned integer. This way we know how many bytes to read from the socket and if we need more or we need to parse multiple messages.</p>"},{"location":"index.html#usage","title":"Usage","text":"<p>The integration creates an <code>AYON</code> menu entry where all related tools are located.</p> <p>NOTE: Menu creation can be temperamental. The best way is to launch Harmony and do nothing else until Harmony is fully launched.</p>"},{"location":"index.html#work-files","title":"Work files","text":"<p>Because Harmony projects are directories, this integration uses <code>.zip</code> as work file extension. Internally the project directories are stored under <code>[User]/.ayon/harmony</code>. Whenever the user saves the <code>.xstage</code> file, the integration zips up the project directory and moves it to the AYON project path. Zipping and moving happens in the background.</p>"},{"location":"index.html#show-workfiles-on-launch","title":"Show Workfiles on launch","text":"<p>You can show the Workfiles app when Harmony launches by setting environment variable <code>AYON_HARMONY_WORKFILES_ON_LAUNCH=1</code>.</p>"},{"location":"index.html#developing","title":"Developing","text":""},{"location":"index.html#low-level-messaging","title":"Low level messaging","text":"<p>To send from Python to Harmony you can use the exposed method:</p> <pre><code>import ayon_harmony.api as harmony\nfrom uuid import uuid4\n\n\nfunc = \"\"\"function %s_hello(person)\n{\n  return (\"Hello \" + person + \"!\");\n}\n%s_hello\n\"\"\" % (uuid4(), uuid4())\nprint(harmony.send({\"function\": func, \"args\": [\"Python\"]})[\"result\"])\n</code></pre> <p>NOTE: Its important to declare the function at the end of the function string. You can have multiple functions within your function string, but the function declared at the end is what gets executed.</p> <p>To send a function with multiple arguments its best to declare the arguments within the function:</p> <pre><code>import ayon_harmony.api as harmony\nfrom uuid import uuid4\n\nsignature = str(uuid4()).replace(\"-\", \"_\")\nfunc = \"\"\"function %s_hello(args)\n{\n  var greeting = args[0];\n  var person = args[1];\n  return (greeting + \" \" + person + \"!\");\n}\n%s_hello\n\"\"\" % (signature, signature)\nprint(harmony.send({\"function\": func, \"args\": [\"Hello\", \"Python\"]})[\"result\"])\n</code></pre>"},{"location":"index.html#caution","title":"Caution","text":"<p>When naming your functions be aware that they are executed in global scope. They can potentially clash with Harmony own function and object names. For example <code>func</code> is already existing Harmony object. When you call your function <code>func</code> it will overwrite in global scope the one from Harmony, causing erratic behavior of Harmony. AYON is prefixing those function names with UUID4 making chance of such clash minimal. See above examples how that works. This will result in function named <code>38dfcef0_a6d7_4064_8069_51fe99ab276e_hello()</code>. You can find list of Harmony object and function in Harmony documentation.</p>"},{"location":"index.html#higher-level-recommended","title":"Higher level (recommended)","text":"<p>Instead of sending functions directly to Harmony, it is more efficient and safe to just add your code to <code>js/AyonHarmony.js</code> or utilize <code>{\"script\": \"...\"}</code> method.</p>"},{"location":"index.html#extending-ayonharmonyjs","title":"Extending AyonHarmony.js","text":"<p>Add your function to <code>AyonHarmony.js</code>. For example:</p> <pre><code>AyonHarmony.myAwesomeFunction = function() {\n  someCoolStuff();\n};\n</code></pre> <p>Then you can call that javascript code from your Python like:</p> <pre><code>import ayon_harmony.api as harmony\n\nharmony.send({\"function\": \"AyonHarmony.myAwesomeFunction\"});\n\n</code></pre>"},{"location":"index.html#using-script-method","title":"Using Script method","text":"<p>You can also pass whole scripts into harmony and call their functions later as needed.</p> <p>For example, you have bunch of javascript files:</p> <pre><code>/* Master.js */\n\nvar Master = {\n  Foo = {};\n  Boo = {};\n};\n\n/* FileA.js */\nvar Foo = function() {};\n\nFoo.prototype.A = function() {\n  someAStuff();\n}\n\n// This will construct object Foo and add it to Master namespace.\nMaster.Foo = new Foo();\n\n/* FileB.js */\nvar Boo = function() {};\n\nBoo.prototype.B = function() {\n  someBStuff();\n}\n\n// This will construct object Boo and add it to Master namespace.\nMaster.Boo = new Boo();\n</code></pre> <p>Now in python, just read all those files and send them to Harmony.</p> <pre><code>from pathlib import Path\nimport ayon_harmony.api as harmony\n\npath_to_js = Path('/path/to/my/js')\nscript_to_send = \"\"\n\nfor file in path_to_js.iterdir():\n  if file.suffix == \".js\":\n    script_to_send += file.read_text()\n\nharmony.send({\"script\": script_to_send})\n\n# and use your code in Harmony\nharmony.send({\"function\": \"Master.Boo.B\"})\n\n</code></pre>"},{"location":"index.html#scene-save","title":"Scene Save","text":"<p>Instead of sending a request to Harmony with <code>scene.saveAll</code> please use:</p> <pre><code>import ayon_harmony.api as harmony\nharmony.save_scene()\n</code></pre> Click to expand for details on scene save.    Because AYON tools do not deal well with folders for a single entity like a Harmony scene, this integration has implemented to use zip files to encapsulate the Harmony scene folders. Saving scene in Harmony via menu or CTRL+S will not result in producing zip file, only saving it from Workfiles will. This is because   zipping process can take some time in which we cannot block user from saving again. If xstage file is changed during zipping process it will produce corrupted zip   archive."},{"location":"index.html#resources","title":"Resources","text":"<ul> <li>https://github.com/diegogarciahuerta/tk-harmony</li> <li>https://github.com/cfourney/OpenHarmony</li> <li>Toon Boom Discord</li> <li>Toon Boom TD</li> </ul>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_harmony<ul> <li>addon</li> <li>api<ul> <li>base_loaders</li> <li>launch_script</li> <li>lib</li> <li>pipeline</li> <li>plugin</li> <li>server</li> <li>workio</li> </ul> </li> <li>hooks<ul> <li>pre_launch_args</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>convert_legacy</li> <li>create_render</li> <li>create_render_layers</li> <li>create_review</li> <li>create_template</li> <li>create_workfile</li> </ul> </li> <li>load<ul> <li>load_audio</li> <li>load_background</li> <li>load_imagesequence</li> <li>load_layers</li> <li>load_palette</li> <li>load_template</li> <li>load_template_workfile</li> </ul> </li> <li>publish<ul> <li>collect_audio</li> <li>collect_current_file</li> <li>collect_farm_render</li> <li>collect_instances</li> <li>collect_palettes</li> <li>collect_scene</li> <li>extract_convert_to_exr</li> <li>extract_palette</li> <li>extract_render</li> <li>extract_review_source</li> <li>extract_save_scene</li> <li>extract_template</li> <li>extract_workfile</li> <li>increment_workfile</li> <li>validate_audio</li> <li>validate_instances</li> <li>validate_review_source</li> <li>validate_scene_settings</li> </ul> </li> </ul> </li> <li>vendor<ul> <li>OpenHarmony<ul> <li>openHarmony<ul> <li>classes</li> </ul> </li> <li>reference</li> <li>tools<ul> <li>OpenHarmony_basic</li> </ul> </li> </ul> </li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>creator_plugins</li> <li>imageio</li> <li>main</li> <li>publish_plugins</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_harmony/index.html","title":"ayon_harmony","text":""},{"location":"autoapi/client/ayon_harmony/index.html#client.ayon_harmony.HarmonyAddon","title":"<code>HarmonyAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_harmony/addon.py</code> <pre><code>class HarmonyAddon(AYONAddon, IHostAddon):\n    name = \"harmony\"\n    version = __version__\n    host_name = \"harmony\"\n\n    def add_implementation_envs(self, env, _app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n        openharmony_path = os.path.join(\n            HARMONY_ADDON_ROOT, \"vendor\", \"OpenHarmony\"\n        )\n        # TODO check if is already set? What to do if is already set?\n        env[\"LIB_OPENHARMONY_PATH\"] = openharmony_path\n\n    def get_workfile_extensions(self):\n        return [\".zip\"]\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(HARMONY_ADDON_ROOT, \"hooks\")\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/index.html#client.ayon_harmony.HarmonyAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_harmony/addon.py</code> <pre><code>def add_implementation_envs(self, env, _app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n    openharmony_path = os.path.join(\n        HARMONY_ADDON_ROOT, \"vendor\", \"OpenHarmony\"\n    )\n    # TODO check if is already set? What to do if is already set?\n    env[\"LIB_OPENHARMONY_PATH\"] = openharmony_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_harmony/addon.html#client.ayon_harmony.addon.HarmonyAddon","title":"<code>HarmonyAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_harmony/addon.py</code> <pre><code>class HarmonyAddon(AYONAddon, IHostAddon):\n    name = \"harmony\"\n    version = __version__\n    host_name = \"harmony\"\n\n    def add_implementation_envs(self, env, _app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n        openharmony_path = os.path.join(\n            HARMONY_ADDON_ROOT, \"vendor\", \"OpenHarmony\"\n        )\n        # TODO check if is already set? What to do if is already set?\n        env[\"LIB_OPENHARMONY_PATH\"] = openharmony_path\n\n    def get_workfile_extensions(self):\n        return [\".zip\"]\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(HARMONY_ADDON_ROOT, \"hooks\")\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/addon.html#client.ayon_harmony.addon.HarmonyAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_harmony/addon.py</code> <pre><code>def add_implementation_envs(self, env, _app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n    openharmony_path = os.path.join(\n        HARMONY_ADDON_ROOT, \"vendor\", \"OpenHarmony\"\n    )\n    # TODO check if is already set? What to do if is already set?\n    env[\"LIB_OPENHARMONY_PATH\"] = openharmony_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/version.html","title":"version","text":"<p>Package declaring AYON addon 'harmony' version.</p>"},{"location":"autoapi/client/ayon_harmony/api/index.html","title":"api","text":"<p>Public API</p> <p>Anything that isn't defined here is INTERNAL and unreliable for external use.</p>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.BackdropBaseLoader","title":"<code>BackdropBaseLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load nodes into a backdrop.</p> Source code in <code>client/ayon_harmony/api/base_loaders.py</code> <pre><code>class BackdropBaseLoader(load.LoaderPlugin):\n    \"\"\"Load nodes into a backdrop.\"\"\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        \"\"\"Plugin entry point.\n\n        Args:\n            context (:class:`pyblish.api.Context`): Context.\n            name (str, optional): Container name.\n            namespace (str, optional): Container namespace.\n            data (dict, optional): Additional data passed into loader.\n\n        \"\"\"\n        self_name = self.__class__.__name__\n        filepath = self.filepath_from_context(context)\n\n        backdrop_name = harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Loaders.{self_name}.loadContainer\",\n                \"args\": [filepath, name],\n            }\n        )[\"result\"]\n\n        # We must validate the group_node\n        return harmony.containerise(\n            name,\n            namespace,\n            backdrop_name,\n            context,\n            self_name\n        )\n\n    def remove(self, container):\n        \"\"\"Remove container.\n\n        Args:\n            container (dict): container definition.\n        \"\"\"\n        container_backdrop = harmony.find_backdrop_by_name(container[\"name\"])\n        if container_backdrop:\n            harmony.send(\n                {\n                    \"function\": \"AyonHarmony.removeBackdrop\",\n                    \"args\": [container_backdrop, True]\n                }\n            )\n        harmony.remove(container[\"name\"])\n\n    def update(self, container, context):\n        \"\"\"Update loaded containers.\n\n        Args:\n            container (dict): Container data.\n            context (dict): Representation context data.\n\n        \"\"\"\n        return self.switch(container, context)\n\n    def switch(self, container, context):\n        \"\"\"Switch representation containers.\"\"\"\n        backdrop_name = container[\"name\"]\n        backdrop = harmony.find_backdrop_by_name(backdrop_name)\n\n        # Keep backdrop links\n        backdrop_links = harmony.send(\n            {\n                \"function\": \"AyonHarmony.getBackdropLinks\",\n                \"args\": backdrop,\n            }\n        )[\"result\"]\n\n        # Replace template container\n        self.remove(container)  # Before load to avoid node name incrementation\n        container = self.load(\n            context, container[\"name\"], container[\"namespace\"]\n        )\n\n        # Restore backdrop links\n        harmony.send(\n            {\n                \"function\": \"AyonHarmony.setNodesLinks\",\n                \"args\": backdrop_links\n            }\n        )\n\n        return container\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.BackdropBaseLoader.load","title":"<code>load(context, name=None, namespace=None, data=None)</code>","text":"<p>Plugin entry point.</p> <p>Parameters:</p> Name Type Description Default <code>context (</code> <p>class:<code>pyblish.api.Context</code>): Context.</p> required <code>name</code> <code>str</code> <p>Container name.</p> <code>None</code> <code>namespace</code> <code>str</code> <p>Container namespace.</p> <code>None</code> <code>data</code> <code>dict</code> <p>Additional data passed into loader.</p> <code>None</code> Source code in <code>client/ayon_harmony/api/base_loaders.py</code> <pre><code>def load(self, context, name=None, namespace=None, data=None):\n    \"\"\"Plugin entry point.\n\n    Args:\n        context (:class:`pyblish.api.Context`): Context.\n        name (str, optional): Container name.\n        namespace (str, optional): Container namespace.\n        data (dict, optional): Additional data passed into loader.\n\n    \"\"\"\n    self_name = self.__class__.__name__\n    filepath = self.filepath_from_context(context)\n\n    backdrop_name = harmony.send(\n        {\n            \"function\": f\"AyonHarmony.Loaders.{self_name}.loadContainer\",\n            \"args\": [filepath, name],\n        }\n    )[\"result\"]\n\n    # We must validate the group_node\n    return harmony.containerise(\n        name,\n        namespace,\n        backdrop_name,\n        context,\n        self_name\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.BackdropBaseLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove container.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>dict</code> <p>container definition.</p> required Source code in <code>client/ayon_harmony/api/base_loaders.py</code> <pre><code>def remove(self, container):\n    \"\"\"Remove container.\n\n    Args:\n        container (dict): container definition.\n    \"\"\"\n    container_backdrop = harmony.find_backdrop_by_name(container[\"name\"])\n    if container_backdrop:\n        harmony.send(\n            {\n                \"function\": \"AyonHarmony.removeBackdrop\",\n                \"args\": [container_backdrop, True]\n            }\n        )\n    harmony.remove(container[\"name\"])\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.BackdropBaseLoader.switch","title":"<code>switch(container, context)</code>","text":"<p>Switch representation containers.</p> Source code in <code>client/ayon_harmony/api/base_loaders.py</code> <pre><code>def switch(self, container, context):\n    \"\"\"Switch representation containers.\"\"\"\n    backdrop_name = container[\"name\"]\n    backdrop = harmony.find_backdrop_by_name(backdrop_name)\n\n    # Keep backdrop links\n    backdrop_links = harmony.send(\n        {\n            \"function\": \"AyonHarmony.getBackdropLinks\",\n            \"args\": backdrop,\n        }\n    )[\"result\"]\n\n    # Replace template container\n    self.remove(container)  # Before load to avoid node name incrementation\n    container = self.load(\n        context, container[\"name\"], container[\"namespace\"]\n    )\n\n    # Restore backdrop links\n    harmony.send(\n        {\n            \"function\": \"AyonHarmony.setNodesLinks\",\n            \"args\": backdrop_links\n        }\n    )\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.BackdropBaseLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update loaded containers.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>dict</code> <p>Container data.</p> required <code>context</code> <code>dict</code> <p>Representation context data.</p> required Source code in <code>client/ayon_harmony/api/base_loaders.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update loaded containers.\n\n    Args:\n        container (dict): Container data.\n        context (dict): Representation context data.\n\n    \"\"\"\n    return self.switch(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.HarmonyHost","title":"<code>HarmonyHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>class HarmonyHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"harmony\"\n\n    _context_key = \"AYON_context\"\n\n    def install(self):\n        \"\"\"Install Pype as host config.\"\"\"\n        print(\"Installing AYON Harmony Host ...\")\n\n        pyblish.api.register_host(\"harmony\")\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n\n        register_event_callback(\"application.launched\", application_launch)\n\n    def uninstall(self):\n        pyblish.api.deregister_plugin_path(PUBLISH_PATH)\n        deregister_loader_plugin_path(LOAD_PATH)\n        deregister_creator_plugin_path(CREATE_PATH)\n\n    def open_workfile(self, filepath):\n        return open_file(filepath)\n\n    def save_workfile(self, filepath=None):\n        return save_file(filepath)\n\n    def work_root(self, session):\n        return work_root(session)\n\n    def get_current_workfile(self):\n        return current_file()\n\n    def workfile_has_unsaved_changes(self):\n        return has_unsaved_changes()\n\n    def get_workfile_extensions(self):\n        return file_extensions()\n\n    def get_containers(self):\n        return ls()\n\n    def get_context_data(self):\n        return get_scene_data().get(self._context_key, {})\n\n    def update_context_data(self, data, changes):\n        scene_data = get_scene_data()\n        context_data = scene_data.setdefault(self._context_key, {})\n        context_data.update(data)\n        set_scene_data(scene_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.HarmonyHost.install","title":"<code>install()</code>","text":"<p>Install Pype as host config.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Install Pype as host config.\"\"\"\n    print(\"Installing AYON Harmony Host ...\")\n\n    pyblish.api.register_host(\"harmony\")\n    pyblish.api.register_plugin_path(PUBLISH_PATH)\n    register_loader_plugin_path(LOAD_PATH)\n    register_creator_plugin_path(CREATE_PATH)\n\n    register_event_callback(\"application.launched\", application_launch)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.application_launch","title":"<code>application_launch(event)</code>","text":"<p>Event that is executed after Harmony is launched.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def application_launch(event):\n    \"\"\"Event that is executed after Harmony is launched.\"\"\"\n    # fills AYON_HARMONY_JS\n    ayon_harmony_path = Path(__file__).parent.parent / \"js\" / \"AyonHarmony.js\"\n    ayon_harmony_js = ayon_harmony_path.read_text()\n\n    # go through js/creators, loaders and publish folders and load all scripts\n    script = \"\"\n    for item in [\"creators\", \"loaders\", \"publish\"]:\n        dir_to_scan = Path(__file__).parent.parent / \"js\" / item\n        for child in dir_to_scan.iterdir():\n            script += child.read_text()\n\n    # send scripts to Harmony\n    harmony.send({\"script\": ayon_harmony_js})\n    harmony.send({\"script\": script})\n    inject_ayon_js()\n\n    # ensure_scene_settings()\n    check_inventory()\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.check_inventory","title":"<code>check_inventory()</code>","text":"<p>Check is scene contains outdated containers.</p> <p>If it does it will colorize outdated nodes and display warning message in Harmony.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def check_inventory():\n    \"\"\"Check is scene contains outdated containers.\n\n    If it does it will colorize outdated nodes and display warning message\n    in Harmony.\n    \"\"\"\n\n    outdated_containers = get_outdated_containers()\n    if not outdated_containers:\n        return\n\n    # Colour nodes.\n    outdated_nodes = []\n    for container in outdated_containers:\n        if container[\"loader\"] == \"ImageSequenceLoader\":\n            outdated_nodes.append(\n                harmony.find_node_by_name(container[\"name\"], \"READ\")\n            )\n    harmony.send({\"function\": \"AyonHarmony.setColor\", \"args\": outdated_nodes})\n\n    # Warn about outdated containers.\n    msg = \"There are outdated containers in the scene.\"\n    harmony.send({\"function\": \"AyonHarmony.message\", \"args\": msg})\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.containerise","title":"<code>containerise(name, namespace, node, context, loader=None, suffix=None, nodes=None)</code>","text":"<p>Imprint node with metadata.</p> <p>Containerisation enables a tracking of version, author and origin for loaded product representations.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly.</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container.</p> required <code>node</code> <code>str</code> <p>Node to containerise.</p> required <code>context</code> <code>dict</code> <p>Loaded representation full context information.</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>container</code> <code>str</code> <p>Path of container assembly.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def containerise(name,\n                 namespace,\n                 node,\n                 context,\n                 loader=None,\n                 suffix=None,\n                 nodes=None):\n    \"\"\"Imprint node with metadata.\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded product representations.\n\n    Arguments:\n        name (str): Name of resulting assembly.\n        namespace (str): Namespace under which to host container.\n        node (str): Node to containerise.\n        context (dict): Loaded representation full context information.\n        loader (str, optional): Name of loader used to produce this container.\n        suffix (str, optional): Suffix of container, defaults to `_CON`.\n\n    Returns:\n        container (str): Path of container assembly.\n    \"\"\"\n    if not nodes:\n        nodes = []\n\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace,\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"nodes\": nodes\n    }\n\n    harmony.imprint(node, data)\n\n    return node\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.current_file","title":"<code>current_file()</code>","text":"<p>Returning None to make Workfiles app look at first file extension.</p> Source code in <code>client/ayon_harmony/api/workio.py</code> <pre><code>def current_file():\n    \"\"\"Returning None to make Workfiles app look at first file extension.\"\"\"\n    return ProcessContext.workfile_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.delete_node","title":"<code>delete_node(node)</code>","text":"<p>Physically delete node from scene.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def delete_node(node):\n    \"\"\" Physically delete node from scene. \"\"\"\n    send(\n        {\n            \"function\": \"AyonHarmonyAPI.deleteNode\",\n            \"args\": node\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.ensure_scene_settings","title":"<code>ensure_scene_settings()</code>","text":"<p>Validate if Harmony scene has valid settings.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def ensure_scene_settings():\n    \"\"\"Validate if Harmony scene has valid settings.\"\"\"\n    settings = get_current_context_settings()\n\n    invalid_settings = []\n    valid_settings = {}\n    for key, value in settings.items():\n        if value is None:\n            invalid_settings.append(key)\n        else:\n            valid_settings[key] = value\n\n    # Warn about missing attributes.\n    if invalid_settings:\n        msg = \"Missing attributes:\"\n        for item in invalid_settings:\n            msg += f\"\\n{item}\"\n\n        harmony.send(\n            {\"function\": \"AyonHarmony.message\", \"args\": msg})\n\n    set_scene_settings(valid_settings)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.export_backdrop_as_template","title":"<code>export_backdrop_as_template(backdrop, filepath)</code>","text":"<p>Export Backdrop as Template (.tpl) file.</p> <p>Parameters:</p> Name Type Description Default <code>backdrop</code> <code>list</code> <p>Backdrop to export.</p> required <code>filepath</code> <code>str</code> <p>Path where to save Template.</p> required Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def export_backdrop_as_template(backdrop, filepath):\n    \"\"\"Export Backdrop as Template (.tpl) file.\n\n    Args:\n        backdrop (list): Backdrop to export.\n        filepath (str): Path where to save Template.\n    \"\"\"\n    harmony.send({\n        \"function\": \"AyonHarmony.exportBackdropAsTemplate\",\n        \"args\": [\n            backdrop,\n            os.path.basename(filepath),\n            os.path.dirname(filepath)\n        ]\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.find_backdrop_by_name","title":"<code>find_backdrop_by_name(name)</code>","text":"<p>Find backdrop by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the backdrop.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Optional[dict]</code> <p>Backdrop.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def find_backdrop_by_name(name: str) -&gt; Optional[dict]:\n    \"\"\"Find backdrop by its name.\n\n    Args:\n        name (str): Name of the backdrop.\n\n    Returns:\n        dict: Backdrop.\n    \"\"\"\n    backdrops = send(\n        {\"function\": \"Backdrop.backdrops\", \"args\": [\"Top\"]}\n    )[\"result\"]\n    for backdrop in backdrops:\n        if backdrop[\"title\"][\"text\"] == name:\n            return backdrop\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.find_node_by_name","title":"<code>find_node_by_name(name, node_type)</code>","text":"<p>Find node by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the Node. (without part before '/')</p> required <code>node_type</code> <code>str</code> <p>Type of the Node. 'READ' - for loaded data with Loaders (background) 'GROUP' - for loaded data with Loaders (templates) 'WRITE' - render nodes</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>FQ Node name.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def find_node_by_name(name, node_type):\n    \"\"\"Find node by its name.\n\n    Args:\n        name (str): Name of the Node. (without part before '/')\n        node_type (str): Type of the Node.\n            'READ' - for loaded data with Loaders (background)\n            'GROUP' - for loaded data with Loaders (templates)\n            'WRITE' - render nodes\n\n    Returns:\n        str: FQ Node name.\n\n    \"\"\"\n    nodes = send(\n        {\"function\": \"node.getNodes\", \"args\": [[node_type]]}\n    )[\"result\"]\n    for node in nodes:\n        node_name = node.split(\"/\")[-1]\n        if name == node_name:\n            return node\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.get_all_top_names","title":"<code>get_all_top_names()</code>","text":"<p>Get all top node and backdrop names in the scene.</p> <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>Set of top node names.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def get_all_top_names() -&gt; set:\n    \"\"\"Get all top node and backdrop names in the scene.\n\n    Returns:\n        set: Set of top node names.\n\n    \"\"\"\n    nodes = send({\"function\": \"node.subNodes\", \"args\": [\"Top\"]})[\"result\"]\n    backdrops = {\n        backdrop[\"title\"][\"text\"]\n        for backdrop in send(\n            {\"function\": \"Backdrop.backdrops\", \"args\": [\"Top\"]}\n        )[\"result\"]\n    }\n    return set(nodes) | backdrops\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.get_current_context_settings","title":"<code>get_current_context_settings()</code>","text":"<p>Get settings on current task from server.</p> <p>Returns:</p> Type Description <p>dict[str, Any]: Scene data.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def get_current_context_settings():\n    \"\"\"Get settings on current task from server.\n\n    Returns:\n        dict[str, Any]: Scene data.\n\n    \"\"\"\n\n    task_entity = get_current_task_entity()\n    task_attributes = task_entity[\"attrib\"]\n\n    fps = task_attributes.get(\"fps\")\n    frame_start = task_attributes.get(\"frameStart\")\n    frame_end = task_attributes.get(\"frameEnd\")\n    handle_start = task_attributes.get(\"handleStart\")\n    handle_end = task_attributes.get(\"handleEnd\")\n    resolution_width = task_attributes.get(\"resolutionWidth\")\n    resolution_height = task_attributes.get(\"resolutionHeight\")\n\n    scene_data = {\n        \"fps\": fps,\n        \"frameStart\": frame_start,\n        \"frameEnd\": frame_end,\n        \"handleStart\": handle_start,\n        \"handleEnd\": handle_end,\n        \"resolutionWidth\": resolution_width,\n        \"resolutionHeight\": resolution_height\n    }\n\n    return scene_data\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.get_palettes_paths","title":"<code>get_palettes_paths()</code>","text":"<p>Get all palettes paths in the scene.</p> <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>Set of palettes paths.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def get_palettes_paths() -&gt; set:\n    \"\"\"Get all palettes paths in the scene.\n\n    Returns:\n        set: Set of palettes paths.\n    \"\"\"\n    return {pal[\"_path\"] for pal in send(\n        {\"function\": \"AyonHarmony.getAllPalettesPaths\"}\n    )[\"result\"]}\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.imprint","title":"<code>imprint(node_id, data, remove=False)</code>","text":"<p>Write <code>data</code> to the <code>node</code> as json.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>Path to node or id of object.</p> required <code>data</code> <code>dict</code> <p>Dictionary of key/value pairs.</p> required <code>remove</code> <code>bool</code> <p>Removes the data from the scene.</p> <code>False</code> Example <p>from ayon_harmony.api import lib node = \"Top/Display\" data = {\"str\": \"something\", \"int\": 1, \"float\": 0.32, \"bool\": True} lib.imprint(layer, data)</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def imprint(node_id, data, remove=False):\n    \"\"\"Write `data` to the `node` as json.\n\n    Arguments:\n        node_id (str): Path to node or id of object.\n        data (dict): Dictionary of key/value pairs.\n        remove (bool): Removes the data from the scene.\n\n    Example:\n        &gt;&gt;&gt; from ayon_harmony.api import lib\n        &gt;&gt;&gt; node = \"Top/Display\"\n        &gt;&gt;&gt; data = {\"str\": \"something\", \"int\": 1, \"float\": 0.32, \"bool\": True}\n        &gt;&gt;&gt; lib.imprint(layer, data)\n    \"\"\"\n    scene_data = get_scene_data()\n\n    if remove and (node_id in scene_data):\n        scene_data.pop(node_id, None)\n    else:\n        if node_id in scene_data:\n            scene_data[node_id].update(data)\n        else:\n            scene_data[node_id] = data\n\n    set_scene_data(scene_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.inject_ayon_js","title":"<code>inject_ayon_js()</code>","text":"<p>Inject AyonHarmonyAPI.js into Harmony.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def inject_ayon_js():\n    \"\"\"Inject AyonHarmonyAPI.js into Harmony.\"\"\"\n    ayon_harmony_js = Path(__file__).parent.joinpath(\"js/AyonHarmonyAPI.js\")\n    script = ayon_harmony_js.read_text()\n    # send AyonHarmonyAPI.js to Harmony\n    harmony.send({\"script\": script})\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.launch","title":"<code>launch(application_path, *args)</code>","text":"<p>Set Harmony for launch.</p> <p>Launches Harmony and the server, then starts listening on the main thread for callbacks from the server. This is to have Qt applications run in the main thread.</p> <p>Parameters:</p> Name Type Description Default <code>application_path</code> <code>str</code> <p>Path to Harmony.</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def launch(application_path, *args):\n    \"\"\"Set Harmony for launch.\n\n    Launches Harmony and the server, then starts listening on the main thread\n    for callbacks from the server. This is to have Qt applications run in the\n    main thread.\n\n    Args:\n        application_path (str): Path to Harmony.\n\n    \"\"\"\n    from ayon_core.pipeline import install_host\n    from ayon_harmony.api import HarmonyHost\n\n    install_host(HarmonyHost())\n\n    ProcessContext.port = random.randrange(49152, 65535)\n    os.environ[\"AYON_HARMONY_PORT\"] = str(ProcessContext.port)\n    ProcessContext.application_path = application_path\n\n    # Launch Harmony.\n    setup_startup_scripts()\n    check_libs()\n\n    if len(args) &gt; 0 and (scene_path := Path(args[-1])).suffix == \".zip\":\n        launch_zip_file(scene_path)\n\n    open_workfile_app = env_value_to_bool(\"AYON_HARMONY_WORKFILES_ON_LAUNCH\")\n    workfile_already_open = ProcessContext.workfile_path\n    if open_workfile_app or not workfile_already_open:\n        ProcessContext.workfile_tool = host_tools.get_tool_by_name(\n            \"workfiles\"\n        )\n        host_tools.show_workfiles(save=True)\n        ProcessContext.execute_in_main_thread(check_workfiles_tool)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.ls","title":"<code>ls()</code>","text":"<p>Yields containers from Harmony scene.</p> <p>Clean up scene data from orphaned containers.</p> <p>Yields:</p> Name Type Description <code>dict</code> <p>container</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"Yields containers from Harmony scene.\n\n    Clean up scene data from orphaned containers.\n\n    Yields:\n        dict: container\n    \"\"\"\n    scene_data = harmony.get_scene_data() or dict()\n    containers_names = (\n        harmony.get_all_top_names() | harmony.get_palettes_paths()\n    )\n    cleaned_scene_data = False\n    for entity_name, entity_data in scene_data.copy().items():\n        if not is_container_data(entity_data):\n            continue\n\n        # Filter orphaned containers\n        if entity_name not in containers_names:\n            del scene_data[entity_name]\n            cleaned_scene_data = True\n            continue\n\n        if not entity_data.get(\"objectName\"):  # backward compatibility\n            entity_data[\"objectName\"] = entity_data[\"name\"]\n        yield entity_data\n\n    # Update scene data if cleaned\n    if cleaned_scene_data:\n        harmony.set_scene_data(scene_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.maintained_nodes_state","title":"<code>maintained_nodes_state(nodes)</code>","text":"<p>Maintain nodes states during context.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_nodes_state(nodes):\n    \"\"\"Maintain nodes states during context.\"\"\"\n    # Collect current state.\n    states = send(\n        {\n            \"function\": \"AyonHarmonyAPI.areEnabled\", \"args\": nodes\n        })[\"result\"]\n\n    # Disable all nodes.\n    send(\n        {\n            \"function\": \"AyonHarmonyAPI.disableNodes\", \"args\": nodes\n        })\n\n    try:\n        yield\n    finally:\n        send(\n            {\n                \"function\": \"AyonHarmonyAPI.setState\",\n                \"args\": [nodes, states]\n            })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.read","title":"<code>read(node_id)</code>","text":"<p>Read object metadata in to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>Path to node or id of object.</p> required <p>Returns:</p> Type Description <p>dict</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def read(node_id):\n    \"\"\"Read object metadata in to a dictionary.\n\n    Args:\n        node_id (str): Path to node or id of object.\n\n    Returns:\n        dict\n    \"\"\"\n    scene_data = get_scene_data()\n    if node_id in scene_data:\n        return scene_data[node_id]\n\n    return {}\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.remove","title":"<code>remove(node_id)</code>","text":"<p>Remove node data from scene metadata.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>full name (eg. 'Top/renderAnimation')</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def remove(node_id):\n    \"\"\"\n        Remove node data from scene metadata.\n\n        Args:\n            node_id (str): full name (eg. 'Top/renderAnimation')\n    \"\"\"\n    data = get_scene_data()\n    del data[node_id]\n    set_scene_data(data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.rename_node","title":"<code>rename_node(node_name, new_name)</code>","text":"<p>Rename node name</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def rename_node(node_name, new_name):\n    \"\"\" Rename node name \"\"\"\n    send(\n        {\n            \"function\": \"AyonHarmony.renameNode\",\n            \"args\": [node_name, new_name]\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.save_scene","title":"<code>save_scene(zip_and_move=True)</code>","text":"<p>Save the Harmony scene safely.</p> <p>The built-in (to AYON) background zip and moving of the Harmony scene folder, interferes with server/client communication by sending two requests at the same time. This only happens when sending \"scene.saveAll()\". This method prevents this double request and safely saves the scene.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def save_scene(zip_and_move=True):\n    \"\"\"Save the Harmony scene safely.\n\n    The built-in (to AYON) background zip and moving of the Harmony scene\n    folder, interferes with server/client communication by sending two\n    requests at the same time. This only happens when sending\n    \"scene.saveAll()\". This method prevents this double request and safely\n    saves the scene.\n\n    \"\"\"\n    # Need to turn off the background watcher else the communication with\n    # the server gets spammed with two requests at the same time.\n    scene_path = send(\n        {\"function\": \"AyonHarmonyAPI.saveScene\"})[\"result\"]\n\n    # # Manually update the remote file.\n    if zip_and_move:\n        on_file_changed(scene_path, threaded=False)\n\n    # Re-enable the background watcher.\n    send({\"function\": \"AyonHarmonyAPI.enableFileWather\"})\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.save_scene_as","title":"<code>save_scene_as(filepath)</code>","text":"<p>Save Harmony scene as <code>filepath</code>.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def save_scene_as(filepath):\n    \"\"\"Save Harmony scene as `filepath`.\"\"\"\n    scene_dir = os.path.dirname(filepath)\n    destination = os.path.join(\n        os.path.dirname(ProcessContext.workfile_path),\n        os.path.splitext(os.path.basename(filepath))[0] + \".zip\"\n    )\n\n    if os.path.exists(scene_dir):\n        try:\n            shutil.rmtree(scene_dir)\n        except Exception as e:\n            log.error(f\"Cannot remove {scene_dir}\")\n            raise Exception(f\"Cannot remove {scene_dir}\") from e\n\n    send(\n        {\"function\": \"scene.saveAs\", \"args\": [scene_dir]}\n    )[\"result\"]\n\n    zip_and_move(scene_dir, destination)\n\n    ProcessContext.workfile_path = destination\n\n    send(\n        {\"function\": \"AyonHarmonyAPI.addPathToWatcher\", \"args\": filepath}\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.select_nodes","title":"<code>select_nodes(nodes)</code>","text":"<p>Selects nodes in Node View</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def select_nodes(nodes):\n    \"\"\" Selects nodes in Node View \"\"\"\n    _ = send(\n        {\n            \"function\": \"AyonHarmonyAPI.selectNodes\",\n            \"args\": nodes\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.send","title":"<code>send(request)</code>","text":"<p>Public method for sending requests to Harmony.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def send(request):\n    \"\"\"Public method for sending requests to Harmony.\"\"\"\n    return ProcessContext.server.send(request)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.set_scene_data","title":"<code>set_scene_data(data)</code>","text":"<p>Write scene data to metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Data to write.</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def set_scene_data(data):\n    \"\"\"Write scene data to metadata.\n\n    Args:\n        data (dict): Data to write.\n\n    \"\"\"\n    # Write scene data.\n    send(\n        {\n            \"function\": \"AyonHarmonyAPI.setSceneData\",\n            \"args\": data\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.set_scene_settings","title":"<code>set_scene_settings(settings)</code>","text":"<p>Set correct scene settings in Harmony.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>dict</code> <p>Scene settings.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary of settings to set.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def set_scene_settings(settings):\n    \"\"\"Set correct scene settings in Harmony.\n\n    Args:\n        settings (dict): Scene settings.\n\n    Returns:\n        dict: Dictionary of settings to set.\n\n    \"\"\"\n    harmony.send(\n        {\"function\": \"AyonHarmony.setSceneSettings\", \"args\": settings})\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.signature","title":"<code>signature(postfix='func')</code>","text":"<p>Return random ECMA6 compatible function name.</p> <p>Parameters:</p> Name Type Description Default <code>postfix</code> <code>str</code> <p>name to append to random string.</p> <code>'func'</code> <p>Returns:     str: random function name.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def signature(postfix=\"func\") -&gt; str:\n    \"\"\"Return random ECMA6 compatible function name.\n\n    Args:\n        postfix (str): name to append to random string.\n    Returns:\n        str: random function name.\n\n    \"\"\"\n    return \"f{}_{}\".format(str(uuid4()).replace(\"-\", \"_\"), postfix)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/index.html#client.ayon_harmony.api.unzip_scene_file","title":"<code>unzip_scene_file(filepath)</code>","text":"<p>Unzip a Harmony scene file and return the path to the .xstage file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the zip file.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the .xstage file.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no .xstage file is found or if the working folder cannot be deleted.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def unzip_scene_file(filepath: str) -&gt; str:\n    \"\"\"Unzip a Harmony scene file and return the path to the .xstage file.\n\n    Args:\n        filepath (str): Path to the zip file.\n\n    Returns:\n        str: Path to the .xstage file.\n\n    Raises:\n        Exception: If no .xstage file is found or if the working\n            folder cannot be deleted.\n\n    \"\"\"\n    print(f\"Localizing {filepath}\")\n\n    local_scene_dir_path = get_local_harmony_path(filepath)\n    scene_name = os.path.basename(local_scene_dir_path)\n    if os.path.exists(os.path.join(local_scene_dir_path, scene_name)):\n        # unzipped with duplicated scene_name\n        local_scene_dir_path = os.path.join(local_scene_dir_path, scene_name)\n\n    scene_path = os.path.join(\n        local_scene_dir_path, f\"{scene_name}.xstage\"\n    )\n\n    unzip = True\n    if os.path.exists(scene_path):\n        unzip = False\n        # Check remote scene is newer than local.\n        if os.path.getmtime(scene_path) &lt; os.path.getmtime(filepath):\n            try:\n                shutil.rmtree(local_scene_dir_path)\n            except Exception as e:\n                log.error(e)\n                raise Exception(\"Cannot delete working folder\") from e\n            unzip = True\n\n    if unzip:\n        with _ZipFile(filepath, \"r\") as zip_ref:\n            zip_ref.extractall(local_scene_dir_path)\n\n        if os.path.exists(os.path.join(local_scene_dir_path, scene_name)):\n            # unzipped with duplicated scene_name\n            local_scene_dir_path = os.path.join(\n                local_scene_dir_path, scene_name\n            )\n\n    # find any xstage files is directory, prefer the one with the same name\n    # as directory (plus extension)\n    xstage_files = []\n    for root, _, files in os.walk(local_scene_dir_path):\n        for file in files:\n            if os.path.splitext(file)[1] == \".xstage\":\n                full_path = os.path.join(root, file)\n                relative_path = os.path.relpath(\n                    full_path, local_scene_dir_path\n                )\n                xstage_files.append(relative_path)\n\n    if not os.path.basename(\"temp.zip\"):\n        if not xstage_files:\n            raise Exception(\"No xstage file was found.\")\n\n    # prefer the one named as zip file\n    zip_based_name = \"{}.xstage\".format(\n        os.path.splitext(os.path.basename(filepath))[0])\n\n    xstage_files.reverse()  # prefer 0 found xstage\n    for relative_path_xstage in xstage_files:\n        scene_path = os.path.join(\n            local_scene_dir_path, relative_path_xstage\n        )\n        if zip_based_name in relative_path_xstage:\n            break\n\n    if not os.path.exists(scene_path):\n        raise Exception(\n            f\"Expected '{scene_path}' not found in '{local_scene_dir_path}'.\"\n        )\n\n    return scene_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/base_loaders.html","title":"base_loaders","text":"<p>Base classes for loaders.</p>"},{"location":"autoapi/client/ayon_harmony/api/base_loaders.html#client.ayon_harmony.api.base_loaders.BackdropBaseLoader","title":"<code>BackdropBaseLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load nodes into a backdrop.</p> Source code in <code>client/ayon_harmony/api/base_loaders.py</code> <pre><code>class BackdropBaseLoader(load.LoaderPlugin):\n    \"\"\"Load nodes into a backdrop.\"\"\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        \"\"\"Plugin entry point.\n\n        Args:\n            context (:class:`pyblish.api.Context`): Context.\n            name (str, optional): Container name.\n            namespace (str, optional): Container namespace.\n            data (dict, optional): Additional data passed into loader.\n\n        \"\"\"\n        self_name = self.__class__.__name__\n        filepath = self.filepath_from_context(context)\n\n        backdrop_name = harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Loaders.{self_name}.loadContainer\",\n                \"args\": [filepath, name],\n            }\n        )[\"result\"]\n\n        # We must validate the group_node\n        return harmony.containerise(\n            name,\n            namespace,\n            backdrop_name,\n            context,\n            self_name\n        )\n\n    def remove(self, container):\n        \"\"\"Remove container.\n\n        Args:\n            container (dict): container definition.\n        \"\"\"\n        container_backdrop = harmony.find_backdrop_by_name(container[\"name\"])\n        if container_backdrop:\n            harmony.send(\n                {\n                    \"function\": \"AyonHarmony.removeBackdrop\",\n                    \"args\": [container_backdrop, True]\n                }\n            )\n        harmony.remove(container[\"name\"])\n\n    def update(self, container, context):\n        \"\"\"Update loaded containers.\n\n        Args:\n            container (dict): Container data.\n            context (dict): Representation context data.\n\n        \"\"\"\n        return self.switch(container, context)\n\n    def switch(self, container, context):\n        \"\"\"Switch representation containers.\"\"\"\n        backdrop_name = container[\"name\"]\n        backdrop = harmony.find_backdrop_by_name(backdrop_name)\n\n        # Keep backdrop links\n        backdrop_links = harmony.send(\n            {\n                \"function\": \"AyonHarmony.getBackdropLinks\",\n                \"args\": backdrop,\n            }\n        )[\"result\"]\n\n        # Replace template container\n        self.remove(container)  # Before load to avoid node name incrementation\n        container = self.load(\n            context, container[\"name\"], container[\"namespace\"]\n        )\n\n        # Restore backdrop links\n        harmony.send(\n            {\n                \"function\": \"AyonHarmony.setNodesLinks\",\n                \"args\": backdrop_links\n            }\n        )\n\n        return container\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/base_loaders.html#client.ayon_harmony.api.base_loaders.BackdropBaseLoader.load","title":"<code>load(context, name=None, namespace=None, data=None)</code>","text":"<p>Plugin entry point.</p> <p>Parameters:</p> Name Type Description Default <code>context (</code> <p>class:<code>pyblish.api.Context</code>): Context.</p> required <code>name</code> <code>str</code> <p>Container name.</p> <code>None</code> <code>namespace</code> <code>str</code> <p>Container namespace.</p> <code>None</code> <code>data</code> <code>dict</code> <p>Additional data passed into loader.</p> <code>None</code> Source code in <code>client/ayon_harmony/api/base_loaders.py</code> <pre><code>def load(self, context, name=None, namespace=None, data=None):\n    \"\"\"Plugin entry point.\n\n    Args:\n        context (:class:`pyblish.api.Context`): Context.\n        name (str, optional): Container name.\n        namespace (str, optional): Container namespace.\n        data (dict, optional): Additional data passed into loader.\n\n    \"\"\"\n    self_name = self.__class__.__name__\n    filepath = self.filepath_from_context(context)\n\n    backdrop_name = harmony.send(\n        {\n            \"function\": f\"AyonHarmony.Loaders.{self_name}.loadContainer\",\n            \"args\": [filepath, name],\n        }\n    )[\"result\"]\n\n    # We must validate the group_node\n    return harmony.containerise(\n        name,\n        namespace,\n        backdrop_name,\n        context,\n        self_name\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/base_loaders.html#client.ayon_harmony.api.base_loaders.BackdropBaseLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove container.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>dict</code> <p>container definition.</p> required Source code in <code>client/ayon_harmony/api/base_loaders.py</code> <pre><code>def remove(self, container):\n    \"\"\"Remove container.\n\n    Args:\n        container (dict): container definition.\n    \"\"\"\n    container_backdrop = harmony.find_backdrop_by_name(container[\"name\"])\n    if container_backdrop:\n        harmony.send(\n            {\n                \"function\": \"AyonHarmony.removeBackdrop\",\n                \"args\": [container_backdrop, True]\n            }\n        )\n    harmony.remove(container[\"name\"])\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/base_loaders.html#client.ayon_harmony.api.base_loaders.BackdropBaseLoader.switch","title":"<code>switch(container, context)</code>","text":"<p>Switch representation containers.</p> Source code in <code>client/ayon_harmony/api/base_loaders.py</code> <pre><code>def switch(self, container, context):\n    \"\"\"Switch representation containers.\"\"\"\n    backdrop_name = container[\"name\"]\n    backdrop = harmony.find_backdrop_by_name(backdrop_name)\n\n    # Keep backdrop links\n    backdrop_links = harmony.send(\n        {\n            \"function\": \"AyonHarmony.getBackdropLinks\",\n            \"args\": backdrop,\n        }\n    )[\"result\"]\n\n    # Replace template container\n    self.remove(container)  # Before load to avoid node name incrementation\n    container = self.load(\n        context, container[\"name\"], container[\"namespace\"]\n    )\n\n    # Restore backdrop links\n    harmony.send(\n        {\n            \"function\": \"AyonHarmony.setNodesLinks\",\n            \"args\": backdrop_links\n        }\n    )\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/base_loaders.html#client.ayon_harmony.api.base_loaders.BackdropBaseLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update loaded containers.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>dict</code> <p>Container data.</p> required <code>context</code> <code>dict</code> <p>Representation context data.</p> required Source code in <code>client/ayon_harmony/api/base_loaders.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update loaded containers.\n\n    Args:\n        container (dict): Container data.\n        context (dict): Representation context data.\n\n    \"\"\"\n    return self.switch(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/launch_script.html","title":"launch_script","text":"<p>Script wraps launch mechanism of Harmony implementations.</p> <p>Arguments passed to the script are passed to launch function in host implementation. In all cases requires host app executable and may contain workfile or others.</p>"},{"location":"autoapi/client/ayon_harmony/api/launch_script.html#client.ayon_harmony.api.launch_script.on_invalid_args","title":"<code>on_invalid_args(script_not_found)</code>","text":"<p>Show to user message box saying that something went wrong.</p> <p>Tell user that arguments to launch implementation are invalid with arguments details.</p> <p>Parameters:</p> Name Type Description Default <code>script_not_found</code> <code>bool</code> <p>Use different message based on this value.</p> required Source code in <code>client/ayon_harmony/api/launch_script.py</code> <pre><code>def on_invalid_args(script_not_found):\n    \"\"\"Show to user message box saying that something went wrong.\n\n    Tell user that arguments to launch implementation are invalid with\n    arguments details.\n\n    Args:\n        script_not_found (bool): Use different message based on this value.\n    \"\"\"\n\n    title = \"Invalid arguments\"\n    joined_args = \", \".join(\"\\\"{}\\\"\".format(arg) for arg in sys.argv)\n    if script_not_found:\n        submsg = \"Where couldn't find script path:\\n\\\"{}\\\"\"\n    else:\n        submsg = \"Expected Host executable after script path:\\n\\\"{}\\\"\"\n\n    message = \"BUG: Got invalid arguments so can't launch Host application.\"\n    detail_message = \"Process was launched with arguments:\\n{}\\n\\n{}\".format(\n        joined_args,\n        submsg.format(CURRENT_FILE)\n    )\n\n    show_error_messagebox(title, message, detail_message)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/launch_script.html#client.ayon_harmony.api.launch_script.show_error_messagebox","title":"<code>show_error_messagebox(title, message, detail_message=None)</code>","text":"<p>Function will show message and process ends after closing it.</p> Source code in <code>client/ayon_harmony/api/launch_script.py</code> <pre><code>def show_error_messagebox(title, message, detail_message=None):\n    \"\"\"Function will show message and process ends after closing it.\"\"\"\n    from qtpy import QtWidgets, QtCore\n    from ayon_core import style\n\n    app = QtWidgets.QApplication([])\n    app.setStyleSheet(style.load_stylesheet())\n\n    msgbox = QtWidgets.QMessageBox()\n    msgbox.setWindowTitle(title)\n    msgbox.setText(message)\n\n    if detail_message:\n        msgbox.setDetailedText(detail_message)\n\n    msgbox.setWindowModality(QtCore.Qt.ApplicationModal)\n    msgbox.show()\n\n    sys.exit(app.exec_())\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html","title":"lib","text":"<p>Utility functions used for AYON - Harmony integration.</p>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.check_libs","title":"<code>check_libs()</code>","text":"<p>Check if <code>OpenHarmony</code>_ is available.</p> <p>AYON expects either path in <code>LIB_OPENHARMONY_PATH</code> or <code>openHarmony.js</code> present in <code>TOONBOOM_GLOBAL_SCRIPT_LOCATION</code>.</p> Throws <p>RuntimeError: If openHarmony is not found.</p> <p>.. _OpenHarmony:     https://github.com/cfourney/OpenHarmony</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def check_libs():\n    \"\"\"Check if `OpenHarmony`_ is available.\n\n    AYON expects either path in `LIB_OPENHARMONY_PATH` or `openHarmony.js`\n    present in `TOONBOOM_GLOBAL_SCRIPT_LOCATION`.\n\n    Throws:\n        RuntimeError: If openHarmony is not found.\n\n    .. _OpenHarmony:\n        https://github.com/cfourney/OpenHarmony\n\n    \"\"\"\n    if os.getenv(\"LIB_OPENHARMONY_PATH\"):\n        return\n\n    script_location = os.getenv(\"TOONBOOM_GLOBAL_SCRIPT_LOCATION\")\n    if not script_location:\n        log.error(\n            \"Cannot find OpenHarmony library.\"\n            \" Please set path to it in LIB_OPENHARMONY_PATH\"\n            \" environment variable.\"\n        )\n        raise RuntimeError(\"Missing OpenHarmony library.\")\n\n    script_path = os.path.join(script_location, \"openHarmony.js\")\n    if os.path.exists(script_path):\n        os.environ[\"LIB_OPENHARMONY_PATH\"] = script_location\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.delete_node","title":"<code>delete_node(node)</code>","text":"<p>Physically delete node from scene.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def delete_node(node):\n    \"\"\" Physically delete node from scene. \"\"\"\n    send(\n        {\n            \"function\": \"AyonHarmonyAPI.deleteNode\",\n            \"args\": node\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.find_backdrop_by_name","title":"<code>find_backdrop_by_name(name)</code>","text":"<p>Find backdrop by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the backdrop.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Optional[dict]</code> <p>Backdrop.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def find_backdrop_by_name(name: str) -&gt; Optional[dict]:\n    \"\"\"Find backdrop by its name.\n\n    Args:\n        name (str): Name of the backdrop.\n\n    Returns:\n        dict: Backdrop.\n    \"\"\"\n    backdrops = send(\n        {\"function\": \"Backdrop.backdrops\", \"args\": [\"Top\"]}\n    )[\"result\"]\n    for backdrop in backdrops:\n        if backdrop[\"title\"][\"text\"] == name:\n            return backdrop\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.find_node_by_name","title":"<code>find_node_by_name(name, node_type)</code>","text":"<p>Find node by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the Node. (without part before '/')</p> required <code>node_type</code> <code>str</code> <p>Type of the Node. 'READ' - for loaded data with Loaders (background) 'GROUP' - for loaded data with Loaders (templates) 'WRITE' - render nodes</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>FQ Node name.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def find_node_by_name(name, node_type):\n    \"\"\"Find node by its name.\n\n    Args:\n        name (str): Name of the Node. (without part before '/')\n        node_type (str): Type of the Node.\n            'READ' - for loaded data with Loaders (background)\n            'GROUP' - for loaded data with Loaders (templates)\n            'WRITE' - render nodes\n\n    Returns:\n        str: FQ Node name.\n\n    \"\"\"\n    nodes = send(\n        {\"function\": \"node.getNodes\", \"args\": [[node_type]]}\n    )[\"result\"]\n    for node in nodes:\n        node_name = node.split(\"/\")[-1]\n        if name == node_name:\n            return node\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.get_all_top_names","title":"<code>get_all_top_names()</code>","text":"<p>Get all top node and backdrop names in the scene.</p> <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>Set of top node names.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def get_all_top_names() -&gt; set:\n    \"\"\"Get all top node and backdrop names in the scene.\n\n    Returns:\n        set: Set of top node names.\n\n    \"\"\"\n    nodes = send({\"function\": \"node.subNodes\", \"args\": [\"Top\"]})[\"result\"]\n    backdrops = {\n        backdrop[\"title\"][\"text\"]\n        for backdrop in send(\n            {\"function\": \"Backdrop.backdrops\", \"args\": [\"Top\"]}\n        )[\"result\"]\n    }\n    return set(nodes) | backdrops\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.get_layers_info","title":"<code>get_layers_info()</code>","text":"<p>Returns list of dicts with info about timeline layers</p> <p>'position' goes from 0 at the top and increases to bottom on timeline</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def get_layers_info() -&gt; list[dict[str, str]]:\n    \"\"\"Returns list of dicts with info about timeline layers\n\n    'position' goes from 0 at the top and increases to bottom on timeline\n    \"\"\"\n    layers_info = send(\n        {\n            \"function\": \"AyonHarmony.getLayerInfos\",\n            \"args\": []\n        }\n    )[\"result\"]\n    layers_info = [layer for layer in layers_info if layer[\"enabled\"]]\n    return sorted(\n        layers_info,\n        key=lambda layer: layer[\"position\"],\n        reverse=True\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.get_local_harmony_path","title":"<code>get_local_harmony_path(filepath)</code>","text":"<p>From the provided path get the equivalent local Harmony path.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def get_local_harmony_path(filepath):\n    \"\"\"From the provided path get the equivalent local Harmony path.\"\"\"\n    basename = os.path.splitext(os.path.basename(filepath))[0]\n    harmony_path = os.path.join(os.path.expanduser(\"~\"), \".ayon\", \"harmony\")\n    return os.path.join(harmony_path, basename)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.get_palettes_paths","title":"<code>get_palettes_paths()</code>","text":"<p>Get all palettes paths in the scene.</p> <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>Set of palettes paths.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def get_palettes_paths() -&gt; set:\n    \"\"\"Get all palettes paths in the scene.\n\n    Returns:\n        set: Set of palettes paths.\n    \"\"\"\n    return {pal[\"_path\"] for pal in send(\n        {\"function\": \"AyonHarmony.getAllPalettesPaths\"}\n    )[\"result\"]}\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.imprint","title":"<code>imprint(node_id, data, remove=False)</code>","text":"<p>Write <code>data</code> to the <code>node</code> as json.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>Path to node or id of object.</p> required <code>data</code> <code>dict</code> <p>Dictionary of key/value pairs.</p> required <code>remove</code> <code>bool</code> <p>Removes the data from the scene.</p> <code>False</code> Example <p>from ayon_harmony.api import lib node = \"Top/Display\" data = {\"str\": \"something\", \"int\": 1, \"float\": 0.32, \"bool\": True} lib.imprint(layer, data)</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def imprint(node_id, data, remove=False):\n    \"\"\"Write `data` to the `node` as json.\n\n    Arguments:\n        node_id (str): Path to node or id of object.\n        data (dict): Dictionary of key/value pairs.\n        remove (bool): Removes the data from the scene.\n\n    Example:\n        &gt;&gt;&gt; from ayon_harmony.api import lib\n        &gt;&gt;&gt; node = \"Top/Display\"\n        &gt;&gt;&gt; data = {\"str\": \"something\", \"int\": 1, \"float\": 0.32, \"bool\": True}\n        &gt;&gt;&gt; lib.imprint(layer, data)\n    \"\"\"\n    scene_data = get_scene_data()\n\n    if remove and (node_id in scene_data):\n        scene_data.pop(node_id, None)\n    else:\n        if node_id in scene_data:\n            scene_data[node_id].update(data)\n        else:\n            scene_data[node_id] = data\n\n    set_scene_data(scene_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.launch","title":"<code>launch(application_path, *args)</code>","text":"<p>Set Harmony for launch.</p> <p>Launches Harmony and the server, then starts listening on the main thread for callbacks from the server. This is to have Qt applications run in the main thread.</p> <p>Parameters:</p> Name Type Description Default <code>application_path</code> <code>str</code> <p>Path to Harmony.</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def launch(application_path, *args):\n    \"\"\"Set Harmony for launch.\n\n    Launches Harmony and the server, then starts listening on the main thread\n    for callbacks from the server. This is to have Qt applications run in the\n    main thread.\n\n    Args:\n        application_path (str): Path to Harmony.\n\n    \"\"\"\n    from ayon_core.pipeline import install_host\n    from ayon_harmony.api import HarmonyHost\n\n    install_host(HarmonyHost())\n\n    ProcessContext.port = random.randrange(49152, 65535)\n    os.environ[\"AYON_HARMONY_PORT\"] = str(ProcessContext.port)\n    ProcessContext.application_path = application_path\n\n    # Launch Harmony.\n    setup_startup_scripts()\n    check_libs()\n\n    if len(args) &gt; 0 and (scene_path := Path(args[-1])).suffix == \".zip\":\n        launch_zip_file(scene_path)\n\n    open_workfile_app = env_value_to_bool(\"AYON_HARMONY_WORKFILES_ON_LAUNCH\")\n    workfile_already_open = ProcessContext.workfile_path\n    if open_workfile_app or not workfile_already_open:\n        ProcessContext.workfile_tool = host_tools.get_tool_by_name(\n            \"workfiles\"\n        )\n        host_tools.show_workfiles(save=True)\n        ProcessContext.execute_in_main_thread(check_workfiles_tool)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.launch_zip_file","title":"<code>launch_zip_file(filepath)</code>","text":"<p>Launch a Harmony application instance with the provided zip file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to file.</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def launch_zip_file(filepath):\n    \"\"\"Launch a Harmony application instance with the provided zip file.\n\n    Args:\n        filepath (str): Path to file.\n    \"\"\"\n    # Close existing scene.\n    if ProcessContext.pid:\n        os.kill(ProcessContext.pid, signal.SIGTERM)\n\n    # Stop server.\n    if ProcessContext.server:\n        ProcessContext.server.stop()\n\n    # Launch AYON server.\n    ProcessContext.server = Server(ProcessContext.port)\n    ProcessContext.server.start()\n    # thread = threading.Thread(target=self.server.start)\n    # thread.daemon = True\n    # thread.start()\n\n    # Save workfile path for later.\n    ProcessContext.workfile_path = filepath\n\n    # Unzip the scene file and get the .xstage path\n    try:\n        scene_path = unzip_scene_file(filepath)\n    except Exception as e:\n        print(f\"Error unzipping scene file: {e}\")\n        ProcessContext.server.stop()\n        return\n\n    print(\"Launching {}\".format(scene_path))\n    # QUESTION Could we use 'run_detached_process' from 'ayon_core.lib'?\n    kwargs = {}\n    if (\n        platform.system().lower() == \"windows\"\n        and not is_using_ayon_console()\n    ):\n        kwargs.update({\n            \"creationflags\": subprocess.CREATE_NO_WINDOW,\n            \"stdout\": subprocess.DEVNULL,\n            \"stderr\": subprocess.DEVNULL\n        })\n\n    process = subprocess.Popen(\n        [ProcessContext.application_path, scene_path],\n        **kwargs\n    )\n    ProcessContext.pid = process.pid\n    ProcessContext.process = process\n    ProcessContext.stdout_broker.host_connected()\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.maintained_nodes_state","title":"<code>maintained_nodes_state(nodes)</code>","text":"<p>Maintain nodes states during context.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_nodes_state(nodes):\n    \"\"\"Maintain nodes states during context.\"\"\"\n    # Collect current state.\n    states = send(\n        {\n            \"function\": \"AyonHarmonyAPI.areEnabled\", \"args\": nodes\n        })[\"result\"]\n\n    # Disable all nodes.\n    send(\n        {\n            \"function\": \"AyonHarmonyAPI.disableNodes\", \"args\": nodes\n        })\n\n    try:\n        yield\n    finally:\n        send(\n            {\n                \"function\": \"AyonHarmonyAPI.setState\",\n                \"args\": [nodes, states]\n            })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.on_file_changed","title":"<code>on_file_changed(path, threaded=True)</code>","text":"<p>Threaded zipping and move of the project directory.</p> <p>This method is called when the <code>.xstage</code> file is changed.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def on_file_changed(path, threaded=True):\n    \"\"\"Threaded zipping and move of the project directory.\n\n    This method is called when the `.xstage` file is changed.\n    \"\"\"\n    log.debug(\"File changed: \" + path)\n\n    if ProcessContext.workfile_path is None:\n        return\n\n    if threaded:\n        thread = threading.Thread(\n            target=zip_and_move,\n            args=(os.path.dirname(path), ProcessContext.workfile_path)\n        )\n        thread.start()\n    else:\n        zip_and_move(os.path.dirname(path), ProcessContext.workfile_path)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.read","title":"<code>read(node_id)</code>","text":"<p>Read object metadata in to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>Path to node or id of object.</p> required <p>Returns:</p> Type Description <p>dict</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def read(node_id):\n    \"\"\"Read object metadata in to a dictionary.\n\n    Args:\n        node_id (str): Path to node or id of object.\n\n    Returns:\n        dict\n    \"\"\"\n    scene_data = get_scene_data()\n    if node_id in scene_data:\n        return scene_data[node_id]\n\n    return {}\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.remove","title":"<code>remove(node_id)</code>","text":"<p>Remove node data from scene metadata.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>full name (eg. 'Top/renderAnimation')</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def remove(node_id):\n    \"\"\"\n        Remove node data from scene metadata.\n\n        Args:\n            node_id (str): full name (eg. 'Top/renderAnimation')\n    \"\"\"\n    data = get_scene_data()\n    del data[node_id]\n    set_scene_data(data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.rename_node","title":"<code>rename_node(node_name, new_name)</code>","text":"<p>Rename node name</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def rename_node(node_name, new_name):\n    \"\"\" Rename node name \"\"\"\n    send(\n        {\n            \"function\": \"AyonHarmony.renameNode\",\n            \"args\": [node_name, new_name]\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.save_scene","title":"<code>save_scene(zip_and_move=True)</code>","text":"<p>Save the Harmony scene safely.</p> <p>The built-in (to AYON) background zip and moving of the Harmony scene folder, interferes with server/client communication by sending two requests at the same time. This only happens when sending \"scene.saveAll()\". This method prevents this double request and safely saves the scene.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def save_scene(zip_and_move=True):\n    \"\"\"Save the Harmony scene safely.\n\n    The built-in (to AYON) background zip and moving of the Harmony scene\n    folder, interferes with server/client communication by sending two\n    requests at the same time. This only happens when sending\n    \"scene.saveAll()\". This method prevents this double request and safely\n    saves the scene.\n\n    \"\"\"\n    # Need to turn off the background watcher else the communication with\n    # the server gets spammed with two requests at the same time.\n    scene_path = send(\n        {\"function\": \"AyonHarmonyAPI.saveScene\"})[\"result\"]\n\n    # # Manually update the remote file.\n    if zip_and_move:\n        on_file_changed(scene_path, threaded=False)\n\n    # Re-enable the background watcher.\n    send({\"function\": \"AyonHarmonyAPI.enableFileWather\"})\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.save_scene_as","title":"<code>save_scene_as(filepath)</code>","text":"<p>Save Harmony scene as <code>filepath</code>.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def save_scene_as(filepath):\n    \"\"\"Save Harmony scene as `filepath`.\"\"\"\n    scene_dir = os.path.dirname(filepath)\n    destination = os.path.join(\n        os.path.dirname(ProcessContext.workfile_path),\n        os.path.splitext(os.path.basename(filepath))[0] + \".zip\"\n    )\n\n    if os.path.exists(scene_dir):\n        try:\n            shutil.rmtree(scene_dir)\n        except Exception as e:\n            log.error(f\"Cannot remove {scene_dir}\")\n            raise Exception(f\"Cannot remove {scene_dir}\") from e\n\n    send(\n        {\"function\": \"scene.saveAs\", \"args\": [scene_dir]}\n    )[\"result\"]\n\n    zip_and_move(scene_dir, destination)\n\n    ProcessContext.workfile_path = destination\n\n    send(\n        {\"function\": \"AyonHarmonyAPI.addPathToWatcher\", \"args\": filepath}\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.select_nodes","title":"<code>select_nodes(nodes)</code>","text":"<p>Selects nodes in Node View</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def select_nodes(nodes):\n    \"\"\" Selects nodes in Node View \"\"\"\n    _ = send(\n        {\n            \"function\": \"AyonHarmonyAPI.selectNodes\",\n            \"args\": nodes\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.send","title":"<code>send(request)</code>","text":"<p>Public method for sending requests to Harmony.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def send(request):\n    \"\"\"Public method for sending requests to Harmony.\"\"\"\n    return ProcessContext.server.send(request)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.set_scene_data","title":"<code>set_scene_data(data)</code>","text":"<p>Write scene data to metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Data to write.</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def set_scene_data(data):\n    \"\"\"Write scene data to metadata.\n\n    Args:\n        data (dict): Data to write.\n\n    \"\"\"\n    # Write scene data.\n    send(\n        {\n            \"function\": \"AyonHarmonyAPI.setSceneData\",\n            \"args\": data\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.setup_startup_scripts","title":"<code>setup_startup_scripts()</code>","text":"<p>Manages installation of ayon's TB_sceneOpened.js for Harmony launch.</p> <p>If a studio already has defined \"TOONBOOM_GLOBAL_SCRIPT_LOCATION\", copies the TB_sceneOpened.js to that location if the file is different. Otherwise, will set the env var to point to the ayon/harmony folder.</p> <p>Admins should be aware that this will overwrite TB_sceneOpened in the \"TOONBOOM_GLOBAL_SCRIPT_LOCATION\", and that if they want to have additional logic, they will need to one of the following:     * Create a Harmony package to manage startup logic     * Use TB_sceneOpenedUI.js instead to manage startup logic     * Add their startup logic to ayon/harmony/TB_sceneOpened.js</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def setup_startup_scripts():\n    \"\"\"Manages installation of ayon's TB_sceneOpened.js for Harmony launch.\n\n    If a studio already has defined \"TOONBOOM_GLOBAL_SCRIPT_LOCATION\", copies\n    the TB_sceneOpened.js to that location if the file is different.\n    Otherwise, will set the env var to point to the ayon/harmony folder.\n\n    Admins should be aware that this will overwrite TB_sceneOpened in the\n    \"TOONBOOM_GLOBAL_SCRIPT_LOCATION\", and that if they want to have additional\n    logic, they will need to one of the following:\n        * Create a Harmony package to manage startup logic\n        * Use TB_sceneOpenedUI.js instead to manage startup logic\n        * Add their startup logic to ayon/harmony/TB_sceneOpened.js\n    \"\"\"\n    ayon_host_dir = os.path.join(HARMONY_ADDON_ROOT, \"api\")\n    startup_js = \"TB_sceneOpened.js\"\n\n    env_location = os.getenv(\"TOONBOOM_GLOBAL_SCRIPT_LOCATION\")\n    if not env_location:\n        os.environ[\"TOONBOOM_GLOBAL_SCRIPT_LOCATION\"] = ayon_host_dir\n        return\n\n    ayon_harmony_startup = os.path.join(ayon_host_dir, startup_js)\n    env_harmony_startup = os.path.join(env_location, startup_js)\n\n    # Check if destination file exists or if files are the same\n    if (\n        os.path.exists(env_harmony_startup)\n        and filecmp.cmp(ayon_harmony_startup, env_harmony_startup)\n    ):\n        return\n\n    try:\n        shutil.copy(ayon_harmony_startup, env_harmony_startup)\n    except Exception:\n        log.warning(\n            f\"Failed to copy {ayon_harmony_startup} to {env_harmony_startup}!\"\n            \" Defaulting to AYON's TOONBOOM_GLOBAL_SCRIPT_LOCATION.\",\n            exc_info=True\n        )\n\n        os.environ[\"TOONBOOM_GLOBAL_SCRIPT_LOCATION\"] = ayon_host_dir\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.show","title":"<code>show(tool_name)</code>","text":"<p>Call show on \"module_name\".</p> <p>This allows to make a QApplication ahead of time and always \"exec_\" to prevent crashing.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Name of module to call \"show\" on.</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def show(tool_name):\n    \"\"\"Call show on \"module_name\".\n\n    This allows to make a QApplication ahead of time and always \"exec_\" to\n    prevent crashing.\n\n    Args:\n        module_name (str): Name of module to call \"show\" on.\n\n    \"\"\"\n    # Requests often get doubled up when showing tools, so we wait a second\n    #   for requests to be received properly.\n    time.sleep(1)\n\n    kwargs = {}\n    if tool_name == \"loader\":\n        kwargs[\"use_context\"] = True\n    elif tool_name == \"publisher\":\n        kwargs[\"tab\"] = \"publish\"\n    elif tool_name == \"creator\":\n        tool_name = \"publisher\"\n        kwargs[\"tab\"] = \"create\"\n\n    ProcessContext.execute_in_main_thread(\n        lambda: host_tools.show_tool_by_name(tool_name, **kwargs)\n    )\n\n    # Required return statement.\n    return \"nothing\"\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.signature","title":"<code>signature(postfix='func')</code>","text":"<p>Return random ECMA6 compatible function name.</p> <p>Parameters:</p> Name Type Description Default <code>postfix</code> <code>str</code> <p>name to append to random string.</p> <code>'func'</code> <p>Returns:     str: random function name.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def signature(postfix=\"func\") -&gt; str:\n    \"\"\"Return random ECMA6 compatible function name.\n\n    Args:\n        postfix (str): name to append to random string.\n    Returns:\n        str: random function name.\n\n    \"\"\"\n    return \"f{}_{}\".format(str(uuid4()).replace(\"-\", \"_\"), postfix)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.unzip_scene_file","title":"<code>unzip_scene_file(filepath)</code>","text":"<p>Unzip a Harmony scene file and return the path to the .xstage file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the zip file.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the .xstage file.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no .xstage file is found or if the working folder cannot be deleted.</p> Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def unzip_scene_file(filepath: str) -&gt; str:\n    \"\"\"Unzip a Harmony scene file and return the path to the .xstage file.\n\n    Args:\n        filepath (str): Path to the zip file.\n\n    Returns:\n        str: Path to the .xstage file.\n\n    Raises:\n        Exception: If no .xstage file is found or if the working\n            folder cannot be deleted.\n\n    \"\"\"\n    print(f\"Localizing {filepath}\")\n\n    local_scene_dir_path = get_local_harmony_path(filepath)\n    scene_name = os.path.basename(local_scene_dir_path)\n    if os.path.exists(os.path.join(local_scene_dir_path, scene_name)):\n        # unzipped with duplicated scene_name\n        local_scene_dir_path = os.path.join(local_scene_dir_path, scene_name)\n\n    scene_path = os.path.join(\n        local_scene_dir_path, f\"{scene_name}.xstage\"\n    )\n\n    unzip = True\n    if os.path.exists(scene_path):\n        unzip = False\n        # Check remote scene is newer than local.\n        if os.path.getmtime(scene_path) &lt; os.path.getmtime(filepath):\n            try:\n                shutil.rmtree(local_scene_dir_path)\n            except Exception as e:\n                log.error(e)\n                raise Exception(\"Cannot delete working folder\") from e\n            unzip = True\n\n    if unzip:\n        with _ZipFile(filepath, \"r\") as zip_ref:\n            zip_ref.extractall(local_scene_dir_path)\n\n        if os.path.exists(os.path.join(local_scene_dir_path, scene_name)):\n            # unzipped with duplicated scene_name\n            local_scene_dir_path = os.path.join(\n                local_scene_dir_path, scene_name\n            )\n\n    # find any xstage files is directory, prefer the one with the same name\n    # as directory (plus extension)\n    xstage_files = []\n    for root, _, files in os.walk(local_scene_dir_path):\n        for file in files:\n            if os.path.splitext(file)[1] == \".xstage\":\n                full_path = os.path.join(root, file)\n                relative_path = os.path.relpath(\n                    full_path, local_scene_dir_path\n                )\n                xstage_files.append(relative_path)\n\n    if not os.path.basename(\"temp.zip\"):\n        if not xstage_files:\n            raise Exception(\"No xstage file was found.\")\n\n    # prefer the one named as zip file\n    zip_based_name = \"{}.xstage\".format(\n        os.path.splitext(os.path.basename(filepath))[0])\n\n    xstage_files.reverse()  # prefer 0 found xstage\n    for relative_path_xstage in xstage_files:\n        scene_path = os.path.join(\n            local_scene_dir_path, relative_path_xstage\n        )\n        if zip_based_name in relative_path_xstage:\n            break\n\n    if not os.path.exists(scene_path):\n        raise Exception(\n            f\"Expected '{scene_path}' not found in '{local_scene_dir_path}'.\"\n        )\n\n    return scene_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/lib.html#client.ayon_harmony.api.lib.zip_and_move","title":"<code>zip_and_move(source, destination)</code>","text":"<p>Zip a directory and move to <code>destination</code>.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Directory to zip and move to destination.</p> required <code>destination</code> <code>str</code> <p>Destination file path to zip file.</p> required Source code in <code>client/ayon_harmony/api/lib.py</code> <pre><code>def zip_and_move(source, destination):\n    \"\"\"Zip a directory and move to `destination`.\n\n    Args:\n        source (str): Directory to zip and move to destination.\n        destination (str): Destination file path to zip file.\n\n    \"\"\"\n    os.chdir(os.path.dirname(source))\n    shutil.make_archive(os.path.basename(source), \"zip\", source)\n    with _ZipFile(os.path.basename(source) + \".zip\") as zr:\n        if zr.testzip() is not None:\n            raise Exception(\"File archive is corrupted.\")\n    shutil.move(os.path.basename(source) + \".zip\", destination)\n    log.debug(f\"Saved '{source}' to '{destination}'\")\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html","title":"pipeline","text":""},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.HarmonyHost","title":"<code>HarmonyHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>class HarmonyHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"harmony\"\n\n    _context_key = \"AYON_context\"\n\n    def install(self):\n        \"\"\"Install Pype as host config.\"\"\"\n        print(\"Installing AYON Harmony Host ...\")\n\n        pyblish.api.register_host(\"harmony\")\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n\n        register_event_callback(\"application.launched\", application_launch)\n\n    def uninstall(self):\n        pyblish.api.deregister_plugin_path(PUBLISH_PATH)\n        deregister_loader_plugin_path(LOAD_PATH)\n        deregister_creator_plugin_path(CREATE_PATH)\n\n    def open_workfile(self, filepath):\n        return open_file(filepath)\n\n    def save_workfile(self, filepath=None):\n        return save_file(filepath)\n\n    def work_root(self, session):\n        return work_root(session)\n\n    def get_current_workfile(self):\n        return current_file()\n\n    def workfile_has_unsaved_changes(self):\n        return has_unsaved_changes()\n\n    def get_workfile_extensions(self):\n        return file_extensions()\n\n    def get_containers(self):\n        return ls()\n\n    def get_context_data(self):\n        return get_scene_data().get(self._context_key, {})\n\n    def update_context_data(self, data, changes):\n        scene_data = get_scene_data()\n        context_data = scene_data.setdefault(self._context_key, {})\n        context_data.update(data)\n        set_scene_data(scene_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.HarmonyHost.install","title":"<code>install()</code>","text":"<p>Install Pype as host config.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Install Pype as host config.\"\"\"\n    print(\"Installing AYON Harmony Host ...\")\n\n    pyblish.api.register_host(\"harmony\")\n    pyblish.api.register_plugin_path(PUBLISH_PATH)\n    register_loader_plugin_path(LOAD_PATH)\n    register_creator_plugin_path(CREATE_PATH)\n\n    register_event_callback(\"application.launched\", application_launch)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.application_launch","title":"<code>application_launch(event)</code>","text":"<p>Event that is executed after Harmony is launched.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def application_launch(event):\n    \"\"\"Event that is executed after Harmony is launched.\"\"\"\n    # fills AYON_HARMONY_JS\n    ayon_harmony_path = Path(__file__).parent.parent / \"js\" / \"AyonHarmony.js\"\n    ayon_harmony_js = ayon_harmony_path.read_text()\n\n    # go through js/creators, loaders and publish folders and load all scripts\n    script = \"\"\n    for item in [\"creators\", \"loaders\", \"publish\"]:\n        dir_to_scan = Path(__file__).parent.parent / \"js\" / item\n        for child in dir_to_scan.iterdir():\n            script += child.read_text()\n\n    # send scripts to Harmony\n    harmony.send({\"script\": ayon_harmony_js})\n    harmony.send({\"script\": script})\n    inject_ayon_js()\n\n    # ensure_scene_settings()\n    check_inventory()\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.check_inventory","title":"<code>check_inventory()</code>","text":"<p>Check is scene contains outdated containers.</p> <p>If it does it will colorize outdated nodes and display warning message in Harmony.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def check_inventory():\n    \"\"\"Check is scene contains outdated containers.\n\n    If it does it will colorize outdated nodes and display warning message\n    in Harmony.\n    \"\"\"\n\n    outdated_containers = get_outdated_containers()\n    if not outdated_containers:\n        return\n\n    # Colour nodes.\n    outdated_nodes = []\n    for container in outdated_containers:\n        if container[\"loader\"] == \"ImageSequenceLoader\":\n            outdated_nodes.append(\n                harmony.find_node_by_name(container[\"name\"], \"READ\")\n            )\n    harmony.send({\"function\": \"AyonHarmony.setColor\", \"args\": outdated_nodes})\n\n    # Warn about outdated containers.\n    msg = \"There are outdated containers in the scene.\"\n    harmony.send({\"function\": \"AyonHarmony.message\", \"args\": msg})\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.containerise","title":"<code>containerise(name, namespace, node, context, loader=None, suffix=None, nodes=None)</code>","text":"<p>Imprint node with metadata.</p> <p>Containerisation enables a tracking of version, author and origin for loaded product representations.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly.</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container.</p> required <code>node</code> <code>str</code> <p>Node to containerise.</p> required <code>context</code> <code>dict</code> <p>Loaded representation full context information.</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>container</code> <code>str</code> <p>Path of container assembly.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def containerise(name,\n                 namespace,\n                 node,\n                 context,\n                 loader=None,\n                 suffix=None,\n                 nodes=None):\n    \"\"\"Imprint node with metadata.\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded product representations.\n\n    Arguments:\n        name (str): Name of resulting assembly.\n        namespace (str): Namespace under which to host container.\n        node (str): Node to containerise.\n        context (dict): Loaded representation full context information.\n        loader (str, optional): Name of loader used to produce this container.\n        suffix (str, optional): Suffix of container, defaults to `_CON`.\n\n    Returns:\n        container (str): Path of container assembly.\n    \"\"\"\n    if not nodes:\n        nodes = []\n\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace,\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"nodes\": nodes\n    }\n\n    harmony.imprint(node, data)\n\n    return node\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.ensure_scene_settings","title":"<code>ensure_scene_settings()</code>","text":"<p>Validate if Harmony scene has valid settings.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def ensure_scene_settings():\n    \"\"\"Validate if Harmony scene has valid settings.\"\"\"\n    settings = get_current_context_settings()\n\n    invalid_settings = []\n    valid_settings = {}\n    for key, value in settings.items():\n        if value is None:\n            invalid_settings.append(key)\n        else:\n            valid_settings[key] = value\n\n    # Warn about missing attributes.\n    if invalid_settings:\n        msg = \"Missing attributes:\"\n        for item in invalid_settings:\n            msg += f\"\\n{item}\"\n\n        harmony.send(\n            {\"function\": \"AyonHarmony.message\", \"args\": msg})\n\n    set_scene_settings(valid_settings)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.export_backdrop_as_template","title":"<code>export_backdrop_as_template(backdrop, filepath)</code>","text":"<p>Export Backdrop as Template (.tpl) file.</p> <p>Parameters:</p> Name Type Description Default <code>backdrop</code> <code>list</code> <p>Backdrop to export.</p> required <code>filepath</code> <code>str</code> <p>Path where to save Template.</p> required Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def export_backdrop_as_template(backdrop, filepath):\n    \"\"\"Export Backdrop as Template (.tpl) file.\n\n    Args:\n        backdrop (list): Backdrop to export.\n        filepath (str): Path where to save Template.\n    \"\"\"\n    harmony.send({\n        \"function\": \"AyonHarmony.exportBackdropAsTemplate\",\n        \"args\": [\n            backdrop,\n            os.path.basename(filepath),\n            os.path.dirname(filepath)\n        ]\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.get_current_context_settings","title":"<code>get_current_context_settings()</code>","text":"<p>Get settings on current task from server.</p> <p>Returns:</p> Type Description <p>dict[str, Any]: Scene data.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def get_current_context_settings():\n    \"\"\"Get settings on current task from server.\n\n    Returns:\n        dict[str, Any]: Scene data.\n\n    \"\"\"\n\n    task_entity = get_current_task_entity()\n    task_attributes = task_entity[\"attrib\"]\n\n    fps = task_attributes.get(\"fps\")\n    frame_start = task_attributes.get(\"frameStart\")\n    frame_end = task_attributes.get(\"frameEnd\")\n    handle_start = task_attributes.get(\"handleStart\")\n    handle_end = task_attributes.get(\"handleEnd\")\n    resolution_width = task_attributes.get(\"resolutionWidth\")\n    resolution_height = task_attributes.get(\"resolutionHeight\")\n\n    scene_data = {\n        \"fps\": fps,\n        \"frameStart\": frame_start,\n        \"frameEnd\": frame_end,\n        \"handleStart\": handle_start,\n        \"handleEnd\": handle_end,\n        \"resolutionWidth\": resolution_width,\n        \"resolutionHeight\": resolution_height\n    }\n\n    return scene_data\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.inject_ayon_js","title":"<code>inject_ayon_js()</code>","text":"<p>Inject AyonHarmonyAPI.js into Harmony.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def inject_ayon_js():\n    \"\"\"Inject AyonHarmonyAPI.js into Harmony.\"\"\"\n    ayon_harmony_js = Path(__file__).parent.joinpath(\"js/AyonHarmonyAPI.js\")\n    script = ayon_harmony_js.read_text()\n    # send AyonHarmonyAPI.js to Harmony\n    harmony.send({\"script\": script})\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.is_container_data","title":"<code>is_container_data(data)</code>","text":"<p>Return whether data is container data.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def is_container_data(data: dict) -&gt; bool:\n    \"\"\"Return whether data is container data.\"\"\"\n    return data and data.get(\"id\") in {AYON_CONTAINER_ID, AVALON_CONTAINER_ID}\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.ls","title":"<code>ls()</code>","text":"<p>Yields containers from Harmony scene.</p> <p>Clean up scene data from orphaned containers.</p> <p>Yields:</p> Name Type Description <code>dict</code> <p>container</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"Yields containers from Harmony scene.\n\n    Clean up scene data from orphaned containers.\n\n    Yields:\n        dict: container\n    \"\"\"\n    scene_data = harmony.get_scene_data() or dict()\n    containers_names = (\n        harmony.get_all_top_names() | harmony.get_palettes_paths()\n    )\n    cleaned_scene_data = False\n    for entity_name, entity_data in scene_data.copy().items():\n        if not is_container_data(entity_data):\n            continue\n\n        # Filter orphaned containers\n        if entity_name not in containers_names:\n            del scene_data[entity_name]\n            cleaned_scene_data = True\n            continue\n\n        if not entity_data.get(\"objectName\"):  # backward compatibility\n            entity_data[\"objectName\"] = entity_data[\"name\"]\n        yield entity_data\n\n    # Update scene data if cleaned\n    if cleaned_scene_data:\n        harmony.set_scene_data(scene_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/pipeline.html#client.ayon_harmony.api.pipeline.set_scene_settings","title":"<code>set_scene_settings(settings)</code>","text":"<p>Set correct scene settings in Harmony.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>dict</code> <p>Scene settings.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary of settings to set.</p> Source code in <code>client/ayon_harmony/api/pipeline.py</code> <pre><code>def set_scene_settings(settings):\n    \"\"\"Set correct scene settings in Harmony.\n\n    Args:\n        settings (dict): Scene settings.\n\n    Returns:\n        dict: Dictionary of settings to set.\n\n    \"\"\"\n    harmony.send(\n        {\"function\": \"AyonHarmony.setSceneSettings\", \"args\": settings})\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_harmony/api/plugin.html#client.ayon_harmony.api.plugin.HarmonyCreator","title":"<code>HarmonyCreator</code>","text":"<p>               Bases: <code>Creator</code>, <code>HarmonyCreatorBase</code></p> <p>Creator plugin to create instances in Harmony.</p> <p>By default a Composite node is created to support any number of nodes in an instance, but any node type is supported. If the selection is used, the selected nodes will be connected to the created node.</p> Source code in <code>client/ayon_harmony/api/plugin.py</code> <pre><code>class HarmonyCreator(Creator, HarmonyCreatorBase):\n    \"\"\"Creator plugin to create instances in Harmony.\n\n    By default a Composite node is created to support any number of nodes in\n    an instance, but any node type is supported.\n    If the selection is used, the selected nodes will be connected to the\n    created node.\n    \"\"\"\n\n    settings_category = \"harmony\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        # Create the node\n        node = self.product_impl(product_name, instance_data, pre_create_data)\n\n        instance = CreatedInstance(\n            self.product_type,\n            product_name,\n            instance_data,\n            self\n        )\n        instance.transient_data[\"node\"] = node\n        harmony.imprint(node, instance.data_to_store())\n\n        self._add_instance_to_context(instance)\n\n        return instance\n\n    def update_instances(self, update_list):\n        for created_inst, _changes in update_list:\n            node = created_inst.transient_data[\"node\"]\n            new_data = created_inst.data_to_store()\n\n            harmony.imprint(node, new_data)\n\n    def remove_instances(self, instances):\n        for instance in instances:\n            # There is only ever one workfile instance\n            harmony.delete_node(instance.transient_data[\"node\"])\n            self._remove_instance_from_context(instance)\n\n    def collect_instances(self):\n        cache = self.cache_instance_data(self.collection_shared_data)\n        for node_name in cache.get(\"harmony_cached_instance_data\").get(\n                self.identifier, []):\n            data = cache.get(\"harmony_cached_scene_data\")[node_name]\n\n            product_type = data.get(\"productType\")\n            if product_type is None:\n                product_type = data[\"family\"]\n                data[\"productType\"] = product_type\n            data[\"family\"] = product_type\n\n            instance = CreatedInstance.from_existing(instance_data=data,\n                                                     creator=self)\n            instance.transient_data[\"node\"] = node_name\n\n            # Active state is based of the node's active state\n            instance.data[\"active\"] = self.get_active_state(instance)\n\n            self._add_instance_to_context(instance)\n\n    def get_active_state(self, instance: CreatedInstance):\n        \"\"\"Get active state of the instance.\n\n        Args:\n            instance (CreatedInstance): Instance.\n\n        Returns:\n            bool: Active state of the instance.\n        \"\"\"\n        return instance.data.get(\"active\", True)\n\n    def setup_node(self, node):\n        \"\"\"Prepare node as container.\n\n        Args:\n            node (str): Path to node.\n        \"\"\"\n        harmony.send(\n            {\n                \"function\": \"AyonHarmonyAPI.setupNodeForCreator\",\n                \"args\": node\n            }\n        )\n\n    def product_impl(self, name, instance_data: dict, pre_create_data: dict):\n        raise NotImplementedError\n\n    def get_pre_create_attr_defs(self):\n        output = [\n            BoolDef(\n                \"use_selection\",\n                tooltip=\"Composition for publishable instance should be \"\n                        \"selected by default.\",\n                default=True,\n                label=\"Use selection\"\n            ),\n        ]\n        return output\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/plugin.html#client.ayon_harmony.api.plugin.HarmonyCreator.get_active_state","title":"<code>get_active_state(instance)</code>","text":"<p>Get active state of the instance.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>CreatedInstance</code> <p>Instance.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Active state of the instance.</p> Source code in <code>client/ayon_harmony/api/plugin.py</code> <pre><code>def get_active_state(self, instance: CreatedInstance):\n    \"\"\"Get active state of the instance.\n\n    Args:\n        instance (CreatedInstance): Instance.\n\n    Returns:\n        bool: Active state of the instance.\n    \"\"\"\n    return instance.data.get(\"active\", True)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/plugin.html#client.ayon_harmony.api.plugin.HarmonyCreator.setup_node","title":"<code>setup_node(node)</code>","text":"<p>Prepare node as container.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>Path to node.</p> required Source code in <code>client/ayon_harmony/api/plugin.py</code> <pre><code>def setup_node(self, node):\n    \"\"\"Prepare node as container.\n\n    Args:\n        node (str): Path to node.\n    \"\"\"\n    harmony.send(\n        {\n            \"function\": \"AyonHarmonyAPI.setupNodeForCreator\",\n            \"args\": node\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/plugin.html#client.ayon_harmony.api.plugin.HarmonyCreatorBase","title":"<code>HarmonyCreatorBase</code>","text":"Source code in <code>client/ayon_harmony/api/plugin.py</code> <pre><code>class HarmonyCreatorBase:\n    @staticmethod\n    def cache_instance_data(shared_data):\n        \"\"\"Cache instances for Creators to shared data.\n\n        Create `maya_cached_instance_data` key when needed in shared data and\n        fill it with all collected instances from the scene under its\n        respective creator identifiers.\n\n        If legacy instances are detected in the scene, create\n        `maya_cached_legacy_instances` there and fill it with\n        all legacy products under product type as a key.\n\n        Args:\n            Dict[str, Any]: Shared data.\n\n        \"\"\"\n        if shared_data.get(\"harmony_cached_instance_data\") is None:\n            cache = dict()\n            cache_legacy = dict()\n\n            # Collect scene data once instead of calling `read()` per node\n            scene_data = harmony.get_scene_data()\n            all_top_names = harmony.get_all_top_names()\n            cleaned_scene_data = False\n            for entity_name, entity_data in reversed(\n                scene_data.copy().items()\n            ):\n                # Filter orphaned instances\n                if entity_name not in all_top_names:\n                    del scene_data[entity_name]\n                    cleaned_scene_data = True\n                    continue\n\n                if entity_data.get(\"id\") not in {\n                    AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n                }:\n                    continue\n\n                creator_id = entity_data.get(\"creator_identifier\")\n                if creator_id is not None:\n                    # creator instance\n                    cache.setdefault(creator_id, []).append(entity_name)\n                else:\n                    # legacy instance\n                    product_type = entity_data.get(\n                        \"productType\") or entity_data.get(\"family\")\n\n                    if product_type is None:\n                        # must be a broken instance\n                        continue\n\n                    cache_legacy.setdefault(product_type, []).append(\n                        entity_name\n                    )\n\n            shared_data[\"harmony_cached_scene_data\"] = scene_data\n            shared_data[\"harmony_cached_instance_data\"] = cache\n            shared_data[\"harmony_cached_legacy_instances_names\"] = cache_legacy\n\n            # Update scene data if cleaned\n            if cleaned_scene_data:\n                harmony.set_scene_data(scene_data)\n\n        return shared_data\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/plugin.html#client.ayon_harmony.api.plugin.HarmonyCreatorBase.cache_instance_data","title":"<code>cache_instance_data(shared_data)</code>  <code>staticmethod</code>","text":"<p>Cache instances for Creators to shared data.</p> <p>Create <code>maya_cached_instance_data</code> key when needed in shared data and fill it with all collected instances from the scene under its respective creator identifiers.</p> <p>If legacy instances are detected in the scene, create <code>maya_cached_legacy_instances</code> there and fill it with all legacy products under product type as a key.</p> <p>Parameters:</p> Name Type Description Default <code>Dict[str, Any]</code> <p>Shared data.</p> required Source code in <code>client/ayon_harmony/api/plugin.py</code> <pre><code>@staticmethod\ndef cache_instance_data(shared_data):\n    \"\"\"Cache instances for Creators to shared data.\n\n    Create `maya_cached_instance_data` key when needed in shared data and\n    fill it with all collected instances from the scene under its\n    respective creator identifiers.\n\n    If legacy instances are detected in the scene, create\n    `maya_cached_legacy_instances` there and fill it with\n    all legacy products under product type as a key.\n\n    Args:\n        Dict[str, Any]: Shared data.\n\n    \"\"\"\n    if shared_data.get(\"harmony_cached_instance_data\") is None:\n        cache = dict()\n        cache_legacy = dict()\n\n        # Collect scene data once instead of calling `read()` per node\n        scene_data = harmony.get_scene_data()\n        all_top_names = harmony.get_all_top_names()\n        cleaned_scene_data = False\n        for entity_name, entity_data in reversed(\n            scene_data.copy().items()\n        ):\n            # Filter orphaned instances\n            if entity_name not in all_top_names:\n                del scene_data[entity_name]\n                cleaned_scene_data = True\n                continue\n\n            if entity_data.get(\"id\") not in {\n                AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n            }:\n                continue\n\n            creator_id = entity_data.get(\"creator_identifier\")\n            if creator_id is not None:\n                # creator instance\n                cache.setdefault(creator_id, []).append(entity_name)\n            else:\n                # legacy instance\n                product_type = entity_data.get(\n                    \"productType\") or entity_data.get(\"family\")\n\n                if product_type is None:\n                    # must be a broken instance\n                    continue\n\n                cache_legacy.setdefault(product_type, []).append(\n                    entity_name\n                )\n\n        shared_data[\"harmony_cached_scene_data\"] = scene_data\n        shared_data[\"harmony_cached_instance_data\"] = cache\n        shared_data[\"harmony_cached_legacy_instances_names\"] = cache_legacy\n\n        # Update scene data if cleaned\n        if cleaned_scene_data:\n            harmony.set_scene_data(scene_data)\n\n    return shared_data\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/plugin.html#client.ayon_harmony.api.plugin.HarmonyRenderCreator","title":"<code>HarmonyRenderCreator</code>","text":"<p>               Bases: <code>HarmonyCreator</code></p> <p>Creator plugin to create render instances in Harmony.</p> <p>It creates new Composite type node from which it is rendered.</p> Source code in <code>client/ayon_harmony/api/plugin.py</code> <pre><code>class HarmonyRenderCreator(HarmonyCreator):\n    \"\"\"Creator plugin to create render instances in Harmony.\n\n    It creates new Composite type node from which it is rendered.\n    \"\"\"\n    node_type = \"COMPOSITE\"\n    # should node be auto connected to main Composite node for Harmony Advanced\n    auto_connect = False\n    # regex to find main Composite node\n    composition_node_pattern = \"\"\n\n    rendering_targets = {\n        \"local\": \"Local machine rendering\",\n        \"farm\": \"Farm rendering\",\n    }\n\n    def product_impl(self, name, instance_data: dict, pre_create_data: dict):\n        existing_node_names = harmony.send(\n            {\n                \"function\": \"AyonHarmonyAPI.getNodesNamesByType\",\n                \"args\": self.node_type\n            })[\"result\"]\n\n        # Don't allow instances with the same name.\n        name_lower = name.lower()\n        for existing_name in existing_node_names:\n            if name_lower == existing_name.lower():\n                msg = f\"Instance with name \\\"{name}\\\" already exists.\"\n                raise CreatorError(msg)\n\n        use_selection = pre_create_data.get(\"use_selection\", False)\n        if self.auto_connect:\n            existing_comp_names = harmony.send(\n                {\n                    \"function\": \"AyonHarmonyAPI.getNodesNamesByType\",\n                    \"args\": \"COMPOSITE\"\n                })[\"result\"]\n            name_pattern = self.composition_node_pattern\n            if not name_pattern:\n                raise CreatorError(\"Composition name regex pattern \"\n                                   \"must be filled\")\n            compiled_pattern = re.compile(name_pattern)\n            matching_nodes = [name for name in existing_comp_names\n                              if compiled_pattern.match(name)]\n            if len(matching_nodes) &gt; 1:\n                self.log.warning(\"Multiple composition node found, \"\n                                 \"picked first\")\n            elif len(matching_nodes) &lt;= 0:\n                raise CreatorError(\"No matching composition \"\n                                   \"node found\")\n            node_name = f\"/Top/{matching_nodes[0]}\"\n\n            use_selection = True\n            harmony.send(\n                {\n                    \"function\": \"AyonHarmonyAPI.selectNodes\",\n                    \"args\": [node_name]\n                }\n            )\n\n        node = harmony.send(\n            {\n                \"function\": \"AyonHarmonyAPI.createNodeContainer\",\n                \"args\": [name, self.node_type, use_selection]\n            }\n        )[\"result\"]\n        self.setup_node(node)\n\n        instance_data[\"creator_attributes\"] = {\n            \"render_target\": pre_create_data[\"render_target\"],\n            \"mark_for_review\": pre_create_data[\"mark_for_review\"]\n        }\n\n        return node\n\n    def get_pre_create_attr_defs(self):\n        output = super().get_pre_create_attr_defs()\n        output.extend([\n            EnumDef(\n                \"render_target\",\n                items=self.rendering_targets,\n                label=\"Render target\"\n            ),\n            BoolDef(\n                \"mark_for_review\",\n                label=\"Review\",\n                default=True,\n            )\n        ])\n        return output\n\n    def get_instance_attr_defs(self):\n        return [\n            EnumDef(\n                \"render_target\",\n                items=self.rendering_targets,\n                label=\"Render target\"\n            ),\n            BoolDef(\n                \"mark_for_review\",\n                label=\"Review\",\n                default=True,\n            )\n        ]\n\n    def update_instances(self, update_list):\n        super().update_instances(update_list)\n\n        # Use the node's active state to store the instance's active state\n        for created_inst, _changes in update_list:\n            node = created_inst.transient_data[\"node\"]\n            new_data = created_inst.data_to_store()\n\n            active = new_data.get(\"active\", True)\n            harmony.send(\n                {\"function\": \"AyonHarmonyAPI.setState\",\n                 \"args\": [[node], [active]]}\n            )\n\n    def get_active_state(self, instance: CreatedInstance):\n        if node_name := instance.transient_data.get(\"node\"):\n            return harmony.send(\n                {\"function\": \"AyonHarmonyAPI.isEnabled\", \"args\": [node_name]}\n            )[\"result\"]\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/server.html","title":"server","text":"<p>Server-side implementation of Toon Boon Harmony communication.</p>"},{"location":"autoapi/client/ayon_harmony/api/server.html#client.ayon_harmony.api.server.Server","title":"<code>Server</code>","text":"<p>               Bases: <code>Thread</code></p> <p>Class for communication with Toon Boon Harmony.</p> <p>Attributes:</p> Name Type Description <code>connection</code> <code>Socket</code> <p>connection holding object.</p> <code>received</code> <code>str</code> <p>received data buffer.any(iterable)</p> <code>port</code> <code>int</code> <p>port number.</p> <code>message_id</code> <code>int</code> <p>index of last message going out.</p> <code>queue</code> <code>dict</code> <p>dictionary holding queue of incoming messages.</p> Source code in <code>client/ayon_harmony/api/server.py</code> <pre><code>class Server(threading.Thread):\n    \"\"\"Class for communication with Toon Boon Harmony.\n\n    Attributes:\n        connection (Socket): connection holding object.\n        received (str): received data buffer.any(iterable)\n        port (int): port number.\n        message_id (int): index of last message going out.\n        queue (dict): dictionary holding queue of incoming messages.\n\n    \"\"\"\n\n    def __init__(self, port):\n        \"\"\"Constructor.\"\"\"\n        super(Server, self).__init__()\n        self.daemon = True\n        self.connection = None\n        self.received = \"\"\n        self.port = port\n        self.message_id = 1\n\n        # Setup logging.\n        self.log = logging.getLogger(__name__)\n        self.log.setLevel(logging.DEBUG)\n\n        # Create a TCP/IP socket\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n        # Bind the socket to the port\n        server_address = (\"127.0.0.1\", port)\n        self.log.debug(\n            f\"[{self.timestamp()}] Starting up on \"\n            f\"{server_address[0]}:{server_address[1]}\")\n        self.socket.bind(server_address)\n\n        # Listen for incoming connections\n        self.socket.listen(1)\n        self.queue = {}\n\n    def process_request(self, request):\n        \"\"\"Process incoming request.\n\n        Args:\n            request (dict): {\n                \"module\": (str),  # Module of method.\n                \"method\" (str),  # Name of method in module.\n                \"args\" (list),  # Arguments to pass to method.\n                \"kwargs\" (dict),  # Keyword arguments to pass to method.\n                \"reply\" (bool),  # Optional wait for method completion.\n            }\n        \"\"\"\n        pretty = self._pretty(request)\n        self.log.debug(\n            f\"[{self.timestamp()}] Processing request:\\n{pretty}\")\n\n        # TODO javascript should not define which module is imported and\n        #   which function is called. It should send predefined requests.\n        try:\n            module = importlib.import_module(request[\"module\"])\n            method = getattr(module, request[\"method\"])\n\n            args = request.get(\"args\", [])\n            kwargs = request.get(\"kwargs\", {})\n            partial_method = functools.partial(method, *args, **kwargs)\n\n            lib.ProcessContext.execute_in_main_thread(partial_method)\n        except Exception:\n            self.log.error(traceback.format_exc())\n\n    def receive(self):\n        \"\"\"Receives data from `self.connection`.\n\n        When the data is a json serializable string, a reply is sent then\n        processing of the request.\n        \"\"\"\n        current_time = time.time()\n        while True:\n            # Receive the data in small chunks and retransmit it\n            request = None\n            try:\n                header = self.connection.recv(10)\n            except OSError:\n                # could happen on MacOS\n                self.log.info(\"\")\n                break\n\n            if len(header) == 0:\n                # null data received, socket is closing.\n                self.log.info(f\"[{self.timestamp()}] Connection closing.\")\n                break\n\n            if header[0:2] != b\"AH\":\n                self.log.error(\"INVALID HEADER\")\n            content_length_str = header[2:].decode()\n\n            length = int(content_length_str, 16)\n            data = self.connection.recv(length)\n            while (len(data) &lt; length):\n                # we didn't received everything in first try, lets wait for\n                # all data.\n                self.log.info(\"loop\")\n                time.sleep(0.1)\n                if self.connection is None:\n                    self.log.error(f\"[{self.timestamp()}] \"\n                                   \"Connection is broken\")\n                    break\n                if time.time() &gt; current_time + 30:\n                    self.log.error(f\"[{self.timestamp()}] Connection timeout.\")\n                    break\n\n                data += self.connection.recv(length - len(data))\n            self.log.debug(\"data:: {} {}\".format(data, type(data)))\n            self.received += data.decode(\"utf-8\")\n            pretty = self._pretty(self.received)\n            self.log.debug(\n                f\"[{self.timestamp()}] Received:\\n{pretty}\")\n\n            try:\n                request = json.loads(self.received)\n            except json.decoder.JSONDecodeError as e:\n                self.log.error(f\"[{self.timestamp()}] \"\n                               f\"Invalid message received.\\n{e}\",\n                               exc_info=True)\n\n            self.received = \"\"\n            if request is None:\n                continue\n\n            if \"message_id\" in request.keys():\n                message_id = request[\"message_id\"]\n                self.message_id = message_id + 1\n                self.log.debug(f\"--- storing request as {message_id}\")\n                self.queue[message_id] = request\n            if \"reply\" not in request.keys():\n                request[\"reply\"] = True\n                self.send(request)\n                self.process_request(request)\n\n                if \"message_id\" in request.keys():\n                    try:\n                        self.log.debug(f\"[{self.timestamp()}] \"\n                                       f\"Removing from the queue {message_id}\")\n                        del self.queue[message_id]\n                    except IndexError:\n                        self.log.debug(f\"[{self.timestamp()}] \"\n                                       f\"{message_id} is no longer in queue\")\n            else:\n                self.log.debug(f\"[{self.timestamp()}] \"\n                               \"received data was just a reply.\")\n\n    def run(self):\n        \"\"\"Entry method for server.\n\n        Waits for a connection on `self.port` before going into listen mode.\n        \"\"\"\n        # Wait for a connection\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n        self.log.debug(f\"[{timestamp}] Waiting for a connection.\")\n        self.connection, client_address = self.socket.accept()\n\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n        self.log.debug(f\"[{timestamp}] Connection from: {client_address}\")\n\n        self.receive()\n\n    def stop(self):\n        \"\"\"Shutdown socket server gracefully.\"\"\"\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n        self.log.debug(f\"[{timestamp}] Shutting down server.\")\n        if self.connection is None:\n            self.log.debug(\"Connect to shutdown.\")\n            socket.socket(\n                socket.AF_INET, socket.SOCK_STREAM\n            ).connect((\"localhost\", self.port))\n\n        self.connection.close()\n        self.connection = None\n\n        self.socket.close()\n\n    def _send(self, message):\n        \"\"\"Send a message to Harmony.\n\n        Args:\n            message (str): Data to send to Harmony.\n        \"\"\"\n        # Wait for a connection.\n        while not self.connection:\n            pass\n\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n        encoded = message.encode(\"utf-8\")\n        coded_message = b\"AH\" + struct.pack('&gt;I', len(encoded)) + encoded\n        pretty = self._pretty(coded_message)\n        self.log.debug(\n            f\"[{timestamp}] Sending [{self.message_id}]:\\n{pretty}\")\n        self.log.debug(f\"--- Message length: {len(encoded)}\")\n        self.connection.sendall(coded_message)\n        self.message_id += 1\n\n    def send(self, request):\n        \"\"\"Send a request in dictionary to Harmony.\n\n        Waits for a reply from Harmony.\n\n        Args:\n            request (dict): Data to send to Harmony.\n        \"\"\"\n        request[\"message_id\"] = self.message_id\n        self._send(json.dumps(request))\n        if request.get(\"reply\"):\n            timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n            self.log.debug(\n                f\"[{timestamp}] sent reply, not waiting for anything.\")\n            return None\n        result = None\n        current_time = time.time()\n        try_index = 1\n        while True:\n            time.sleep(0.1)\n            if time.time() &gt; current_time + 30:\n                timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n                self.log.error((f\"[{timestamp}][{self.message_id}] \"\n                                \"No reply from Harmony in 30s. \"\n                                f\"Retrying {try_index}\"))\n                try_index += 1\n                current_time = time.time()\n            if try_index &gt; 30:\n                break\n            try:\n                result = self.queue[request[\"message_id\"]]\n                timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n                self.log.debug((f\"[{timestamp}] Got request \"\n                                f\"id {self.message_id}, \"\n                                \"removing from queue\"))\n                del self.queue[request[\"message_id\"]]\n                break\n            except KeyError:\n                # response not in received queue yey\n                pass\n            try:\n                result = json.loads(self.received)\n                break\n            except json.decoder.JSONDecodeError:\n                pass\n\n        self.received = \"\"\n\n        return result\n\n    def _pretty(self, message) -&gt; str:\n        # result = pformat(message, indent=2)\n        # return result.replace(\"\\\\n\", \"\\n\")\n        return \"{}{}\".format(4 * \" \", message)\n\n    def timestamp(self):\n        \"\"\"Return current timestamp as a string.\n\n        Returns:\n            str: current timestamp.\n\n        \"\"\"\n        return datetime.now().strftime(\"%H:%M:%S.%f\")\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/server.html#client.ayon_harmony.api.server.Server.__init__","title":"<code>__init__(port)</code>","text":"<p>Constructor.</p> Source code in <code>client/ayon_harmony/api/server.py</code> <pre><code>def __init__(self, port):\n    \"\"\"Constructor.\"\"\"\n    super(Server, self).__init__()\n    self.daemon = True\n    self.connection = None\n    self.received = \"\"\n    self.port = port\n    self.message_id = 1\n\n    # Setup logging.\n    self.log = logging.getLogger(__name__)\n    self.log.setLevel(logging.DEBUG)\n\n    # Create a TCP/IP socket\n    self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n    # Bind the socket to the port\n    server_address = (\"127.0.0.1\", port)\n    self.log.debug(\n        f\"[{self.timestamp()}] Starting up on \"\n        f\"{server_address[0]}:{server_address[1]}\")\n    self.socket.bind(server_address)\n\n    # Listen for incoming connections\n    self.socket.listen(1)\n    self.queue = {}\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/server.html#client.ayon_harmony.api.server.Server.process_request","title":"<code>process_request(request)</code>","text":"<p>Process incoming request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>dict</code> <p>{ \"module\": (str),  # Module of method. \"method\" (str),  # Name of method in module. \"args\" (list),  # Arguments to pass to method. \"kwargs\" (dict),  # Keyword arguments to pass to method. \"reply\" (bool),  # Optional wait for method completion.</p> required Source code in <code>client/ayon_harmony/api/server.py</code> <pre><code>def process_request(self, request):\n    \"\"\"Process incoming request.\n\n    Args:\n        request (dict): {\n            \"module\": (str),  # Module of method.\n            \"method\" (str),  # Name of method in module.\n            \"args\" (list),  # Arguments to pass to method.\n            \"kwargs\" (dict),  # Keyword arguments to pass to method.\n            \"reply\" (bool),  # Optional wait for method completion.\n        }\n    \"\"\"\n    pretty = self._pretty(request)\n    self.log.debug(\n        f\"[{self.timestamp()}] Processing request:\\n{pretty}\")\n\n    # TODO javascript should not define which module is imported and\n    #   which function is called. It should send predefined requests.\n    try:\n        module = importlib.import_module(request[\"module\"])\n        method = getattr(module, request[\"method\"])\n\n        args = request.get(\"args\", [])\n        kwargs = request.get(\"kwargs\", {})\n        partial_method = functools.partial(method, *args, **kwargs)\n\n        lib.ProcessContext.execute_in_main_thread(partial_method)\n    except Exception:\n        self.log.error(traceback.format_exc())\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/server.html#client.ayon_harmony.api.server.Server.receive","title":"<code>receive()</code>","text":"<p>Receives data from <code>self.connection</code>.</p> <p>When the data is a json serializable string, a reply is sent then processing of the request.</p> Source code in <code>client/ayon_harmony/api/server.py</code> <pre><code>def receive(self):\n    \"\"\"Receives data from `self.connection`.\n\n    When the data is a json serializable string, a reply is sent then\n    processing of the request.\n    \"\"\"\n    current_time = time.time()\n    while True:\n        # Receive the data in small chunks and retransmit it\n        request = None\n        try:\n            header = self.connection.recv(10)\n        except OSError:\n            # could happen on MacOS\n            self.log.info(\"\")\n            break\n\n        if len(header) == 0:\n            # null data received, socket is closing.\n            self.log.info(f\"[{self.timestamp()}] Connection closing.\")\n            break\n\n        if header[0:2] != b\"AH\":\n            self.log.error(\"INVALID HEADER\")\n        content_length_str = header[2:].decode()\n\n        length = int(content_length_str, 16)\n        data = self.connection.recv(length)\n        while (len(data) &lt; length):\n            # we didn't received everything in first try, lets wait for\n            # all data.\n            self.log.info(\"loop\")\n            time.sleep(0.1)\n            if self.connection is None:\n                self.log.error(f\"[{self.timestamp()}] \"\n                               \"Connection is broken\")\n                break\n            if time.time() &gt; current_time + 30:\n                self.log.error(f\"[{self.timestamp()}] Connection timeout.\")\n                break\n\n            data += self.connection.recv(length - len(data))\n        self.log.debug(\"data:: {} {}\".format(data, type(data)))\n        self.received += data.decode(\"utf-8\")\n        pretty = self._pretty(self.received)\n        self.log.debug(\n            f\"[{self.timestamp()}] Received:\\n{pretty}\")\n\n        try:\n            request = json.loads(self.received)\n        except json.decoder.JSONDecodeError as e:\n            self.log.error(f\"[{self.timestamp()}] \"\n                           f\"Invalid message received.\\n{e}\",\n                           exc_info=True)\n\n        self.received = \"\"\n        if request is None:\n            continue\n\n        if \"message_id\" in request.keys():\n            message_id = request[\"message_id\"]\n            self.message_id = message_id + 1\n            self.log.debug(f\"--- storing request as {message_id}\")\n            self.queue[message_id] = request\n        if \"reply\" not in request.keys():\n            request[\"reply\"] = True\n            self.send(request)\n            self.process_request(request)\n\n            if \"message_id\" in request.keys():\n                try:\n                    self.log.debug(f\"[{self.timestamp()}] \"\n                                   f\"Removing from the queue {message_id}\")\n                    del self.queue[message_id]\n                except IndexError:\n                    self.log.debug(f\"[{self.timestamp()}] \"\n                                   f\"{message_id} is no longer in queue\")\n        else:\n            self.log.debug(f\"[{self.timestamp()}] \"\n                           \"received data was just a reply.\")\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/server.html#client.ayon_harmony.api.server.Server.run","title":"<code>run()</code>","text":"<p>Entry method for server.</p> <p>Waits for a connection on <code>self.port</code> before going into listen mode.</p> Source code in <code>client/ayon_harmony/api/server.py</code> <pre><code>def run(self):\n    \"\"\"Entry method for server.\n\n    Waits for a connection on `self.port` before going into listen mode.\n    \"\"\"\n    # Wait for a connection\n    timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n    self.log.debug(f\"[{timestamp}] Waiting for a connection.\")\n    self.connection, client_address = self.socket.accept()\n\n    timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n    self.log.debug(f\"[{timestamp}] Connection from: {client_address}\")\n\n    self.receive()\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/server.html#client.ayon_harmony.api.server.Server.send","title":"<code>send(request)</code>","text":"<p>Send a request in dictionary to Harmony.</p> <p>Waits for a reply from Harmony.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>dict</code> <p>Data to send to Harmony.</p> required Source code in <code>client/ayon_harmony/api/server.py</code> <pre><code>def send(self, request):\n    \"\"\"Send a request in dictionary to Harmony.\n\n    Waits for a reply from Harmony.\n\n    Args:\n        request (dict): Data to send to Harmony.\n    \"\"\"\n    request[\"message_id\"] = self.message_id\n    self._send(json.dumps(request))\n    if request.get(\"reply\"):\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n        self.log.debug(\n            f\"[{timestamp}] sent reply, not waiting for anything.\")\n        return None\n    result = None\n    current_time = time.time()\n    try_index = 1\n    while True:\n        time.sleep(0.1)\n        if time.time() &gt; current_time + 30:\n            timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n            self.log.error((f\"[{timestamp}][{self.message_id}] \"\n                            \"No reply from Harmony in 30s. \"\n                            f\"Retrying {try_index}\"))\n            try_index += 1\n            current_time = time.time()\n        if try_index &gt; 30:\n            break\n        try:\n            result = self.queue[request[\"message_id\"]]\n            timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n            self.log.debug((f\"[{timestamp}] Got request \"\n                            f\"id {self.message_id}, \"\n                            \"removing from queue\"))\n            del self.queue[request[\"message_id\"]]\n            break\n        except KeyError:\n            # response not in received queue yey\n            pass\n        try:\n            result = json.loads(self.received)\n            break\n        except json.decoder.JSONDecodeError:\n            pass\n\n    self.received = \"\"\n\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/server.html#client.ayon_harmony.api.server.Server.stop","title":"<code>stop()</code>","text":"<p>Shutdown socket server gracefully.</p> Source code in <code>client/ayon_harmony/api/server.py</code> <pre><code>def stop(self):\n    \"\"\"Shutdown socket server gracefully.\"\"\"\n    timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")\n    self.log.debug(f\"[{timestamp}] Shutting down server.\")\n    if self.connection is None:\n        self.log.debug(\"Connect to shutdown.\")\n        socket.socket(\n            socket.AF_INET, socket.SOCK_STREAM\n        ).connect((\"localhost\", self.port))\n\n    self.connection.close()\n    self.connection = None\n\n    self.socket.close()\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/server.html#client.ayon_harmony.api.server.Server.timestamp","title":"<code>timestamp()</code>","text":"<p>Return current timestamp as a string.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>current timestamp.</p> Source code in <code>client/ayon_harmony/api/server.py</code> <pre><code>def timestamp(self):\n    \"\"\"Return current timestamp as a string.\n\n    Returns:\n        str: current timestamp.\n\n    \"\"\"\n    return datetime.now().strftime(\"%H:%M:%S.%f\")\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/api/workio.html","title":"workio","text":"<p>Host API required Work Files tool</p>"},{"location":"autoapi/client/ayon_harmony/api/workio.html#client.ayon_harmony.api.workio.current_file","title":"<code>current_file()</code>","text":"<p>Returning None to make Workfiles app look at first file extension.</p> Source code in <code>client/ayon_harmony/api/workio.py</code> <pre><code>def current_file():\n    \"\"\"Returning None to make Workfiles app look at first file extension.\"\"\"\n    return ProcessContext.workfile_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_harmony/hooks/pre_launch_args.html","title":"pre_launch_args","text":""},{"location":"autoapi/client/ayon_harmony/hooks/pre_launch_args.html#client.ayon_harmony.hooks.pre_launch_args.HarmonyPrelaunchHook","title":"<code>HarmonyPrelaunchHook</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Launch arguments preparation.</p> <p>Hook add python executable and script path to Harmony implementation before Harmony executable and add last workfile path to launch arguments.</p> <p>Existence of last workfile is checked. If workfile does not exists tries to copy templated workfile from predefined path.</p> Source code in <code>client/ayon_harmony/hooks/pre_launch_args.py</code> <pre><code>class HarmonyPrelaunchHook(PreLaunchHook):\n    \"\"\"Launch arguments preparation.\n\n    Hook add python executable and script path to Harmony implementation\n    before Harmony executable and add last workfile path to launch arguments.\n\n    Existence of last workfile is checked. If workfile does not exists tries\n    to copy templated workfile from predefined path.\n    \"\"\"\n    app_groups = {\"harmony\"}\n\n    order = 20\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Pop executable\n        executable_path = self.launch_context.launch_args.pop(0)\n\n        # Pop rest of launch arguments - There should not be other arguments!\n        remainders = []\n        while self.launch_context.launch_args:\n            remainders.append(self.launch_context.launch_args.pop(0))\n\n        script_path = get_launch_script_path()\n\n        new_launch_args = get_ayon_launcher_args(\n            \"run\", script_path, executable_path\n        )\n        # Add workfile path if exists\n        workfile_path = self.data.get(\"workfile_path\")\n        last_workfile_path = self.data[\"last_workfile_path\"]\n        if workfile_path:\n            new_launch_args.append(workfile_path)\n\n        elif (\n            self.data.get(\"start_last_workfile\")\n            and last_workfile_path\n            and os.path.exists(last_workfile_path)\n        ):\n            new_launch_args.append(last_workfile_path)\n\n        workfile_startup = self.data.get(\"workfile_startup\", True)\n\n        self.launch_context.env[\"AYON_HARMONY_WORKFILES_ON_LAUNCH\"] = str(\n            int(workfile_startup)\n        )\n\n        # Append as whole list as these arguments should not be separated\n        self.launch_context.launch_args.append(new_launch_args)\n\n        if remainders:\n            self.launch_context.launch_args.extend(remainders)\n\n        self.launch_context.kwargs = get_launch_kwargs(\n            self.launch_context.kwargs\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/hooks/pre_launch_args.html#client.ayon_harmony.hooks.pre_launch_args.get_launch_kwargs","title":"<code>get_launch_kwargs(kwargs)</code>","text":"<p>Explicit setting of kwargs for Popen for Harmony.</p> <p>Expected behavior - ayon_console opens window with logs - ayon has stdout/stderr available for capturing</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Union[dict, None]</code> <p>Current kwargs or None.</p> required Source code in <code>client/ayon_harmony/hooks/pre_launch_args.py</code> <pre><code>def get_launch_kwargs(kwargs):\n    \"\"\"Explicit setting of kwargs for Popen for Harmony.\n\n    Expected behavior\n    - ayon_console opens window with logs\n    - ayon has stdout/stderr available for capturing\n\n    Args:\n        kwargs (Union[dict, None]): Current kwargs or None.\n\n    \"\"\"\n    if kwargs is None:\n        kwargs = {}\n\n    if platform.system().lower() != \"windows\":\n        return kwargs\n\n    if is_using_ayon_console():\n        kwargs.update({\n            \"creationflags\": subprocess.CREATE_NEW_CONSOLE\n        })\n    else:\n        kwargs.update({\n            \"creationflags\": subprocess.CREATE_NO_WINDOW,\n            \"stdout\": subprocess.DEVNULL,\n            \"stderr\": subprocess.DEVNULL\n        })\n    return kwargs\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_harmony/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_harmony/plugins/create/convert_legacy.html","title":"convert_legacy","text":"<p>Converter for legacy Harmony products.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/create/convert_legacy.html#client.ayon_harmony.plugins.create.convert_legacy.HarmonyLegacyConvertor","title":"<code>HarmonyLegacyConvertor</code>","text":"<p>               Bases: <code>ProductConvertorPlugin</code></p> <p>Find and convert any legacy products in the scene.</p> <p>This Converter will find all legacy products in the scene and will transform them to the current system. Since the old products doesn't retain any information about their original creators, the only mapping we can do is based on their product types.</p> <p>Its limitation is that you can have multiple creators creating product of the same product type and there is no way to handle it. This code should nevertheless cover all creators that came with OpenPype.</p> Source code in <code>client/ayon_harmony/plugins/create/convert_legacy.py</code> <pre><code>class HarmonyLegacyConvertor(ProductConvertorPlugin):\n    \"\"\"Find and convert any legacy products in the scene.\n\n    This Converter will find all legacy products in the scene and will\n    transform them to the current system. Since the old products doesn't\n    retain any information about their original creators, the only mapping\n    we can do is based on their product types.\n\n    Its limitation is that you can have multiple creators creating product\n    of the same product type and there is no way to handle it. This code\n    should nevertheless cover all creators that came with OpenPype.\n\n    \"\"\"\n    identifier = \"io.ayon.creators.harmony.legacy\"\n    product_type_to_id = {\n        \"render\": \"io.ayon.creators.harmony.render\",\n        \"renderFarm\": \"io.ayon.creators.harmony.render\",\n        \"template\": \"io.ayon.creators.harmony.template\",\n        \"workfile\": \"io.ayon.creators.harmony.workfile\",\n    }\n\n    def __init__(self, *args, **kwargs):\n        super(HarmonyLegacyConvertor, self).__init__(*args, **kwargs)\n        self.legacy_instances = {}\n        self.scene_metadata = {}\n\n    def find_instances(self):\n        \"\"\"Find legacy products in the scene.\n\n        Legacy products are the ones that doesn't have `creator_identifier`\n        parameter on them.\n\n        This is using cached entries done in\n        :py:meth:`~HarmonyCreatorBase.cache_instance_data()`\n\n        \"\"\"\n        self.legacy_instances = self.collection_shared_data.get(\n            \"harmony_cached_legacy_instances_names\")\n        if not self.legacy_instances:\n            return\n        # harmony_cached_scene_data is not accessible in `convert` directly\n        self.scene_metadata = self.collection_shared_data.get(\n            \"harmony_cached_scene_data\")\n        self.add_convertor_item(\n            \"Found {} incompatible product{}\".format(\n                len(self.legacy_instances),\n                \"s\" if len(self.legacy_instances) &gt; 1 else \"\"\n            )\n        )\n\n    def convert(self):\n        \"\"\"Convert all legacy products to current.\n\n        It is enough to add `creator_identifier` and `instance_node`.\n\n        \"\"\"\n        if not self.legacy_instances:\n            return\n\n        for product_type, node_names in self.legacy_instances.items():\n            if product_type not in self.product_type_to_id:\n                continue\n\n            for node_name in node_names:\n                creator_identifier = self.product_type_to_id[product_type]\n                self.log.info(\n                    f\"Converting {node_name} to {creator_identifier}\"\n                )\n                changed_data = {\n                    \"creator_identifier\": creator_identifier,\n                    \"id\": AYON_INSTANCE_ID,\n                    \"creator_attributes\": {\"render_target\": \"local\"}\n                }\n                if product_type == \"renderFarm\":\n                    node_meta = self.scene_metadata[node_name]\n                    changed_data[\"productType\"] = \"render\"\n                    changed_data[\"productName\"] = (\n                        node_meta[\"productName\"].replace(\"Farm\", \"\"))\n                    changed_data[\"creator_attributes\"][\"render_target\"] = \\\n                        \"farm\"\n\n                harmony.imprint(node_name, data=changed_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/convert_legacy.html#client.ayon_harmony.plugins.create.convert_legacy.HarmonyLegacyConvertor.convert","title":"<code>convert()</code>","text":"<p>Convert all legacy products to current.</p> <p>It is enough to add <code>creator_identifier</code> and <code>instance_node</code>.</p> Source code in <code>client/ayon_harmony/plugins/create/convert_legacy.py</code> <pre><code>def convert(self):\n    \"\"\"Convert all legacy products to current.\n\n    It is enough to add `creator_identifier` and `instance_node`.\n\n    \"\"\"\n    if not self.legacy_instances:\n        return\n\n    for product_type, node_names in self.legacy_instances.items():\n        if product_type not in self.product_type_to_id:\n            continue\n\n        for node_name in node_names:\n            creator_identifier = self.product_type_to_id[product_type]\n            self.log.info(\n                f\"Converting {node_name} to {creator_identifier}\"\n            )\n            changed_data = {\n                \"creator_identifier\": creator_identifier,\n                \"id\": AYON_INSTANCE_ID,\n                \"creator_attributes\": {\"render_target\": \"local\"}\n            }\n            if product_type == \"renderFarm\":\n                node_meta = self.scene_metadata[node_name]\n                changed_data[\"productType\"] = \"render\"\n                changed_data[\"productName\"] = (\n                    node_meta[\"productName\"].replace(\"Farm\", \"\"))\n                changed_data[\"creator_attributes\"][\"render_target\"] = \\\n                    \"farm\"\n\n            harmony.imprint(node_name, data=changed_data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/convert_legacy.html#client.ayon_harmony.plugins.create.convert_legacy.HarmonyLegacyConvertor.find_instances","title":"<code>find_instances()</code>","text":"<p>Find legacy products in the scene.</p> <p>Legacy products are the ones that doesn't have <code>creator_identifier</code> parameter on them.</p> <p>This is using cached entries done in :py:meth:<code>~HarmonyCreatorBase.cache_instance_data()</code></p> Source code in <code>client/ayon_harmony/plugins/create/convert_legacy.py</code> <pre><code>def find_instances(self):\n    \"\"\"Find legacy products in the scene.\n\n    Legacy products are the ones that doesn't have `creator_identifier`\n    parameter on them.\n\n    This is using cached entries done in\n    :py:meth:`~HarmonyCreatorBase.cache_instance_data()`\n\n    \"\"\"\n    self.legacy_instances = self.collection_shared_data.get(\n        \"harmony_cached_legacy_instances_names\")\n    if not self.legacy_instances:\n        return\n    # harmony_cached_scene_data is not accessible in `convert` directly\n    self.scene_metadata = self.collection_shared_data.get(\n        \"harmony_cached_scene_data\")\n    self.add_convertor_item(\n        \"Found {} incompatible product{}\".format(\n            len(self.legacy_instances),\n            \"s\" if len(self.legacy_instances) &gt; 1 else \"\"\n        )\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_render.html","title":"create_render","text":"<p>Create render node.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_render.html#client.ayon_harmony.plugins.create.create_render.CreateRender","title":"<code>CreateRender</code>","text":"<p>               Bases: <code>HarmonyRenderCreator</code></p> <p>Composite node for publishing renders.</p> Source code in <code>client/ayon_harmony/plugins/create/create_render.py</code> <pre><code>class CreateRender(plugin.HarmonyRenderCreator):\n    \"\"\"Composite node for publishing renders.\"\"\"\n\n    identifier = \"io.ayon.creators.harmony.render\"\n    label = \"Render\"\n    product_type = \"render\"\n    product_base_type = \"render\"\n    icon = \"eye\"\n\n    node_type = \"WRITE\"\n\n    def setup_node(self, node):\n        \"\"\"Set render node.\"\"\"\n        self_name = self.__class__.__name__\n        path = \"render/{0}/{0}.\".format(node.split(\"/\")[-1])\n        harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Creators.{self_name}.create\",\n                \"args\": [node, path]\n            })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_render.html#client.ayon_harmony.plugins.create.create_render.CreateRender.setup_node","title":"<code>setup_node(node)</code>","text":"<p>Set render node.</p> Source code in <code>client/ayon_harmony/plugins/create/create_render.py</code> <pre><code>def setup_node(self, node):\n    \"\"\"Set render node.\"\"\"\n    self_name = self.__class__.__name__\n    path = \"render/{0}/{0}.\".format(node.split(\"/\")[-1])\n    harmony.send(\n        {\n            \"function\": f\"AyonHarmony.Creators.{self_name}.create\",\n            \"args\": [node, path]\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_render_layers.html","title":"create_render_layers","text":"<p>Render Layer and Passes creators.</p> <p>Render layer is main part which is represented by group in Harmony. All Harmony layers marked with that group color are part of the render layer. To be more specific about some parts of layer it is possible to create sub-sets of layer which are named passes. Render pass consist of layers in same color group as render layer but define more specific part.</p> <p>For example render layer could be 'Bob' which consist of 5 Harmony layers. - Bob has 'head' which consist of 2 Harmony layers -&gt; Render pass 'head' - Bob has 'body' which consist of 1 Harmony layer -&gt; Render pass 'body' - Bob has 'arm' which consist of 1 Harmony layer -&gt; Render pass 'arm' - Last layer does not belong to render pass at all</p> <p>Bob will be rendered as 'beauty' of bob (all visible layers in group). His head will be rendered too but without any other parts. The same for body and arm.</p> <p>What is this good for? Compositing has more power how the renders are used. Can do transforms on each render pass without need to modify a re-render them using Harmony.</p> <p>The workflow may hit issues when there are used other blending modes than default 'color' blend more. In that case it is not recommended to use this workflow at all as other blend modes may affect all layers in clip which can't be done.</p> <p>There is special case for simple publishing of scene which is called 'render.scene'. That will use all visible layers and render them as one big sequence.</p> Todos <p>Add option to extract marked layers and passes as json output format for     AfterEffects.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_render_layers.html#client.ayon_harmony.plugins.create.create_render_layers.AutoDetectRendeLayersPasses","title":"<code>AutoDetectRendeLayersPasses</code>","text":"<p>               Bases: <code>HarmonyCreator</code></p> <p>Create Render Layer and Render Pass instances based on scene data.</p> <p>This is auto-detection creator which can be triggered by user to create instances based on information in scene. Each used color group in scene will be created as Render Layer where group name is used as variant and each Harmony layer as Render Pass where layer name is used as variant.</p> <p>Never will have any instances, all instances belong to different creators.</p> Source code in <code>client/ayon_harmony/plugins/create/create_render_layers.py</code> <pre><code>class AutoDetectRendeLayersPasses(HarmonyCreator):\n    \"\"\"Create Render Layer and Render Pass instances based on scene data.\n\n    This is auto-detection creator which can be triggered by user to create\n    instances based on information in scene. Each used color group in scene\n    will be created as Render Layer where group name is used as variant and\n    each Harmony layer as Render Pass where layer name is used as variant.\n\n    Never will have any instances, all instances belong to different creators.\n    \"\"\"\n\n    product_type = \"render\"\n    product_base_type = \"render\"\n    label = \"Render Layer/Passes\"\n    identifier = \"render.auto.detect.creator\"\n    # order = CreateRenderPass.order + 10\n    description = \"Create Render Layers and Render Passes based on scene setup\"\n    detailed_description = AUTODETECT_RENDER_DETAILED_DESCRIPTION\n\n    # Settings\n    default_variants = [\"Main\"]\n    active_on_create = True\n\n    enabled = True\n\n    layer_name_template = {\n        \"enabled\": False,\n        \"template\": \"G{group_index}_L{layer_index}_{variant}\"\n    }\n    render_layer_variant_template = \"G{group_index}\"\n    group_idx_offset = 10\n    group_idx_padding = 3\n\n    def create(self, product_name, instance_data, pre_create_data):\n\n        project_entity = self.create_context.get_current_project_entity()\n        folder_path: str = self.create_context.get_current_folder_path()\n        task_name: str = self.create_context.get_current_task_name()\n        folder_entity: dict[str, Any] = self.create_context.get_folder_entity(\n            folder_path\n        )\n        task_entity: dict[str, Any] = self.create_context.get_task_entity(\n            folder_path, task_name\n        )\n\n        render_layers_by_group_id: dict[int, CreatedInstance] = {}\n        render_passes_by_render_layer_id: dict[int, list[CreatedInstance]] = (\n            collections.defaultdict(list)\n        )\n        for instance in self.create_context.instances:\n            if instance.creator_identifier == CreateRenderLayer.identifier:\n                group_id = instance[\"creator_attributes\"][\"group_id\"]\n                render_layers_by_group_id[group_id] = instance\n            elif instance.creator_identifier == CreateRenderPass.identifier:\n                render_layer_id = (\n                    instance\n                    [\"creator_attributes\"]\n                    [\"render_layer_instance_id\"]\n                )\n                render_passes_by_render_layer_id[render_layer_id].append(\n                    instance\n                )\n\n        layers_by_group_id: dict[int, list[dict[str, Any]]] = (\n            collections.defaultdict(list)\n        )\n        scene_layers: list[dict[str, Any]] = get_layers_info()\n        scene_groups: list[dict[str, Any]] = get_group_infos()\n        for layer in scene_layers:\n            group_id = layer[\"color\"]\n            layers_by_group_id[group_id].append(layer)\n\n        mark_layers_for_review = pre_create_data.get(\n            \"mark_layers_for_review\", False\n        )\n        mark_passes_for_review = pre_create_data.get(\n            \"mark_passes_for_review\", False\n        )\n        render_target = pre_create_data.get(\n            \"render_target\", False\n        )\n\n        only_visible_groups = pre_create_data.get(\n            \"only_visible_groups\", False\n        )\n        filtered_groups = self._filter_groups(\n            layers_by_group_id,\n            scene_groups,\n            only_visible_groups\n        )\n        # Make sure  all render layers are created\n        for group in filtered_groups:\n            instance: Union[CreatedInstance, None] = (\n                self._prepare_render_layer(\n                    project_entity,\n                    folder_entity,\n                    task_entity,\n                    group.color,\n                    filtered_groups,\n                    mark_layers_for_review,\n                    render_target,\n                    render_layers_by_group_id.get(group.color),\n                )\n            )\n            if instance is not None:\n                render_layers_by_group_id[group.color] = instance\n\n        for group in filtered_groups:\n            layers: list[dict[str, Any]] = layers_by_group_id[group.color]\n            render_layer_instance: Union[CreatedInstance, None] = (\n                render_layers_by_group_id.get(group.color)\n            )\n            if not layers or render_layer_instance is None:\n                continue\n\n            self._prepare_render_passes(\n                project_entity,\n                folder_entity,\n                task_entity,\n                render_layer_instance,\n                layers,\n                mark_passes_for_review,\n                render_target,\n                render_passes_by_render_layer_id[render_layer_instance.id]\n            )\n\n        self._wrap_nodes_in_backdrop()\n\n    def _filter_groups(\n        self,\n        layers_by_group_id,\n        scene_groups,\n        only_visible_groups\n    ):\n        filtered_groups = []\n        for group in scene_groups:\n            layers: list[dict[str, Any]] = layers_by_group_id[group.color]\n            if not layers:\n                continue\n\n            if only_visible_groups and not any(\n                layer for layer in layers if layer[\"enabled\"]\n            ):\n                continue\n            filtered_groups.append(group)\n        return filtered_groups\n\n    @staticmethod\n    def _get_render_layer_variant(\n        template: str,\n        group_position: int,\n        group_idx_padding: int,\n        group_idx_offset: int,\n        log\n    ) -&gt; str:\n        \"\"\"Calculates render layer portion (G010)\"\"\"\n        variant = None\n        index_template = f\"{{:0&gt;{group_idx_padding}}}\"\n        group_pos = group_position * group_idx_offset\n        try:\n            group_index = index_template.format(group_pos)\n            variant = template.format(\n                group_index=group_index,\n            )\n        except Exception:\n            log.warning(\n                \"Failed to create render layer variant\",\n                exc_info=True,\n            )\n\n        return variant\n\n    def _prepare_render_layer(\n        self,\n        project_entity: dict[str, Any],\n        folder_entity: dict[str, Any],\n        task_entity: dict[str, Any],\n        group_id: str,\n        groups: list[GroupInfo],\n        mark_for_review: bool,\n        render_target: str,\n        existing_instance: Optional[CreatedInstance] = None,\n    ) -&gt; Union[CreatedInstance, None]:\n        match_group: Optional[dict[str, Any]] = next(\n            (group for group in groups if group.color == group_id), None\n        )\n        if not match_group:\n            return None\n\n        task_name = task_entity[\"name\"]\n        group_idx = match_group.position\n        variant: str = self._get_render_layer_variant(\n            self.render_layer_variant_template,\n            group_idx,\n            self.group_idx_padding,\n            self.group_idx_offset,\n            self.log,\n        )\n        creator: CreateRenderLayer = self.create_context.creators[\n            CreateRenderLayer.identifier\n        ]\n        product_name: str = creator.get_product_name(\n            project_entity[\"name\"],\n            folder_entity,\n            task_entity,\n            variant,\n            host_name=self.create_context.host_name,\n            project_entity=project_entity,\n        )\n        if existing_instance is not None:\n            existing_instance[\"folderPath\"] = folder_entity[\"path\"]\n            existing_instance[\"task\"] = task_name\n            existing_instance[\"productName\"] = product_name\n            return existing_instance\n\n        instance_data: dict[str, str] = {\n            \"folderPath\": folder_entity[\"path\"],\n            \"task\": task_name,\n            \"productType\": creator.product_type,\n            \"variant\": variant,\n            \"group_label\": variant\n        }\n        pre_create_data: dict[str, Any] = {\n            \"group_id\": group_id,\n            \"mark_for_review\": mark_for_review,\n            \"render_target\": render_target,\n        }\n        return creator.create(product_name, instance_data, pre_create_data)\n\n    def _prepare_render_passes(\n        self,\n        project_entity: dict[str, Any],\n        folder_entity: dict[str, Any],\n        task_entity: dict[str, Any],\n        render_layer_instance: CreatedInstance,\n        layers: list[dict[str, Any]],\n        mark_for_review: bool,\n        render_target: str,\n        existing_render_passes: list[CreatedInstance],\n    ):\n        task_name = task_entity[\"name\"]\n        creator: CreateRenderPass = self.create_context.creators[\n            CreateRenderPass.identifier\n        ]\n        render_pass_by_layer_name = {}\n        for render_pass in existing_render_passes:\n            render_pass_by_layer_name[render_pass[\"layer_name\"]] = render_pass\n\n        # Use renaming template to parse correct variant from existing layer\n        #   names.\n        name_regex = None\n        if self.layer_name_template[\"enabled\"]:\n            template = self.layer_name_template[\"template\"]\n            fake_group = \"___group___\"\n            fake_layer = \"___layer___\"\n            fake_variant = \"___variant___\"\n            try:\n                name_regex = template.format(\n                    layer_index=fake_layer,\n                    group_index=fake_group,\n                    variant=fake_variant,\n                )\n            except Exception:\n                self.log.error(\n                    \"Failed to fill name regex template.\",\n                    exc_info=True\n                )\n                name_regex = \"\"\n\n            for src, regex in (\n                (fake_group, r\"(?P&lt;group&gt;\\d+)\"),\n                (fake_layer, r\"(?P&lt;layer&gt;\\d+)\"),\n                (fake_variant, r\"(?P&lt;variant&gt;.*)\"),\n            ):\n                name_regex = name_regex.replace(src, regex)\n            name_regex = re.compile(name_regex)\n\n        layer_positions_in_groups = get_layer_positions_in_groups(layers)\n\n        for layer in layers:\n            layer_name = layer[\"name\"]\n            variant = None\n            render_pass = render_pass_by_layer_name.get(layer_name)\n            if render_pass is not None and len(render_pass[\"layer_names\"]) &gt; 0:\n                variant = render_pass[\"variant\"]\n            elif name_regex is not None:\n                result = name_regex.match(layer_name)\n                if result is not None:\n                    variant = result.groupdict().get(\"variant\")\n\n            if not variant:\n                variant = layer[\"name\"]\n\n            renderlayer = render_layer_instance[\"variant\"]\n\n            renderpass = get_render_pass_name(\n                creator.render_pass_template,\n                layer_positions_in_groups[layer[\"name\"]],\n                creator.layer_idx_padding,\n                creator.layer_idx_offset,\n                variant,\n                self.log\n            )\n            if not render_pass:\n                render_pass = {}\n\n            render_pass[\"renderPass\"] = renderpass\n            render_pass[\"renderLayer\"] = renderlayer\n\n            product_name = creator.get_product_name(\n                project_entity[\"name\"],\n                folder_entity,\n                task_entity,\n                variant,\n                host_name=self.create_context.host_name,\n                instance=render_pass,\n                project_entity=project_entity,\n            )\n\n            instance_data: dict[str, str] = {\n                \"folderPath\": folder_entity[\"path\"],\n                \"task\": task_name,\n                \"productType\": creator.product_type,\n                \"variant\": variant,\n            }\n\n            pre_create_data: dict[str, Any] = {\n                \"render_layer_instance_id\": render_layer_instance.id,\n                \"layer_name\": layer_name,\n                \"mark_for_review\": mark_for_review,\n                \"render_target\": render_target,\n            }\n            creator.create(product_name, instance_data, pre_create_data)\n\n    def get_pre_create_attr_defs(self) -&gt; list[AbstractAttrDef]:\n        render_layer_creator: CreateRenderLayer = self.create_context.creators[\n            CreateRenderLayer.identifier\n        ]\n        render_pass_creator: CreateRenderPass = self.create_context.creators[\n            CreateRenderPass.identifier\n        ]\n        rendering_targets = {\n            \"local\": \"Local machine rendering\",\n            \"farm\": \"Farm rendering\",\n        }\n        return [\n            BoolDef(\n                \"only_visible_groups\",\n                label=\"Only visible color groups\",\n                tooltip=(\n                    \"Render Layers will happen only on color\"\n                    \" groups with visible layers.\"\n                ),\n                default=True\n            ),\n            BoolDef(\n                \"mark_layers_for_review\",\n                label=\"Mark RenderLayers for review\",\n                default=render_layer_creator.mark_for_review,\n            ),\n            BoolDef(\n                \"mark_passes_for_review\",\n                label=\"Mark RenderPasses for review\",\n                default=render_pass_creator.mark_for_review,\n            ),\n            EnumDef(\n                \"render_target\",\n                items=rendering_targets,\n                label=\"Render target\"\n            )\n        ]\n\n    def product_impl(self, name, instance_data: dict, pre_create_data: dict):\n        pass\n\n    def _wrap_nodes_in_backdrop(self):\n        \"\"\"Tries to wrap all nodes of a layer group into Backdrop\"\"\"\n        scene_containers = harmony.get_scene_data()\n        for node_name, container in scene_containers.items():\n            identifier = container[\"creator_identifier\"]\n            if identifier != CreateRenderLayer.identifier:\n                continue\n            group_label = container[\"variant\"]\n            group_id = container[\"creator_attributes\"][\"group_id\"]\n            group_color = group_id\n            harmony.send(\n                {\n                    \"function\": (\n                        \"AyonHarmony.Creators.CreateRenderLayer.formatNodes\"\n                    ),\n                    \"args\": [node_name, group_label, group_color]\n                }\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_render_layers.html#client.ayon_harmony.plugins.create.create_render_layers.CreateRenderLayer","title":"<code>CreateRenderLayer</code>","text":"<p>               Bases: <code>HarmonyRenderCreator</code></p> <p>Mark layer group as Render layer instance.</p> <p>All Harmony layers in the scene with the color group id are rendered in the beauty pass. To create sub passes use Render Layer creator which is dependent on existence of render layer instance.</p> Source code in <code>client/ayon_harmony/plugins/create/create_render_layers.py</code> <pre><code>class CreateRenderLayer(HarmonyRenderCreator):\n    \"\"\"Mark layer group as Render layer instance.\n\n    All Harmony layers in the scene with the color group id are rendered in the\n    beauty pass. To create sub passes use Render Layer creator which is\n    dependent on existence of render layer instance.\n    \"\"\"\n\n    label = \"Render Layer\"\n    product_type = \"render\"\n    product_base_type = \"render\"\n    product_template_product_type = \"renderLayer\"\n    identifier = \"render.layer\"\n    icon = \"fa5.images\"\n\n    # Order to be executed before Render Pass creator\n    order = 90\n    description = \"Mark Harmony color group as one Render Layer.\"\n    detailed_description = RENDER_LAYER_DETAILED_DESCRIPTIONS\n\n    # Settings\n    default_variants = [\"Main\"]\n    active_on_create = True\n\n    # - Default render pass name for beauty\n    default_pass_name = \"beauty\"\n    # - Mark by default instance for review\n    mark_for_review = True\n\n    def get_dynamic_data(\n        self,\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name,\n        instance\n    ):\n        return {\n            \"renderpass\": self.default_pass_name,\n            \"renderlayer\": variant,\n        }\n\n    def product_impl(self, product_name, instance_data, pre_create_data):\n        group_id = pre_create_data.get(\"group_id\")\n        # This creator should run only on one group\n        if group_id is None or group_id == \"-1\":\n            selected_groups = self._get_selected_group_colors()\n            if len(selected_groups) &gt; 1:\n                raise CreatorError(\"You have selected more than one group\")\n\n            if len(selected_groups) == 0:\n                raise CreatorError(\"You don't have selected any group\")\n            group_id = tuple(selected_groups)[0]\n\n        for instance in self.create_context.instances:\n            if instance.creator_identifier != self.identifier:\n                continue\n            if instance[\"creator_attributes\"][\"group_id\"] == group_id:\n                raise CreatorError(\n                    (\n                        f'Group \"{group_id}\" is already used'\n                        f' by another render layer \"{instance[\"productName\"]}\"'\n                    )\n                )\n            if instance[\"productName\"] == product_name:\n                raise CreatorError(\n                    f\"Product '{product_name}' already exists.\")\n\n        creator_attributes = instance_data.setdefault(\"creator_attributes\", {})\n        mark_for_review = pre_create_data.get(\"mark_for_review\")\n        if mark_for_review is None:\n            mark_for_review = self.mark_for_review\n\n        creator_attributes[\"group_id\"] = group_id\n        creator_attributes[\"mark_for_review\"] = mark_for_review\n        creator_attributes[\"render_target\"] = pre_create_data[\"render_target\"]\n\n        node = self._create_nodes_for_group(group_id, product_name)\n        self.log.debug(f\"Created node:: {node}\")\n        return node\n\n    def get_pre_create_attr_defs(self):\n        enum_defs = super().get_pre_create_attr_defs()\n        group_infos = get_group_infos()\n        group_enum_values = [\n            {\"value\": group.color, \"label\": str(group.position)}\n            for group in group_infos\n        ]\n        group_enum_values.insert(\n            0,\n            {\"label\": \"&lt;Use selection&gt;\", \"value\": \"-1\"}\n        )\n\n        enum_defs.append(\n            EnumDef(\"group_id\", label=\"Group\", items=group_enum_values))\n        return enum_defs\n\n    def get_instance_attr_defs(self):\n        groups = get_group_infos()\n\n        groups_enum = [\n            {\"value\": group.color, \"label\": str(group.position)}\n            for group in groups\n        ]\n        return [\n            EnumDef(\n                \"group_id\",\n                label=\"Group\",\n                items=groups_enum,\n                enabled=False\n            ),\n            BoolDef(\n                \"mark_for_review\",\n                label=\"Review\",\n                default=self.mark_for_review\n            ),\n            EnumDef(\n                \"render_target\",\n                items=self.rendering_targets,\n                label=\"Render target\"\n            ),\n        ]\n\n    def _create_nodes_for_group(self, group_id, product_name):\n        layers_data = get_layers_info()\n        layers_full_names = [\n            layer[\"fullName\"]\n            for layer in layers_data\n            if layer[\"color\"] == group_id\n        ]\n\n        self_name = self.__class__.__name__\n        created_node = harmony.send(\n            {\n                \"function\": (\n                    f\"AyonHarmony.Creators.{self_name}.createLayerNodes\"\n                ),\n                \"args\": [layers_full_names, product_name]\n            }\n        )[\"result\"]\n\n        return created_node\n\n    def _get_selected_group_colors(self):\n        return {\n            layer[\"color\"]\n            for layer in get_layers_info()\n            if layer[\"selected\"]\n        }\n\n    def remove_instances(self, instances):\n        for instance in instances:\n            # There is only ever one workfile instance\n            node_name = instance.transient_data[\"node\"]\n            container_data = harmony.read(node_name)\n            harmony.delete_node(node_name)\n            harmony.delete_node(f\"{node_name}_comp\")\n            group_label = container_data.get(\"group_label\")\n            container_backdrop = None\n            if group_label:\n                container_backdrop = harmony.find_backdrop_by_name(\n                    group_label\n                )\n            if container_backdrop:\n                harmony.send(\n                    {\n                        \"function\": \"AyonHarmony.removeBackdrop\",\n                        \"args\": [container_backdrop, False]\n                    }\n                )\n            self._remove_instance_from_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_render_layers.html#client.ayon_harmony.plugins.create.create_render_layers.get_group_infos","title":"<code>get_group_infos()</code>","text":"<p>Lists all used layer colors to choose from</p> Source code in <code>client/ayon_harmony/plugins/create/create_render_layers.py</code> <pre><code>def get_group_infos() -&gt; list[GroupInfo]:\n    \"\"\"Lists all used layer colors to choose from\"\"\"\n    # TODO cache this\n    layers_data = get_layers_info()\n    # to keep order\n    ordered_colors = []\n    for layer in layers_data:\n        color = layer[\"color\"]\n        if color not in ordered_colors:\n            ordered_colors.append(color)\n    return [\n        GroupInfo(color, idx + 1)\n        for idx, color in enumerate(ordered_colors)\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_render_layers.html#client.ayon_harmony.plugins.create.create_render_layers.get_group_position","title":"<code>get_group_position(group_id, group_infos=None)</code>","text":"<p>Find appropriate color for ordinal number of group</p> Source code in <code>client/ayon_harmony/plugins/create/create_render_layers.py</code> <pre><code>def get_group_position(\n    group_id: str,\n    group_infos: Optional[list[GroupInfo]] = None\n) -&gt; Optional[str]:\n    \"\"\"Find appropriate color for ordinal number of group\"\"\"\n    if not group_infos:\n        group_infos = get_group_infos()\n    group_position = None\n    for group_item in group_infos:\n        if group_item.color == group_id:\n            group_position = group_item.position\n            break\n    return group_position\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_render_layers.html#client.ayon_harmony.plugins.create.create_render_layers.get_render_pass_name","title":"<code>get_render_pass_name(pass_template, position_in_group, layer_idx_padding, layer_idx_offset, variant, log)</code>","text":"<p>Calculates render pass portion.</p> <p>It was designed to follow \"L{layer_index}_{variant}\" (L010_CHAR01_head)</p> Source code in <code>client/ayon_harmony/plugins/create/create_render_layers.py</code> <pre><code>def get_render_pass_name(\n    pass_template: str,\n    position_in_group: int,\n    layer_idx_padding: int,\n    layer_idx_offset: int,\n    variant: str,\n    log: logging.Logger,\n) -&gt; str:\n    \"\"\"Calculates render pass portion.\n\n    It was designed to follow \"L{layer_index}_{variant}\"\n    (L010_CHAR01_head)\n    \"\"\"\n    new_name = None\n    index_template = f\"{{:0&gt;{layer_idx_padding}}}\"\n    layer_pos = position_in_group * layer_idx_offset\n    try:\n        layer_index = index_template.format(layer_pos)\n        new_name = pass_template.format(\n            layer_index=layer_index,\n            variant=variant\n        )\n    except Exception:\n        log.warning(\"Failed to create new pass name\", exc_info=True)\n\n    return new_name\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_review.html","title":"create_review","text":"<p>Creator plugin for creating workfiles.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_review.html#client.ayon_harmony.plugins.create.create_review.CreateReview","title":"<code>CreateReview</code>","text":"<p>               Bases: <code>HarmonyAutoCreator</code></p> <p>Review auto-creator.</p> <p>It requires <code>ayon+settings://harmony/create/CreateReview</code> to be enabled. This creator produces instance of <code>review</code> product type, artist does not need create any instance manually if they have a <code>Top/Display</code> node in the scene.</p> Source code in <code>client/ayon_harmony/plugins/create/create_review.py</code> <pre><code>class CreateReview(HarmonyAutoCreator):\n    \"\"\"Review auto-creator.\n\n    It requires `ayon+settings://harmony/create/CreateReview` to be enabled.\n    This creator produces instance of `review` product type, artist does not\n    need create any instance manually if they have a `Top/Display` node\n    in the scene.\n    \"\"\"\n    identifier = \"io.ayon.creators.harmony.review\"\n    label = \"Review\"\n    product_type = \"review\"\n    product_base_type = \"review\"\n    icon = \"ei.video\"\n\n    default_variants = [\"Main\"]\n    active_on_create = True\n\n    # Placeholder node name for where we store the review data.\n    # This does not create an actual Harmony node, but just uses this name\n    # as key in the AYON Harmony scene data.\n    _node_name = \"__review__\"\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_template.html","title":"create_template","text":""},{"location":"autoapi/client/ayon_harmony/plugins/create/create_template.html#client.ayon_harmony.plugins.create.create_template.CreateTemplate","title":"<code>CreateTemplate</code>","text":"<p>               Bases: <code>HarmonyCreator</code></p> <p>Use existing Backdrop or create new one around selected nodes.</p> <p>Publishable template is marked as Backdrop wrapping node(s)</p> Source code in <code>client/ayon_harmony/plugins/create/create_template.py</code> <pre><code>class CreateTemplate(plugin.HarmonyCreator):\n    \"\"\"Use existing Backdrop or create new one around selected nodes.\n\n    Publishable template is marked as Backdrop wrapping node(s)\n    \"\"\"\n\n    identifier = \"io.ayon.creators.harmony.template\"\n    label = \"Template\"\n    product_type = \"harmony.template\"\n    product_base_type = \"harmony.template\"\n    icon = \"cubes\"\n\n    def product_impl(self, name, instance_data: dict, pre_create_data: dict):\n        args = [name, pre_create_data.get(\"use_selection\")]\n        backdrop = harmony.send(\n            {\n                \"function\": \"AyonHarmony.createBackdropContainer\",\n                \"args\": args\n            }\n        )[\"result\"]\n\n        return backdrop[\"title\"][\"text\"]\n\n    def remove_instances(self, instances):\n        for instance in instances:\n            container_name = instance.transient_data[\"node\"]\n            container_backdrop = harmony.find_backdrop_by_name(container_name)\n            if container_backdrop:\n                harmony.send(\n                    {\n                        \"function\": \"AyonHarmony.removeBackdrop\",\n                        \"args\": [container_backdrop, True]\n                    }\n                )\n            harmony.remove(container_name)\n            self._remove_instance_from_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_workfile.html","title":"create_workfile","text":"<p>Creator plugin for creating workfiles.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/create/create_workfile.html#client.ayon_harmony.plugins.create.create_workfile.CreateWorkfile","title":"<code>CreateWorkfile</code>","text":"<p>               Bases: <code>HarmonyAutoCreator</code></p> <p>Workfile auto-creator.</p> Source code in <code>client/ayon_harmony/plugins/create/create_workfile.py</code> <pre><code>class CreateWorkfile(HarmonyAutoCreator):\n    \"\"\"Workfile auto-creator.\"\"\"\n    identifier = \"io.ayon.creators.harmony.workfile\"\n    label = \"Workfile\"\n    product_type = \"workfile\"\n    product_base_type = \"workfile\"\n    icon = \"fa5.file\"\n\n    default_variants = [\"Main\"]\n    active_on_create = True\n\n    # Placeholder node name for where we store the workfile data.\n    # This does not create an actual Harmony node, but just uses this name\n    # as key in the AYON Harmony scene data.\n    _node_name = \"__workfile__\"\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_harmony/plugins/load/load_audio.html","title":"load_audio","text":""},{"location":"autoapi/client/ayon_harmony/plugins/load/load_audio.html#client.ayon_harmony.plugins.load.load_audio.ImportAudioLoader","title":"<code>ImportAudioLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Import audio.</p> Source code in <code>client/ayon_harmony/plugins/load/load_audio.py</code> <pre><code>class ImportAudioLoader(load.LoaderPlugin):\n    \"\"\"Import audio.\"\"\"\n\n    product_types = {\"shot\", \"audio\"}\n    representations = {\"wav\"}\n    label = \"Import Audio\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        wav_file = self.filepath_from_context(context)\n        harmony.send(\n            {\"function\": func, \"args\": [context[\"product\"][\"name\"], wav_file]}\n        )\n\n        product_name = context[\"product\"][\"name\"]\n\n        return harmony.containerise(\n            product_name,\n            namespace,\n            product_name,\n            context,\n            self.__class__.__name__\n        )\n\n    def update(self, container, context):\n        pass\n\n    def remove(self, container):\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_background.html","title":"load_background","text":""},{"location":"autoapi/client/ayon_harmony/plugins/load/load_background.html#client.ayon_harmony.plugins.load.load_background.BackgroundLoader","title":"<code>BackgroundLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load images Stores the imported product in a container named after the product.</p> Source code in <code>client/ayon_harmony/plugins/load/load_background.py</code> <pre><code>class BackgroundLoader(load.LoaderPlugin):\n    \"\"\"Load images\n    Stores the imported product in a container named after the product.\n    \"\"\"\n    product_types = {\"background\"}\n    representations = {\"json\"}\n\n    def load(self, context, name=None, namespace=None, data=None):\n\n        path = self.filepath_from_context(context)\n        with open(path) as json_file:\n            data = json.load(json_file)\n\n        layers = list()\n\n        for child in data['children']:\n            if child.get(\"filename\"):\n                layers.append(child[\"filename\"])\n            else:\n                for layer in child['children']:\n                    if layer.get(\"filename\"):\n                        layers.append(layer[\"filename\"])\n\n        bg_folder = os.path.dirname(path)\n\n        product_name = context[\"product\"][\"name\"]\n        # read_node_name += \"_{}\".format(uuid.uuid4())\n        container_nodes = []\n\n        for layer in sorted(layers):\n            file_to_import = [\n                os.path.join(bg_folder, layer).replace(\"\\\\\", \"/\")\n            ]\n\n            read_node = harmony.send(\n                {\n                    \"function\": copy_files + import_files,\n                    \"args\": [\"Top\", file_to_import, layer, 1]\n                }\n            )[\"result\"]\n            container_nodes.append(read_node)\n\n        return harmony.containerise(\n            product_name,\n            namespace,\n            product_name,\n            context,\n            self.__class__.__name__,\n            nodes=container_nodes\n        )\n\n    def update(self, container, context):\n        repre_entity = context[\"representation\"]\n        path = self.filepath_from_context(context)\n        with open(path) as json_file:\n            data = json.load(json_file)\n\n        layers = list()\n\n        for child in data['children']:\n            if child.get(\"filename\"):\n                print(child[\"filename\"])\n                layers.append(child[\"filename\"])\n            else:\n                for layer in child['children']:\n                    if layer.get(\"filename\"):\n                        print(layer[\"filename\"])\n                        layers.append(layer[\"filename\"])\n\n        bg_folder = os.path.dirname(path)\n\n        print(container)\n\n        is_latest = is_representation_from_latest(repre_entity)\n        for layer in sorted(layers):\n            file_to_import = [\n                os.path.join(bg_folder, layer).replace(\"\\\\\", \"/\")\n            ]\n            print(20 * \"#\")\n            print(f\"FILE TO REPLACE: {file_to_import}\")\n            print(f\"LAYER: {layer}\")\n            node = harmony.find_node_by_name(layer, \"READ\")\n            print(f\"{node}\")\n\n            if node in container['nodes']:\n                harmony.send(\n                    {\n                        \"function\": copy_files + replace_files,\n                        \"args\": [file_to_import, node, 1]\n                    }\n                )\n            else:\n                read_node = harmony.send(\n                    {\n                        \"function\": copy_files + import_files,\n                        \"args\": [\"Top\", file_to_import, layer, 1]\n                    }\n                )[\"result\"]\n                container['nodes'].append(read_node)\n\n            # Colour node.\n            sig = harmony.signature(\"set_color\")\n            func = \"\"\"function %s(args){\n                for( var i =0; i &lt;= args[0].length - 1; ++i)\n                {\n                    var red_color = new ColorRGBA(255, 0, 0, 255);\n                    var green_color = new ColorRGBA(0, 255, 0, 255);\n                    if (args[1] == \"red\"){\n                        node.setColor(args[0], red_color);\n                    }\n                    if (args[1] == \"green\"){\n                        node.setColor(args[0], green_color);\n                    }\n                }\n            }\n            %s\n            \"\"\" % (sig, sig)\n            if is_latest:\n                harmony.send({\"function\": func, \"args\": [node, \"green\"]})\n            else:\n                harmony.send({\"function\": func, \"args\": [node, \"red\"]})\n\n        harmony.imprint(\n            container['name'],\n            {\n                \"representation\": repre_entity[\"id\"],\n                \"nodes\": container[\"nodes\"]\n            }\n        )\n\n    def remove(self, container):\n        for node in container.get(\"nodes\"):\n\n            func = \"\"\"function deleteNode(_node)\n            {\n                node.deleteNode(_node, true, true);\n            }\n            deleteNode\n            \"\"\"\n            harmony.send(\n                {\"function\": func, \"args\": [node]}\n            )\n            harmony.imprint(container['name'], {}, remove=True)\n\n    def switch(self, container, context):\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_imagesequence.html","title":"load_imagesequence","text":"<p>Loader for image sequences.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_imagesequence.html#client.ayon_harmony.plugins.load.load_imagesequence.ImageSequenceLoader","title":"<code>ImageSequenceLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load image sequences.</p> <p>Stores the imported product in a container named after the product.</p> Source code in <code>client/ayon_harmony/plugins/load/load_imagesequence.py</code> <pre><code>class ImageSequenceLoader(load.LoaderPlugin):\n    \"\"\"Load image sequences.\n\n    Stores the imported product in a container named after the product.\n    \"\"\"\n\n    product_types = {\n        \"shot\",\n        \"render\",\n        \"image\",\n        \"plate\",\n        \"reference\",\n        \"review\",\n    }\n    representations = {\"*\"}\n    extensions = {\"jpeg\", \"png\", \"jpg\"}\n    settings_category = \"harmony\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        \"\"\"Plugin entry point.\n\n        Args:\n            context (:class:`pyblish.api.Context`): Context.\n            name (str, optional): Container name.\n            namespace (str, optional): Container namespace.\n            data (dict, optional): Additional data passed into loader.\n\n        \"\"\"\n        fname = Path(self.filepath_from_context(context))\n        self_name = self.__class__.__name__\n        collections, remainder = clique.assemble(\n            os.listdir(fname.parent.as_posix())\n        )\n        files = []\n        if collections:\n            for f in list(collections[0]):\n                files.append(fname.parent.joinpath(f).as_posix())\n        else:\n            files.append(fname.parent.joinpath(remainder[0]).as_posix())\n\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        group_id = str(uuid.uuid4())\n        read_node = harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Loaders.{self_name}.importFiles\",  # noqa: E501\n                \"args\": [\n                    files,\n                    folder_name,\n                    product_name,\n                    1,\n                    group_id\n                ]\n            }\n        )[\"result\"]\n\n        return harmony.containerise(\n            f\"{folder_name}_{product_name}\",\n            namespace,\n            read_node,\n            context,\n            self_name,\n            nodes=[read_node]\n        )\n\n    def update(self, container, context):\n        \"\"\"Update loaded containers.\n\n        Args:\n            container (dict): Container data.\n            context (dict): Representation context data.\n\n        \"\"\"\n        self_name = self.__class__.__name__\n        node = container.get(\"nodes\").pop()\n\n        repre_entity = context[\"representation\"]\n        path = self.filepath_from_context(context)\n        collections, remainder = clique.assemble(\n            os.listdir(os.path.dirname(path))\n        )\n        files = []\n        if collections:\n            for f in list(collections[0]):\n                files.append(\n                    os.path.join(\n                        os.path.dirname(path), f\n                    ).replace(\"\\\\\", \"/\")\n                )\n        else:\n            files.append(\n                os.path.join(\n                    os.path.dirname(path), remainder[0]\n                ).replace(\"\\\\\", \"/\")\n            )\n\n        harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Loaders.{self_name}.replaceFiles\",\n                \"args\": [files, node, 1]\n            }\n        )\n\n        # Colour node.\n        if is_representation_from_latest(repre_entity):\n            harmony.send(\n                {\n                    \"function\": \"AyonHarmony.setColor\",\n                    \"args\": [node, [0, 255, 0, 255]]\n                })\n        else:\n            harmony.send(\n                {\n                    \"function\": \"AyonHarmony.setColor\",\n                    \"args\": [node, [255, 0, 0, 255]]\n                })\n\n        harmony.imprint(\n            node, {\"representation\": repre_entity[\"id\"]}\n        )\n\n    def remove(self, container):\n        \"\"\"Remove loaded container.\n\n        Args:\n            container (dict): Container data.\n\n        \"\"\"\n        node = container.get(\"nodes\").pop()\n        harmony.send(\n            {\"function\": \"AyonHarmony.deleteNode\", \"args\": [node]}\n        )\n        harmony.imprint(node, {}, remove=True)\n\n    def switch(self, container, context):\n        \"\"\"Switch loaded representations.\"\"\"\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_imagesequence.html#client.ayon_harmony.plugins.load.load_imagesequence.ImageSequenceLoader.load","title":"<code>load(context, name=None, namespace=None, data=None)</code>","text":"<p>Plugin entry point.</p> <p>Parameters:</p> Name Type Description Default <code>context (</code> <p>class:<code>pyblish.api.Context</code>): Context.</p> required <code>name</code> <code>str</code> <p>Container name.</p> <code>None</code> <code>namespace</code> <code>str</code> <p>Container namespace.</p> <code>None</code> <code>data</code> <code>dict</code> <p>Additional data passed into loader.</p> <code>None</code> Source code in <code>client/ayon_harmony/plugins/load/load_imagesequence.py</code> <pre><code>def load(self, context, name=None, namespace=None, data=None):\n    \"\"\"Plugin entry point.\n\n    Args:\n        context (:class:`pyblish.api.Context`): Context.\n        name (str, optional): Container name.\n        namespace (str, optional): Container namespace.\n        data (dict, optional): Additional data passed into loader.\n\n    \"\"\"\n    fname = Path(self.filepath_from_context(context))\n    self_name = self.__class__.__name__\n    collections, remainder = clique.assemble(\n        os.listdir(fname.parent.as_posix())\n    )\n    files = []\n    if collections:\n        for f in list(collections[0]):\n            files.append(fname.parent.joinpath(f).as_posix())\n    else:\n        files.append(fname.parent.joinpath(remainder[0]).as_posix())\n\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    group_id = str(uuid.uuid4())\n    read_node = harmony.send(\n        {\n            \"function\": f\"AyonHarmony.Loaders.{self_name}.importFiles\",  # noqa: E501\n            \"args\": [\n                files,\n                folder_name,\n                product_name,\n                1,\n                group_id\n            ]\n        }\n    )[\"result\"]\n\n    return harmony.containerise(\n        f\"{folder_name}_{product_name}\",\n        namespace,\n        read_node,\n        context,\n        self_name,\n        nodes=[read_node]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_imagesequence.html#client.ayon_harmony.plugins.load.load_imagesequence.ImageSequenceLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove loaded container.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>dict</code> <p>Container data.</p> required Source code in <code>client/ayon_harmony/plugins/load/load_imagesequence.py</code> <pre><code>def remove(self, container):\n    \"\"\"Remove loaded container.\n\n    Args:\n        container (dict): Container data.\n\n    \"\"\"\n    node = container.get(\"nodes\").pop()\n    harmony.send(\n        {\"function\": \"AyonHarmony.deleteNode\", \"args\": [node]}\n    )\n    harmony.imprint(node, {}, remove=True)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_imagesequence.html#client.ayon_harmony.plugins.load.load_imagesequence.ImageSequenceLoader.switch","title":"<code>switch(container, context)</code>","text":"<p>Switch loaded representations.</p> Source code in <code>client/ayon_harmony/plugins/load/load_imagesequence.py</code> <pre><code>def switch(self, container, context):\n    \"\"\"Switch loaded representations.\"\"\"\n    self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_imagesequence.html#client.ayon_harmony.plugins.load.load_imagesequence.ImageSequenceLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update loaded containers.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>dict</code> <p>Container data.</p> required <code>context</code> <code>dict</code> <p>Representation context data.</p> required Source code in <code>client/ayon_harmony/plugins/load/load_imagesequence.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update loaded containers.\n\n    Args:\n        container (dict): Container data.\n        context (dict): Representation context data.\n\n    \"\"\"\n    self_name = self.__class__.__name__\n    node = container.get(\"nodes\").pop()\n\n    repre_entity = context[\"representation\"]\n    path = self.filepath_from_context(context)\n    collections, remainder = clique.assemble(\n        os.listdir(os.path.dirname(path))\n    )\n    files = []\n    if collections:\n        for f in list(collections[0]):\n            files.append(\n                os.path.join(\n                    os.path.dirname(path), f\n                ).replace(\"\\\\\", \"/\")\n            )\n    else:\n        files.append(\n            os.path.join(\n                os.path.dirname(path), remainder[0]\n            ).replace(\"\\\\\", \"/\")\n        )\n\n    harmony.send(\n        {\n            \"function\": f\"AyonHarmony.Loaders.{self_name}.replaceFiles\",\n            \"args\": [files, node, 1]\n        }\n    )\n\n    # Colour node.\n    if is_representation_from_latest(repre_entity):\n        harmony.send(\n            {\n                \"function\": \"AyonHarmony.setColor\",\n                \"args\": [node, [0, 255, 0, 255]]\n            })\n    else:\n        harmony.send(\n            {\n                \"function\": \"AyonHarmony.setColor\",\n                \"args\": [node, [255, 0, 0, 255]]\n            })\n\n    harmony.imprint(\n        node, {\"representation\": repre_entity[\"id\"]}\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_layers.html","title":"load_layers","text":"<p>Load image.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_layers.html#client.ayon_harmony.plugins.load.load_layers.PsdLoader","title":"<code>PsdLoader</code>","text":"<p>               Bases: <code>BackdropBaseLoader</code></p> <p>Load Photoshop file (.psd).</p> Source code in <code>client/ayon_harmony/plugins/load/load_layers.py</code> <pre><code>class PsdLoader(harmony.BackdropBaseLoader):\n    \"\"\"Load Photoshop file (.psd).\"\"\"\n\n    product_types = {\"image\"}\n    representations = {\"psd\"}\n    label = \"Load Photoshop Layers\"\n    icon = \"layers\"\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_palette.html","title":"load_palette","text":""},{"location":"autoapi/client/ayon_harmony/plugins/load/load_palette.html#client.ayon_harmony.plugins.load.load_palette.ImportPaletteLoader","title":"<code>ImportPaletteLoader</code>","text":"<p>               Bases: <code>LinkPaletteLoader</code></p> <p>Import a palette.</p> <p>Copy the palette to the scene directory and link it.</p> Source code in <code>client/ayon_harmony/plugins/load/load_palette.py</code> <pre><code>class ImportPaletteLoader(LinkPaletteLoader):\n    \"\"\"Import a palette.\n\n    Copy the palette to the scene directory and link it.\n    \"\"\"\n\n    label = \"Import Palette\"\n    representations = {\"plt\"}\n    icon = \"gift\"\n    order = 0.1\n\n    def load_palette(self, palette_path: str) -&gt; str:\n        \"\"\"Import the palette to the scene.\n\n        Copy the palette to the scene directory and link it.\n\n        Args:\n            palette_path (str): Path to the palette.\n\n        Returns:\n            str: Palette ID.\n        \"\"\"\n        scene_path = harmony.send(\n            {\"function\": \"scene.currentProjectPath\"}\n        )[\"result\"]\n\n        dst = Path(\n            scene_path,\n            \"palette-library\",\n            Path(palette_path).name,\n        )\n\n        self.log.info(f\"Copying palette to {dst}\")\n        shutil.copy(palette_path, dst)\n\n        return super().load_palette(dst.as_posix())\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_palette.html#client.ayon_harmony.plugins.load.load_palette.ImportPaletteLoader.load_palette","title":"<code>load_palette(palette_path)</code>","text":"<p>Import the palette to the scene.</p> <p>Copy the palette to the scene directory and link it.</p> <p>Parameters:</p> Name Type Description Default <code>palette_path</code> <code>str</code> <p>Path to the palette.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Palette ID.</p> Source code in <code>client/ayon_harmony/plugins/load/load_palette.py</code> <pre><code>def load_palette(self, palette_path: str) -&gt; str:\n    \"\"\"Import the palette to the scene.\n\n    Copy the palette to the scene directory and link it.\n\n    Args:\n        palette_path (str): Path to the palette.\n\n    Returns:\n        str: Palette ID.\n    \"\"\"\n    scene_path = harmony.send(\n        {\"function\": \"scene.currentProjectPath\"}\n    )[\"result\"]\n\n    dst = Path(\n        scene_path,\n        \"palette-library\",\n        Path(palette_path).name,\n    )\n\n    self.log.info(f\"Copying palette to {dst}\")\n    shutil.copy(palette_path, dst)\n\n    return super().load_palette(dst.as_posix())\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_palette.html#client.ayon_harmony.plugins.load.load_palette.LinkPaletteLoader","title":"<code>LinkPaletteLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Link a palette.</p> <p>Link the palette to the scene.</p> Source code in <code>client/ayon_harmony/plugins/load/load_palette.py</code> <pre><code>class LinkPaletteLoader(load.LoaderPlugin):\n    \"\"\"Link a palette.\n\n    Link the palette to the scene.\n    \"\"\"\n\n    label = \"Link Palette\"\n    product_types = {\"palette\", \"harmony.palette\"}\n    representations = {\"plt\"}\n    icon = \"link\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        representation = context[\"representation\"]\n        repre_filepath = self.filepath_from_context(context)\n        palette_path = self.load_palette(repre_filepath)\n\n        product_name = representation[\"context\"][\"product\"][\"name\"]\n        name = product_name.replace(\"palette\", \"\")\n\n        return harmony.containerise(\n            name,\n            namespace,\n            # Because of sh*tty Harmony API, the only consistent value is\n            #   the palette path palette[\"id\"] changes at every file opening\n            #   and the index can be modified by user\n            palette_path,\n            context,\n            self.__class__.__name__,\n            nodes=[palette_path],\n        )\n\n    def load_palette(self, palette_path: str) -&gt; str:\n        \"\"\"Link the palette to the scene.\n\n        Args:\n            palette_path (str): Path to the palette.\n\n        Returns:\n            str: Palette path.\n\n        \"\"\"\n        harmony.send(\n            {\n                \"function\": (\n                    \"PaletteObjectManager.getScenePaletteList().addPalette\"\n                ),\n                \"args\": Path(palette_path).with_suffix(\"\").as_posix(),\n            }\n        )[\"result\"]\n        return palette_path\n\n    def remove(self, container) -&gt; int:\n        \"\"\"Remove the palette from the scene.\n\n        Args:\n            container (dict): Container data.\n\n        Returns:\n            int: Removed palette index.\n        \"\"\"\n        palette_path = container[\"nodes\"][0]\n        removed_idx = harmony.send(\n            {\n                \"function\": \"AyonHarmony.removePaletteByPath\",\n                \"args\": palette_path,\n            }\n        )[\"result\"]\n        harmony.remove(palette_path)\n\n        return removed_idx\n\n    def switch(self, container, context):\n        palette_idx = self.remove(container)\n        palette_path = self.load(context)\n\n        # Move loaded palette to the index of the removed one\n        harmony.send(\n            {\n                \"function\": \"AyonHarmony.movePaletteToIndex\",\n                \"args\": [palette_path, palette_idx]\n            }\n        )\n\n    def update(self, container, context):\n        self.switch(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_palette.html#client.ayon_harmony.plugins.load.load_palette.LinkPaletteLoader.load_palette","title":"<code>load_palette(palette_path)</code>","text":"<p>Link the palette to the scene.</p> <p>Parameters:</p> Name Type Description Default <code>palette_path</code> <code>str</code> <p>Path to the palette.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Palette path.</p> Source code in <code>client/ayon_harmony/plugins/load/load_palette.py</code> <pre><code>def load_palette(self, palette_path: str) -&gt; str:\n    \"\"\"Link the palette to the scene.\n\n    Args:\n        palette_path (str): Path to the palette.\n\n    Returns:\n        str: Palette path.\n\n    \"\"\"\n    harmony.send(\n        {\n            \"function\": (\n                \"PaletteObjectManager.getScenePaletteList().addPalette\"\n            ),\n            \"args\": Path(palette_path).with_suffix(\"\").as_posix(),\n        }\n    )[\"result\"]\n    return palette_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_palette.html#client.ayon_harmony.plugins.load.load_palette.LinkPaletteLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove the palette from the scene.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>dict</code> <p>Container data.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Removed palette index.</p> Source code in <code>client/ayon_harmony/plugins/load/load_palette.py</code> <pre><code>def remove(self, container) -&gt; int:\n    \"\"\"Remove the palette from the scene.\n\n    Args:\n        container (dict): Container data.\n\n    Returns:\n        int: Removed palette index.\n    \"\"\"\n    palette_path = container[\"nodes\"][0]\n    removed_idx = harmony.send(\n        {\n            \"function\": \"AyonHarmony.removePaletteByPath\",\n            \"args\": palette_path,\n        }\n    )[\"result\"]\n    harmony.remove(palette_path)\n\n    return removed_idx\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_template.html","title":"load_template","text":"<p>Load template.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_template.html#client.ayon_harmony.plugins.load.load_template.TemplateLoader","title":"<code>TemplateLoader</code>","text":"<p>               Bases: <code>BackdropBaseLoader</code></p> <p>Load Harmony template as Backdrop container.</p> Source code in <code>client/ayon_harmony/plugins/load/load_template.py</code> <pre><code>class TemplateLoader(harmony.BackdropBaseLoader):\n    \"\"\"Load Harmony template as Backdrop container.\"\"\"\n\n    product_types = {\"harmony.template\"}\n    representations = {\"tpl\"}\n    label = \"Load Template\"\n    icon = \"gift\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        \"\"\"Plugin entry point.\n\n        Args:\n            context (:class:`pyblish.api.Context`): Context.\n            name (str, optional): Container name.\n            namespace (str, optional): Container namespace.\n            data (dict, optional): Additional data passed into loader.\n\n        \"\"\"\n        # Load template.\n        self_name = self.__class__.__name__\n        temp_dir = tempfile.mkdtemp()\n        zip_file = self.filepath_from_context(context)\n\n        with zipfile.ZipFile(zip_file, \"r\") as zip_ref:\n            zip_ref.extractall(temp_dir)\n\n        backdrop_name = harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Loaders.{self_name}.loadContainer\",\n                # Published tpl name is not consistent, use first found,\n                #   must be only one\n                \"args\": next(Path(temp_dir).glob(\"*.tpl\")).as_posix(),\n            }\n        )[\"result\"]\n\n        # Cleanup the temp directory\n        shutil.rmtree(temp_dir)\n\n        # We must validate the group_node\n        return harmony.containerise(\n            name,\n            namespace,\n            backdrop_name,\n            context,\n            self_name\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_template.html#client.ayon_harmony.plugins.load.load_template.TemplateLoader.load","title":"<code>load(context, name=None, namespace=None, data=None)</code>","text":"<p>Plugin entry point.</p> <p>Parameters:</p> Name Type Description Default <code>context (</code> <p>class:<code>pyblish.api.Context</code>): Context.</p> required <code>name</code> <code>str</code> <p>Container name.</p> <code>None</code> <code>namespace</code> <code>str</code> <p>Container namespace.</p> <code>None</code> <code>data</code> <code>dict</code> <p>Additional data passed into loader.</p> <code>None</code> Source code in <code>client/ayon_harmony/plugins/load/load_template.py</code> <pre><code>def load(self, context, name=None, namespace=None, data=None):\n    \"\"\"Plugin entry point.\n\n    Args:\n        context (:class:`pyblish.api.Context`): Context.\n        name (str, optional): Container name.\n        namespace (str, optional): Container namespace.\n        data (dict, optional): Additional data passed into loader.\n\n    \"\"\"\n    # Load template.\n    self_name = self.__class__.__name__\n    temp_dir = tempfile.mkdtemp()\n    zip_file = self.filepath_from_context(context)\n\n    with zipfile.ZipFile(zip_file, \"r\") as zip_ref:\n        zip_ref.extractall(temp_dir)\n\n    backdrop_name = harmony.send(\n        {\n            \"function\": f\"AyonHarmony.Loaders.{self_name}.loadContainer\",\n            # Published tpl name is not consistent, use first found,\n            #   must be only one\n            \"args\": next(Path(temp_dir).glob(\"*.tpl\")).as_posix(),\n        }\n    )[\"result\"]\n\n    # Cleanup the temp directory\n    shutil.rmtree(temp_dir)\n\n    # We must validate the group_node\n    return harmony.containerise(\n        name,\n        namespace,\n        backdrop_name,\n        context,\n        self_name\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_template_workfile.html","title":"load_template_workfile","text":""},{"location":"autoapi/client/ayon_harmony/plugins/load/load_template_workfile.html#client.ayon_harmony.plugins.load.load_template_workfile.ImportTemplateLoader","title":"<code>ImportTemplateLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Import Harmony workfiles.</p> Source code in <code>client/ayon_harmony/plugins/load/load_template_workfile.py</code> <pre><code>class ImportTemplateLoader(load.LoaderPlugin):\n    \"\"\"Import Harmony workfiles.\"\"\"\n\n    product_types = {\"workfile\"}\n    representations = {\"tpl\"}\n    label = \"Import Template\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        # Import template.\n        temp_dir = tempfile.mkdtemp()\n        zip_file = self.filepath_from_context(context)\n        template_path = os.path.join(temp_dir, \"temp.tpl\")\n        with zipfile.ZipFile(zip_file, \"r\") as zip_ref:\n            zip_ref.extractall(template_path)\n\n        sig = harmony.signature(\"paste\")\n        func = \"\"\"function %s(args)\n        {\n            var template_path = args[0];\n            var drag_object = copyPaste.pasteTemplateIntoGroup(\n                template_path, \"Top\", 1\n            );\n        }\n        %s\n        \"\"\" % (sig, sig)\n\n        harmony.send({\"function\": func, \"args\": [template_path]})\n\n        shutil.rmtree(temp_dir)\n\n        product_name = context[\"product\"][\"name\"]\n\n        return harmony.containerise(\n            product_name,\n            namespace,\n            product_name,\n            context,\n            self.__class__.__name__\n        )\n\n    def update(self, container, context):\n        pass\n\n    def remove(self, container):\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/load/load_template_workfile.html#client.ayon_harmony.plugins.load.load_template_workfile.ImportWorkfileLoader","title":"<code>ImportWorkfileLoader</code>","text":"<p>               Bases: <code>ImportTemplateLoader</code></p> <p>Import workfiles.</p> Source code in <code>client/ayon_harmony/plugins/load/load_template_workfile.py</code> <pre><code>class ImportWorkfileLoader(ImportTemplateLoader):\n    \"\"\"Import workfiles.\"\"\"\n\n    product_types = {\"workfile\"}\n    representations = {\"zip\"}\n    label = \"Import Workfile\"\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_audio.html","title":"collect_audio","text":""},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_audio.html#client.ayon_harmony.plugins.publish.collect_audio.CollectAudio","title":"<code>CollectAudio</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect relative path for audio file to instance.</p> <p>Harmony api <code>getSoundtrackAll</code> returns useless path to temp folder, for render on farm we look into 'audio' folder and select first file.</p> <p>Correct path needs to be calculated in <code>submit_harmony_deadline.py</code></p> Source code in <code>client/ayon_harmony/plugins/publish/collect_audio.py</code> <pre><code>class CollectAudio(pyblish.api.InstancePlugin):\n    \"\"\"\n        Collect relative path for audio file to instance.\n\n        Harmony api `getSoundtrackAll` returns useless path to temp folder,\n        for render on farm we look into 'audio' folder and select first file.\n\n        Correct path needs to be calculated in `submit_harmony_deadline.py`\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.499\n    label = \"Collect Audio\"\n    hosts = [\"harmony\"]\n    families = [\"render.farm\"]\n\n    def process(self, instance):\n        full_file_name = None\n        audio_dir = os.path.join(\n            os.path.dirname(instance.context.data.get(\"currentFile\")), 'audio')\n        if os.path.isdir(audio_dir):\n            for full_file_name in os.listdir(audio_dir):\n                file_name, file_ext = os.path.splitext(full_file_name)\n\n                if file_ext not in ['.wav', '.mp3', '.aiff']:\n                    self.log.error(\"Unsupported file {}.{}\".format(file_name,\n                                                                   file_ext))\n                    full_file_name = None\n\n        if full_file_name:\n            audio_file_path = os.path.join('audio', full_file_name)\n            self.log.debug(\"audio_file_path {}\".format(audio_file_path))\n            instance.data[\"audioFile\"] = audio_file_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_current_file.html","title":"collect_current_file","text":"<p>Collect information about current file.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_current_file.html#client.ayon_harmony.plugins.publish.collect_current_file.CollectCurrentFile","title":"<code>CollectCurrentFile</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Inject the current working file into context.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_current_file.py</code> <pre><code>class CollectCurrentFile(pyblish.api.ContextPlugin):\n    \"\"\"Inject the current working file into context.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.5\n    label = \"Current File\"\n    hosts = [\"harmony\"]\n\n    def process(self, context):\n        \"\"\"Inject the current working file.\"\"\"\n        self_name = self.__class__.__name__\n\n        current_file = harmony.send(\n            {\"function\": f\"AyonHarmony.Publish.{self_name}.collect\"})[\"result\"]\n        context.data[\"currentFile\"] = os.path.normpath(current_file)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_current_file.html#client.ayon_harmony.plugins.publish.collect_current_file.CollectCurrentFile.process","title":"<code>process(context)</code>","text":"<p>Inject the current working file.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_current_file.py</code> <pre><code>def process(self, context):\n    \"\"\"Inject the current working file.\"\"\"\n    self_name = self.__class__.__name__\n\n    current_file = harmony.send(\n        {\"function\": f\"AyonHarmony.Publish.{self_name}.collect\"})[\"result\"]\n    context.data[\"currentFile\"] = os.path.normpath(current_file)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_farm_render.html","title":"collect_farm_render","text":"<p>Collect data to render from scene.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_farm_render.html#client.ayon_harmony.plugins.publish.collect_farm_render.CollectFarmRender","title":"<code>CollectFarmRender</code>","text":"<p>               Bases: <code>AbstractCollectRender</code></p> <p>Gather all publishable renders.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_farm_render.py</code> <pre><code>class CollectFarmRender(publish.AbstractCollectRender):\n    \"\"\"Gather all publishable renders.\"\"\"\n\n    # https://docs.toonboom.com/help/harmony-17/premium/reference/node/output/write-node-image-formats.html\n    ext_mapping = {\n        \"tvg\": [\"TVG\"],\n        \"tga\": [\"TGA\", \"TGA4\", \"TGA3\", \"TGA1\"],\n        \"sgi\": [\"SGI\", \"SGI4\", \"SGA3\", \"SGA1\", \"SGIDP\", \"SGIDP4\", \"SGIDP3\"],\n        \"psd\": [\"PSD\", \"PSD1\", \"PSD3\", \"PSD4\", \"PSDDP\", \"PSDDP1\", \"PSDDP3\",\n                \"PSDDP4\"],\n        \"yuv\": [\"YUV\"],\n        \"pal\": [\"PAL\"],\n        \"scan\": [\"SCAN\"],\n        \"png\": [\"PNG\", \"PNG4\", \"PNGDP\", \"PNGDP3\", \"PNGDP4\"],\n        \"jpg\": [\"JPG\"],\n        \"bmp\": [\"BMP\", \"BMP4\"],\n        \"opt\": [\"OPT\", \"OPT1\", \"OPT3\", \"OPT4\"],\n        \"var\": [\"VAR\"],\n        \"tif\": [\"TIF\"],\n        \"dpx\": [\"DPX\", \"DPX3_8\", \"DPX3_10\", \"DPX3_12\", \"DPX3_16\",\n                \"DPX3_10_INVERTED_CHANNELS\", \"DPX3_12_INVERTED_CHANNELS\",\n                \"DPX3_16_INVERTED_CHANNELS\"],\n        \"exr\": [\"EXR\"],\n        \"pdf\": [\"PDF\"],\n        \"dtext\": [\"DTEX\"]\n    }\n\n    def get_expected_files(self, render_instance):\n        \"\"\"Get list of expected files to be rendered from Harmony.\n\n        This returns full path with file name determined by Write node\n        settings.\n        \"\"\"\n        start = render_instance.frameStart - render_instance.handleStart\n        end = render_instance.frameEnd + render_instance.handleEnd\n        node = render_instance.setMembers[0]\n        self_name = self.__class__.__name__\n        # 0 - filename / 1 - type / 2 - zeros / 3 - start\n        info = harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Publish.{self_name}.\"\n                            \"getRenderNodeSettings\",\n                \"args\": node\n            })[\"result\"]\n\n        ext = None\n        for k, v in self.ext_mapping.items():\n            if info[1] in v:\n                ext = k\n\n        if not ext:\n            raise AssertionError(\n                f\"Cannot determine file extension for {info[1]}\")\n\n        path = Path(render_instance.source).parent\n        # is sequence start node on write node offsetting whole sequence?\n        expected_files = []\n\n        # '-' in name is important for Harmony17\n        for frame in range(start, end + 1):\n            expected_files.append(\n                path / \"{}-{}.{}\".format(\n                    render_instance.productName,\n                    str(frame).rjust(int(info[2]) + 1, \"0\"),\n                    ext\n                )\n            )\n        self.log.debug(\"expected_files::{}\".format(expected_files))\n        return expected_files\n\n    def get_instances(self, context):\n        \"\"\"Get instances per Write node in `renderFarm` product type.\"\"\"\n        version = None\n        if self.sync_workfile_version:\n            version = context.data[\"version\"]\n\n        instances = []\n\n        self_name = self.__class__.__name__\n\n        folder_path = context.data[\"folderPath\"]\n\n        for inst in context:\n            if not inst.data.get(\"active\", True):\n                continue\n            creator_attributes = inst.data.get(\"creator_attributes\", {})\n            if creator_attributes.get(\"render_target\") != \"farm\":\n                continue\n\n            node = inst.data[\"transientData\"][\"node\"]\n            # 0 - filename / 1 - type / 2 - zeros / 3 - start / 4 - enabled\n            info = harmony.send(\n                {\n                    \"function\": f\"AyonHarmony.Publish.{self_name}.\"\n                                \"getRenderNodeSettings\",\n                    \"args\": node\n                })[\"result\"]\n\n            # TODO: handle pixel aspect and frame step\n            product_name = inst.data[\"productName\"]\n            task_name = inst.data.get(\"task\")\n\n            product_type = inst.data(\"productType\")\n            instance_families = inst.data.get(\"families\", [])\n\n            render_instance = HarmonyRenderInstance(\n                version=version,\n                time=get_formatted_current_time(),\n                source=context.data[\"currentFile\"],\n                name=product_name,\n                label=\"{} - {}\".format(product_name, product_type),\n                productName=product_name,\n                productType=product_type,\n                family=product_type,\n                families=instance_families,\n                farm=True,\n                folderPath=folder_path,\n                task=task_name,\n                attachTo=False,\n                setMembers=[node],\n                publish=info[4],\n                renderer=None,\n                priority=50,\n                resolutionWidth=context.data[\"resolutionWidth\"],\n                resolutionHeight=context.data[\"resolutionHeight\"],\n                pixelAspect=1.0,\n                multipartExr=False,\n                tileRendering=False,\n                tilesX=0,\n                tilesY=0,\n                convertToScanline=False,\n\n                # time settings\n                frameStart=context.data[\"frameStart\"],\n                frameEnd=context.data[\"frameEnd\"],\n                handleStart=context.data[\"handleStart\"],  # from DB\n                handleEnd=context.data[\"handleEnd\"],      # from DB\n                frameStep=1,\n                outputType=\"Image\",\n                outputFormat=info[1],\n                outputStartFrame=info[3],\n                leadingZeros=info[2],\n                ignoreFrameHandleCheck=True,\n                # The source instance this render instance replaces\n                source_instance=inst\n            )\n            render_instance.context = context\n            self.log.debug(render_instance)\n            instances.append(render_instance)\n\n        return instances\n\n    def add_additional_data(self, instance):\n        instance[\"FOV\"] = self._context.data[\"FOV\"]\n\n        return instance\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_farm_render.html#client.ayon_harmony.plugins.publish.collect_farm_render.CollectFarmRender.get_expected_files","title":"<code>get_expected_files(render_instance)</code>","text":"<p>Get list of expected files to be rendered from Harmony.</p> <p>This returns full path with file name determined by Write node settings.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_farm_render.py</code> <pre><code>def get_expected_files(self, render_instance):\n    \"\"\"Get list of expected files to be rendered from Harmony.\n\n    This returns full path with file name determined by Write node\n    settings.\n    \"\"\"\n    start = render_instance.frameStart - render_instance.handleStart\n    end = render_instance.frameEnd + render_instance.handleEnd\n    node = render_instance.setMembers[0]\n    self_name = self.__class__.__name__\n    # 0 - filename / 1 - type / 2 - zeros / 3 - start\n    info = harmony.send(\n        {\n            \"function\": f\"AyonHarmony.Publish.{self_name}.\"\n                        \"getRenderNodeSettings\",\n            \"args\": node\n        })[\"result\"]\n\n    ext = None\n    for k, v in self.ext_mapping.items():\n        if info[1] in v:\n            ext = k\n\n    if not ext:\n        raise AssertionError(\n            f\"Cannot determine file extension for {info[1]}\")\n\n    path = Path(render_instance.source).parent\n    # is sequence start node on write node offsetting whole sequence?\n    expected_files = []\n\n    # '-' in name is important for Harmony17\n    for frame in range(start, end + 1):\n        expected_files.append(\n            path / \"{}-{}.{}\".format(\n                render_instance.productName,\n                str(frame).rjust(int(info[2]) + 1, \"0\"),\n                ext\n            )\n        )\n    self.log.debug(\"expected_files::{}\".format(expected_files))\n    return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_farm_render.html#client.ayon_harmony.plugins.publish.collect_farm_render.CollectFarmRender.get_instances","title":"<code>get_instances(context)</code>","text":"<p>Get instances per Write node in <code>renderFarm</code> product type.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_farm_render.py</code> <pre><code>def get_instances(self, context):\n    \"\"\"Get instances per Write node in `renderFarm` product type.\"\"\"\n    version = None\n    if self.sync_workfile_version:\n        version = context.data[\"version\"]\n\n    instances = []\n\n    self_name = self.__class__.__name__\n\n    folder_path = context.data[\"folderPath\"]\n\n    for inst in context:\n        if not inst.data.get(\"active\", True):\n            continue\n        creator_attributes = inst.data.get(\"creator_attributes\", {})\n        if creator_attributes.get(\"render_target\") != \"farm\":\n            continue\n\n        node = inst.data[\"transientData\"][\"node\"]\n        # 0 - filename / 1 - type / 2 - zeros / 3 - start / 4 - enabled\n        info = harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Publish.{self_name}.\"\n                            \"getRenderNodeSettings\",\n                \"args\": node\n            })[\"result\"]\n\n        # TODO: handle pixel aspect and frame step\n        product_name = inst.data[\"productName\"]\n        task_name = inst.data.get(\"task\")\n\n        product_type = inst.data(\"productType\")\n        instance_families = inst.data.get(\"families\", [])\n\n        render_instance = HarmonyRenderInstance(\n            version=version,\n            time=get_formatted_current_time(),\n            source=context.data[\"currentFile\"],\n            name=product_name,\n            label=\"{} - {}\".format(product_name, product_type),\n            productName=product_name,\n            productType=product_type,\n            family=product_type,\n            families=instance_families,\n            farm=True,\n            folderPath=folder_path,\n            task=task_name,\n            attachTo=False,\n            setMembers=[node],\n            publish=info[4],\n            renderer=None,\n            priority=50,\n            resolutionWidth=context.data[\"resolutionWidth\"],\n            resolutionHeight=context.data[\"resolutionHeight\"],\n            pixelAspect=1.0,\n            multipartExr=False,\n            tileRendering=False,\n            tilesX=0,\n            tilesY=0,\n            convertToScanline=False,\n\n            # time settings\n            frameStart=context.data[\"frameStart\"],\n            frameEnd=context.data[\"frameEnd\"],\n            handleStart=context.data[\"handleStart\"],  # from DB\n            handleEnd=context.data[\"handleEnd\"],      # from DB\n            frameStep=1,\n            outputType=\"Image\",\n            outputFormat=info[1],\n            outputStartFrame=info[3],\n            leadingZeros=info[2],\n            ignoreFrameHandleCheck=True,\n            # The source instance this render instance replaces\n            source_instance=inst\n        )\n        render_instance.context = context\n        self.log.debug(render_instance)\n        instances.append(render_instance)\n\n    return instances\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_instances.html","title":"collect_instances","text":"<p>Collect instances in Harmony.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_instances.html#client.ayon_harmony.plugins.publish.collect_instances.CollectInstances","title":"<code>CollectInstances</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Gather instances by nodes metadata.</p> <p>This collector takes into account assets that are associated with a composite node and marked with a unique identifier.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_instances.py</code> <pre><code>class CollectInstances(pyblish.api.InstancePlugin):\n    \"\"\"Gather instances by nodes metadata.\n\n    This collector takes into account assets that are associated with\n    a composite node and marked with a unique identifier.\n    \"\"\"\n\n    label = \"Instances\"\n    order = pyblish.api.CollectorOrder - 0.4\n    hosts = [\"harmony\"]\n\n    product_type_mapping = {\n        \"render\": [],\n        \"harmony.template\": [],\n        \"palette\": [\"palette\"]\n    }\n    pair_media = True\n\n    def process(self, instance: pyblish.api.Instance):\n\n        # skip render farm product type as it is collected separately\n        product_type = instance.data[\"productType\"]\n        if product_type == \"workfile\":\n            return\n\n        node = instance.data[\"transientData\"][\"node\"]\n\n        instance.data[\"setMembers\"] = [node]\n\n        families = [product_type]\n\n        creator_attributes = instance.data.get(\"creator_attributes\", {})\n        if product_type == \"render\":\n            render_target = creator_attributes[\"render_target\"]\n            families.append(f\"render.{render_target}\")\n\n        families.extend(self.product_type_mapping.get(product_type, []))\n\n        mark_for_review = creator_attributes.get(\"mark_for_review\")\n        if mark_for_review:\n            families.append(\"review\")\n\n        instance.data[\"families\"] = families\n\n        # If set in plugin, pair the scene Version with\n        # thumbnails and review media.\n        if self.pair_media and product_type == \"scene\":\n            instance.context.data[\"scene_instance\"] = instance\n\n        # Produce diagnostic message for any graphical\n        # user interface interested in visualising it.\n        self.log.info(\n            \"Processed: \\\"{}\\\":\\n{}\".format(\n                instance.data[\"name\"],\n                json.dumps(instance.data, indent=4)\n            )\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_palettes.html","title":"collect_palettes","text":"<p>Collect palettes from Harmony.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_palettes.html#client.ayon_harmony.plugins.publish.collect_palettes.CollectPalettes","title":"<code>CollectPalettes</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Gather palettes from scene when publishing templates.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_palettes.py</code> <pre><code>class CollectPalettes(pyblish.api.ContextPlugin):\n    \"\"\"Gather palettes from scene when publishing templates.\"\"\"\n\n    label = \"Palettes\"\n    order = pyblish.api.CollectorOrder + 0.003\n    hosts = [\"harmony\"]\n\n    settings_category = \"harmony\"\n\n    # list of regexes for task names where collecting should happen\n    allowed_tasks = []\n\n    def process(self, context):\n        \"\"\"Collector entry point.\"\"\"\n        self_name = self.__class__.__name__\n        palettes = harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Publish.{self_name}.getPalettes\",\n                \"args\": True,\n            })[\"result\"]\n\n        # skip collecting if not in allowed task\n        if self.allowed_tasks:\n            task_name = context.data[\"task\"].lower()\n            if not any(\n                re.search(pattern, task_name)\n                for pattern in self.allowed_tasks\n            ):\n                self.log.info(\n                    \"Skipping collecting palettes, task is not in\"\n                    f\" allowed tasks: {self.allowed_tasks}\"\n                )\n                return\n\n        folder_path = context.data[\"folderPath\"]\n\n        product_type = \"harmony.palette\"\n        for name, palette_id in palettes.items():\n            instance = context.create_instance(name)\n            instance.data.update({\n                \"id\": palette_id,\n                \"productType\": product_type,\n                \"family\": product_type,\n                \"families\": [product_type],\n                \"folderPath\": folder_path,\n                # TODO use product name template to calculate product name\n                \"productName\": f\"palette{name}\"\n            })\n            self.log.info(\n                \"Created instance:\\n\" + json.dumps(\n                    instance.data, sort_keys=True, indent=4\n                )\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_palettes.html#client.ayon_harmony.plugins.publish.collect_palettes.CollectPalettes.process","title":"<code>process(context)</code>","text":"<p>Collector entry point.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_palettes.py</code> <pre><code>def process(self, context):\n    \"\"\"Collector entry point.\"\"\"\n    self_name = self.__class__.__name__\n    palettes = harmony.send(\n        {\n            \"function\": f\"AyonHarmony.Publish.{self_name}.getPalettes\",\n            \"args\": True,\n        })[\"result\"]\n\n    # skip collecting if not in allowed task\n    if self.allowed_tasks:\n        task_name = context.data[\"task\"].lower()\n        if not any(\n            re.search(pattern, task_name)\n            for pattern in self.allowed_tasks\n        ):\n            self.log.info(\n                \"Skipping collecting palettes, task is not in\"\n                f\" allowed tasks: {self.allowed_tasks}\"\n            )\n            return\n\n    folder_path = context.data[\"folderPath\"]\n\n    product_type = \"harmony.palette\"\n    for name, palette_id in palettes.items():\n        instance = context.create_instance(name)\n        instance.data.update({\n            \"id\": palette_id,\n            \"productType\": product_type,\n            \"family\": product_type,\n            \"families\": [product_type],\n            \"folderPath\": folder_path,\n            # TODO use product name template to calculate product name\n            \"productName\": f\"palette{name}\"\n        })\n        self.log.info(\n            \"Created instance:\\n\" + json.dumps(\n                instance.data, sort_keys=True, indent=4\n            )\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_scene.html","title":"collect_scene","text":"<p>Collect scene data.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_scene.html#client.ayon_harmony.plugins.publish.collect_scene.CollectScene","title":"<code>CollectScene</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect basic scene information.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_scene.py</code> <pre><code>class CollectScene(pyblish.api.ContextPlugin):\n    \"\"\"Collect basic scene information.\"\"\"\n\n    label = \"Scene Data\"\n    order = pyblish.api.CollectorOrder\n    hosts = [\"harmony\"]\n\n    def process(self, context):\n        \"\"\"Plugin entry point.\"\"\"\n        result = harmony.send(\n            {\n                \"function\": \"AyonHarmony.getSceneSettings\",\n                \"args\": []}\n        )[\"result\"]\n\n        context.data[\"applicationPath\"] = result[0]\n        context.data[\"scenePath\"] = os.path.join(\n            result[1], result[2] + \".xstage\")\n        context.data[\"frameRate\"] = result[3]\n        context.data[\"frameStartHandle\"] = result[4]\n        context.data[\"frameEndHandle\"] = result[5]\n        context.data[\"audioPath\"] = result[6]\n        context.data[\"resolutionWidth\"] = result[7]\n        context.data[\"resolutionHeight\"] = result[8]\n        context.data[\"FOV\"] = result[9]\n\n        # harmony always starts from 1. frame\n        # 1001 - 10010 &gt;&gt; 1 - 10\n        # frameStart, frameEnd already collected by global plugin\n        offset = context.data[\"frameStart\"] - 1\n        frame_start = context.data[\"frameStart\"] - offset\n        frames_count = context.data[\"frameEnd\"] - \\\n            context.data[\"frameStart\"] + 1\n\n        # increase by handleStart - real frame range\n        # frameStart != frameStartHandle with handle presence\n        context.data[\"frameStart\"] = int(frame_start) + \\\n            context.data[\"handleStart\"]\n        context.data[\"frameEnd\"] = int(frames_count) + \\\n            context.data[\"frameStart\"] - 1\n\n        all_nodes = harmony.send(\n            {\"function\": \"node.subNodes\", \"args\": [\"Top\"]}\n        )[\"result\"]\n\n        context.data[\"allNodes\"] = all_nodes\n\n        # collect all write nodes to be able disable them in Deadline\n        all_write_nodes = harmony.send(\n            {\"function\": \"node.getNodes\", \"args\": [\"WRITE\"]}\n        )[\"result\"]\n\n        context.data[\"all_write_nodes\"] = all_write_nodes\n\n        result = harmony.send(\n            {\n                \"function\": \"AyonHarmony.getVersion\",\n                \"args\": []}\n        )[\"result\"]\n        context.data[\"harmonyVersion\"] = \"{}.{}\".format(result[0], result[1])\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/collect_scene.html#client.ayon_harmony.plugins.publish.collect_scene.CollectScene.process","title":"<code>process(context)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_harmony/plugins/publish/collect_scene.py</code> <pre><code>def process(self, context):\n    \"\"\"Plugin entry point.\"\"\"\n    result = harmony.send(\n        {\n            \"function\": \"AyonHarmony.getSceneSettings\",\n            \"args\": []}\n    )[\"result\"]\n\n    context.data[\"applicationPath\"] = result[0]\n    context.data[\"scenePath\"] = os.path.join(\n        result[1], result[2] + \".xstage\")\n    context.data[\"frameRate\"] = result[3]\n    context.data[\"frameStartHandle\"] = result[4]\n    context.data[\"frameEndHandle\"] = result[5]\n    context.data[\"audioPath\"] = result[6]\n    context.data[\"resolutionWidth\"] = result[7]\n    context.data[\"resolutionHeight\"] = result[8]\n    context.data[\"FOV\"] = result[9]\n\n    # harmony always starts from 1. frame\n    # 1001 - 10010 &gt;&gt; 1 - 10\n    # frameStart, frameEnd already collected by global plugin\n    offset = context.data[\"frameStart\"] - 1\n    frame_start = context.data[\"frameStart\"] - offset\n    frames_count = context.data[\"frameEnd\"] - \\\n        context.data[\"frameStart\"] + 1\n\n    # increase by handleStart - real frame range\n    # frameStart != frameStartHandle with handle presence\n    context.data[\"frameStart\"] = int(frame_start) + \\\n        context.data[\"handleStart\"]\n    context.data[\"frameEnd\"] = int(frames_count) + \\\n        context.data[\"frameStart\"] - 1\n\n    all_nodes = harmony.send(\n        {\"function\": \"node.subNodes\", \"args\": [\"Top\"]}\n    )[\"result\"]\n\n    context.data[\"allNodes\"] = all_nodes\n\n    # collect all write nodes to be able disable them in Deadline\n    all_write_nodes = harmony.send(\n        {\"function\": \"node.getNodes\", \"args\": [\"WRITE\"]}\n    )[\"result\"]\n\n    context.data[\"all_write_nodes\"] = all_write_nodes\n\n    result = harmony.send(\n        {\n            \"function\": \"AyonHarmony.getVersion\",\n            \"args\": []}\n    )[\"result\"]\n    context.data[\"harmonyVersion\"] = \"{}.{}\".format(result[0], result[1])\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_convert_to_exr.html","title":"extract_convert_to_exr","text":"<p>Plugin converting png files from ExtractSequence into exrs.</p> Requires <p>ExtractSequence - source of PNG ExtractReview - review was already created so we can convert to any exr</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_convert_to_exr.html#client.ayon_harmony.plugins.publish.extract_convert_to_exr.CollectExrUserOptions","title":"<code>CollectExrUserOptions</code>","text":"<p>               Bases: <code>ContextPlugin</code>, <code>AYONPyblishPluginMixin</code></p> <p>Collect data for EXR conversion.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_convert_to_exr.py</code> <pre><code>class CollectExrUserOptions(\n    pyblish.api.ContextPlugin,\n    AYONPyblishPluginMixin\n):\n    \"\"\"Collect data for EXR conversion.\"\"\"\n    order = pyblish.api.CollectorOrder - 0.45\n    label = \"Collect Sequence EXR\"\n    hosts = [\"harmony\"]\n    settings_category = \"harmony\"\n\n    multichannel_exr = False\n    user_overrides = []\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        plugin_settins = get_plugin_settings(\n            ExtractConvertToEXR, project_settings, cls.log, \"harmony\"\n        )\n        apply_plugin_settings_automatically(\n            cls, plugin_settins, cls.log\n        )\n\n    @classmethod\n    def register_create_context_callbacks(cls, create_context):\n        create_context.add_value_changed_callback(cls._on_value_change)\n\n    @classmethod\n    def _on_value_change(cls, event):\n        event_data = event.data\n        create_context: CreateContext = event_data[\"create_context\"]\n        for change in event_data[\"changes\"]:\n            instance: Optional[CreatedInstance] = change[\"instance\"]\n            if instance is not None:\n                continue\n\n            value = change[\"changes\"]\n            for key in (\n                \"publish_attributes\",\n                cls.__name__,\n                \"convert_to_exr\",\n            ):\n                value = value.get(key)\n                if value is None:\n                    break\n\n            if value is not None:\n                create_context.set_context_publish_plugin_attr_defs(\n                    cls.__name__,\n                    cls.get_attr_defs_for_context(create_context)\n                )\n            break\n\n    @classmethod\n    def get_attr_defs_for_context(\n        cls, create_context: CreateContext\n    ) -&gt; list[AbstractAttrDef]:\n        has_create_exr = \"create_exr\" in cls.user_overrides\n        has_multichannel_exr = \"multichannel_exr\" in cls.user_overrides\n\n        if not has_create_exr and not has_multichannel_exr:\n            return []\n\n        items = []\n        if has_create_exr:\n            items.append({\"value\": \"skip_exr\", \"label\": \"No conversion\"})\n\n        default = \"create_exr\"\n        items.append({\"value\": \"create_exr\", \"label\": \"Create EXR\"})\n        if has_multichannel_exr:\n            items.append({\n                \"value\": \"multichannel_exr\",\n                \"label\": \"Create multichannel EXR\"\n            })\n            if cls.multichannel_exr:\n                default = \"multichannel_exr\"\n\n        attr_defs: list[AbstractAttrDef] = [\n            EnumDef(\n                \"convert_to_exr\",\n                label=\"Convert to EXR\",\n                items=items,\n                default=default,\n                tooltip=\"Convert PNGs to EXR\",\n            )\n        ]\n        current_value = (\n            create_context\n            .publish_attributes\n            .get(cls.__name__, {})\n            .get(\"convert_to_exr\")\n        )\n        if current_value is None:\n            current_value = default\n\n        if (\n            current_value == \"multichannel_exr\"\n            and \"keep_passes\" in cls.user_overrides\n        ):\n            attr_defs.append(\n                BoolDef(\n                    \"keep_passes\",\n                    default=False,\n                    label=\"Keep render passes\",\n                )\n            )\n\n        return attr_defs\n\n    def process(self, context):\n        attr_values = self.get_attr_values_from_data(context.data)\n        context.data[\"convertExrData\"] = {\n            \"user_value\": attr_values.get(\"convert_to_exr\"),\n            \"keep_passes\": attr_values.get(\"keep_passes\"),\n        }\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_palette.html","title":"extract_palette","text":"<p>Extract palette from Harmony.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_palette.html#client.ayon_harmony.plugins.publish.extract_palette.ExtractPalette","title":"<code>ExtractPalette</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract palette.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_palette.py</code> <pre><code>class ExtractPalette(publish.Extractor):\n    \"\"\"Extract palette.\"\"\"\n\n    label = \"Extract Palette\"\n    hosts = [\"harmony\"]\n    families = [\"harmony.palette\"]\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        self_name = self.__class__.__name__\n        result = harmony.send(\n            {\n                \"function\": f\"AyonHarmony.Publish.{self_name}.getPalette\",\n                \"args\": instance.data[\"id\"]\n            })[\"result\"]\n\n        if not isinstance(result, list):\n            self.log.error(f\"Invalid reply: {result}\")\n            raise AssertionError(\"Invalid reply from server.\")\n        palette_name = result[0]\n        palette_file = result[1]\n        self.log.info(f\"Got palette named {palette_name} \"\n                      f\"and file {palette_file}.\")\n\n        tmp_thumb_path = os.path.join(os.path.dirname(palette_file),\n                                      os.path.basename(palette_file)\n                                      .split(\".plt\")[0] + \"_swatches.png\"\n                                      )\n        self.log.info(f\"Temporary thumbnail path {tmp_thumb_path}\")\n\n        palette_version = str(instance.data.get(\"version\")).zfill(3)\n\n        self.log.info(f\"Palette version {palette_version}\")\n\n        if not instance.data.get(\"representations\"):\n            instance.data[\"representations\"] = []\n\n        try:\n            thumbnail_path = self.create_palette_thumbnail(palette_name,\n                                                           palette_version,\n                                                           palette_file,\n                                                           tmp_thumb_path)\n        except OSError as e:\n            # FIXME: this happens on Mac where PIL cannot access fonts\n            # for some reason.\n            self.log.warning(\"Thumbnail generation failed\")\n            self.log.warning(e)\n        except ValueError:\n            self.log.error(\"Unsupported palette type for thumbnail.\")\n\n        else:\n            thumbnail = {\n                \"name\": \"thumbnail\",\n                \"ext\": \"png\",\n                \"files\": os.path.basename(thumbnail_path),\n                \"stagingDir\": os.path.dirname(thumbnail_path),\n                \"tags\": [\"thumbnail\"]\n            }\n\n            instance.data[\"representations\"].append(thumbnail)\n\n        representation = {\n            \"name\": \"plt\",\n            \"ext\": \"plt\",\n            \"files\": os.path.basename(palette_file),\n            \"stagingDir\": os.path.dirname(palette_file)\n        }\n\n        instance.data[\"representations\"].append(representation)\n\n    def create_palette_thumbnail(self,\n                                 palette_name,\n                                 palette_version,\n                                 palette_path,\n                                 dst_path):\n        \"\"\"Create thumbnail for palette file.\n\n        Args:\n            palette_name (str): Name of palette.\n            palette_version (str): Version of palette.\n            palette_path (str): Path to palette file.\n            dst_path (str): Thumbnail path.\n\n        Returns:\n            str: Thumbnail path.\n\n        \"\"\"\n        colors = {}\n\n        with open(palette_path, newline='') as plt:\n            plt_parser = csv.reader(plt, delimiter=\" \")\n            for i, line in enumerate(plt_parser):\n                if i == 0:\n                    continue\n                while (\"\" in line):\n                    line.remove(\"\")\n                # self.log.debug(line)\n                if line[0] not in [\"Solid\"]:\n                    raise ValueError(\"Unsupported palette type.\")\n                color_name = line[1].strip('\"')\n                colors[color_name] = {\"type\": line[0],\n                                      \"uuid\": line[2],\n                                      \"rgba\": (int(line[3]),\n                                               int(line[4]),\n                                               int(line[5]),\n                                               int(line[6])),\n                                      }\n            plt.close()\n\n        img_pad_top = 80\n        label_pad_name = 30\n        label_pad_rgb = 580\n        swatch_pad_left = 300\n        swatch_pad_top = 10\n        swatch_w = 120\n        swatch_h = 50\n\n        image_w = 800\n        image_h = (img_pad_top +\n                   (len(colors.keys()) *\n                    swatch_h) +\n                   (swatch_pad_top *\n                    len(colors.keys()))\n                   )\n\n        img = Image.new(\"RGBA\", (image_w, image_h), \"white\")\n\n        # For bg of colors with alpha, create checkerboard image\n        checkers = Image.new(\"RGB\", (swatch_w, swatch_h))\n        pixels = checkers.load()\n\n        # Make pixels white where (row+col) is odd\n        for i in range(swatch_w):\n            for j in range(swatch_h):\n                if (i + j) % 2:\n                    pixels[i, j] = (255, 255, 255)\n\n        draw = ImageDraw.Draw(img)\n        # TODO: This needs to be font included with AYON because\n        # arial is not available on other platforms then Windows.\n        title_font = ImageFont.truetype(\"arial.ttf\", 28)\n        label_font = ImageFont.truetype(\"arial.ttf\", 20)\n\n        draw.text((label_pad_name, 20),\n                  \"{} (v{})\".format(palette_name, palette_version),\n                  \"black\",\n                  font=title_font)\n\n        for i, name in enumerate(colors):\n            rgba = colors[name][\"rgba\"]\n            # @TODO: Fix this so alpha colors are displayed with checkboard\n            # if not rgba[3] == \"255\":\n            #     img.paste(checkers,\n            #               (swatch_pad_left,\n            #                img_pad_top + swatch_pad_top + (i * swatch_h))\n            #               )\n            #\n            #     half_y = (img_pad_top + swatch_pad_top + (i * swatch_h))/2\n            #\n            #     draw.rectangle((\n            #         swatch_pad_left,  # upper LX\n            #         img_pad_top + swatch_pad_top + (i * swatch_h), # upper LY\n            #         swatch_pad_left + (swatch_w * 2),  # lower RX\n            #         half_y),  # lower RY\n            #         fill=rgba[:-1], outline=(0, 0, 0), width=2)\n            #     draw.rectangle((\n            #         swatch_pad_left,  # upper LX\n            #         half_y,  # upper LY\n            #         swatch_pad_left + (swatch_w * 2),  # lower RX\n            #         img_pad_top + swatch_h + (i * swatch_h)),  # lower RY\n            #         fill=rgba, outline=(0, 0, 0), width=2)\n            # else:\n\n            draw.rectangle((\n                swatch_pad_left,  # upper left x\n                img_pad_top + swatch_pad_top + (i * swatch_h),  # upper left y\n                swatch_pad_left + (swatch_w * 2),  # lower right x\n                img_pad_top + swatch_h + (i * swatch_h)),  # lower right y\n                fill=rgba, outline=(0, 0, 0), width=2)\n\n            draw.text((label_pad_name, img_pad_top + (i * swatch_h) + swatch_pad_top + (swatch_h / 4)),  # noqa: E501\n                      name,\n                      \"black\",\n                      font=label_font)\n\n            draw.text((label_pad_rgb, img_pad_top + (i * swatch_h) + swatch_pad_top + (swatch_h / 4)),  # noqa: E501\n                      str(rgba),\n                      \"black\",\n                      font=label_font)\n\n        draw = ImageDraw.Draw(img)\n\n        img.save(dst_path)\n        return dst_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_palette.html#client.ayon_harmony.plugins.publish.extract_palette.ExtractPalette.create_palette_thumbnail","title":"<code>create_palette_thumbnail(palette_name, palette_version, palette_path, dst_path)</code>","text":"<p>Create thumbnail for palette file.</p> <p>Parameters:</p> Name Type Description Default <code>palette_name</code> <code>str</code> <p>Name of palette.</p> required <code>palette_version</code> <code>str</code> <p>Version of palette.</p> required <code>palette_path</code> <code>str</code> <p>Path to palette file.</p> required <code>dst_path</code> <code>str</code> <p>Thumbnail path.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Thumbnail path.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_palette.py</code> <pre><code>def create_palette_thumbnail(self,\n                             palette_name,\n                             palette_version,\n                             palette_path,\n                             dst_path):\n    \"\"\"Create thumbnail for palette file.\n\n    Args:\n        palette_name (str): Name of palette.\n        palette_version (str): Version of palette.\n        palette_path (str): Path to palette file.\n        dst_path (str): Thumbnail path.\n\n    Returns:\n        str: Thumbnail path.\n\n    \"\"\"\n    colors = {}\n\n    with open(palette_path, newline='') as plt:\n        plt_parser = csv.reader(plt, delimiter=\" \")\n        for i, line in enumerate(plt_parser):\n            if i == 0:\n                continue\n            while (\"\" in line):\n                line.remove(\"\")\n            # self.log.debug(line)\n            if line[0] not in [\"Solid\"]:\n                raise ValueError(\"Unsupported palette type.\")\n            color_name = line[1].strip('\"')\n            colors[color_name] = {\"type\": line[0],\n                                  \"uuid\": line[2],\n                                  \"rgba\": (int(line[3]),\n                                           int(line[4]),\n                                           int(line[5]),\n                                           int(line[6])),\n                                  }\n        plt.close()\n\n    img_pad_top = 80\n    label_pad_name = 30\n    label_pad_rgb = 580\n    swatch_pad_left = 300\n    swatch_pad_top = 10\n    swatch_w = 120\n    swatch_h = 50\n\n    image_w = 800\n    image_h = (img_pad_top +\n               (len(colors.keys()) *\n                swatch_h) +\n               (swatch_pad_top *\n                len(colors.keys()))\n               )\n\n    img = Image.new(\"RGBA\", (image_w, image_h), \"white\")\n\n    # For bg of colors with alpha, create checkerboard image\n    checkers = Image.new(\"RGB\", (swatch_w, swatch_h))\n    pixels = checkers.load()\n\n    # Make pixels white where (row+col) is odd\n    for i in range(swatch_w):\n        for j in range(swatch_h):\n            if (i + j) % 2:\n                pixels[i, j] = (255, 255, 255)\n\n    draw = ImageDraw.Draw(img)\n    # TODO: This needs to be font included with AYON because\n    # arial is not available on other platforms then Windows.\n    title_font = ImageFont.truetype(\"arial.ttf\", 28)\n    label_font = ImageFont.truetype(\"arial.ttf\", 20)\n\n    draw.text((label_pad_name, 20),\n              \"{} (v{})\".format(palette_name, palette_version),\n              \"black\",\n              font=title_font)\n\n    for i, name in enumerate(colors):\n        rgba = colors[name][\"rgba\"]\n        # @TODO: Fix this so alpha colors are displayed with checkboard\n        # if not rgba[3] == \"255\":\n        #     img.paste(checkers,\n        #               (swatch_pad_left,\n        #                img_pad_top + swatch_pad_top + (i * swatch_h))\n        #               )\n        #\n        #     half_y = (img_pad_top + swatch_pad_top + (i * swatch_h))/2\n        #\n        #     draw.rectangle((\n        #         swatch_pad_left,  # upper LX\n        #         img_pad_top + swatch_pad_top + (i * swatch_h), # upper LY\n        #         swatch_pad_left + (swatch_w * 2),  # lower RX\n        #         half_y),  # lower RY\n        #         fill=rgba[:-1], outline=(0, 0, 0), width=2)\n        #     draw.rectangle((\n        #         swatch_pad_left,  # upper LX\n        #         half_y,  # upper LY\n        #         swatch_pad_left + (swatch_w * 2),  # lower RX\n        #         img_pad_top + swatch_h + (i * swatch_h)),  # lower RY\n        #         fill=rgba, outline=(0, 0, 0), width=2)\n        # else:\n\n        draw.rectangle((\n            swatch_pad_left,  # upper left x\n            img_pad_top + swatch_pad_top + (i * swatch_h),  # upper left y\n            swatch_pad_left + (swatch_w * 2),  # lower right x\n            img_pad_top + swatch_h + (i * swatch_h)),  # lower right y\n            fill=rgba, outline=(0, 0, 0), width=2)\n\n        draw.text((label_pad_name, img_pad_top + (i * swatch_h) + swatch_pad_top + (swatch_h / 4)),  # noqa: E501\n                  name,\n                  \"black\",\n                  font=label_font)\n\n        draw.text((label_pad_rgb, img_pad_top + (i * swatch_h) + swatch_pad_top + (swatch_h / 4)),  # noqa: E501\n                  str(rgba),\n                  \"black\",\n                  font=label_font)\n\n    draw = ImageDraw.Draw(img)\n\n    img.save(dst_path)\n    return dst_path\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_palette.html#client.ayon_harmony.plugins.publish.extract_palette.ExtractPalette.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_palette.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    self_name = self.__class__.__name__\n    result = harmony.send(\n        {\n            \"function\": f\"AyonHarmony.Publish.{self_name}.getPalette\",\n            \"args\": instance.data[\"id\"]\n        })[\"result\"]\n\n    if not isinstance(result, list):\n        self.log.error(f\"Invalid reply: {result}\")\n        raise AssertionError(\"Invalid reply from server.\")\n    palette_name = result[0]\n    palette_file = result[1]\n    self.log.info(f\"Got palette named {palette_name} \"\n                  f\"and file {palette_file}.\")\n\n    tmp_thumb_path = os.path.join(os.path.dirname(palette_file),\n                                  os.path.basename(palette_file)\n                                  .split(\".plt\")[0] + \"_swatches.png\"\n                                  )\n    self.log.info(f\"Temporary thumbnail path {tmp_thumb_path}\")\n\n    palette_version = str(instance.data.get(\"version\")).zfill(3)\n\n    self.log.info(f\"Palette version {palette_version}\")\n\n    if not instance.data.get(\"representations\"):\n        instance.data[\"representations\"] = []\n\n    try:\n        thumbnail_path = self.create_palette_thumbnail(palette_name,\n                                                       palette_version,\n                                                       palette_file,\n                                                       tmp_thumb_path)\n    except OSError as e:\n        # FIXME: this happens on Mac where PIL cannot access fonts\n        # for some reason.\n        self.log.warning(\"Thumbnail generation failed\")\n        self.log.warning(e)\n    except ValueError:\n        self.log.error(\"Unsupported palette type for thumbnail.\")\n\n    else:\n        thumbnail = {\n            \"name\": \"thumbnail\",\n            \"ext\": \"png\",\n            \"files\": os.path.basename(thumbnail_path),\n            \"stagingDir\": os.path.dirname(thumbnail_path),\n            \"tags\": [\"thumbnail\"]\n        }\n\n        instance.data[\"representations\"].append(thumbnail)\n\n    representation = {\n        \"name\": \"plt\",\n        \"ext\": \"plt\",\n        \"files\": os.path.basename(palette_file),\n        \"stagingDir\": os.path.dirname(palette_file)\n    }\n\n    instance.data[\"representations\"].append(representation)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_render.html","title":"extract_render","text":""},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_render.html#client.ayon_harmony.plugins.publish.extract_render.ExtractRender","title":"<code>ExtractRender</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Produce a flattened image file from instance. This plug-in only takes into account the nodes connected to the composite.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_render.py</code> <pre><code>class ExtractRender(pyblish.api.InstancePlugin):\n    \"\"\"Produce a flattened image file from instance.\n    This plug-in only takes into account the nodes connected to the composite.\n    \"\"\"\n\n    label = \"Extract Render\"\n    # TODO remove decrement after ayon-core ExtractThumbnailFromSource\n    #   is set later\n    order = pyblish.api.ExtractorOrder - 0.45\n    hosts = [\"harmony\"]\n    families = [\"render.local\"]\n\n    def process(self, instance):\n        # Collect scene data.\n        application_path = instance.context.data.get(\"applicationPath\")\n        scene_path = instance.context.data.get(\"scenePath\")\n        frame_rate = instance.context.data.get(\"frameRate\")\n        # real value from timeline\n        frame_start = instance.context.data.get(\"frameStartHandle\")\n        frame_end = instance.context.data.get(\"frameEndHandle\")\n        audio_path = instance.context.data.get(\"audioPath\")\n\n        if audio_path and os.path.exists(audio_path):\n            self.log.info(f\"Using audio from {audio_path}\")\n            instance.data[\"audio\"] = [{\"filename\": audio_path}]\n\n        instance.data[\"fps\"] = frame_rate\n\n        # Set output path to temp folder.\n        path = tempfile.mkdtemp()\n        sig = harmony.signature()\n        func = \"\"\"function %s(args)\n        {\n            node.setTextAttr(args[0], \"DRAWING_NAME\", 1, args[1]);\n        }\n        %s\n        \"\"\" % (sig, sig)\n\n        node = instance.data[\"setMembers\"][0]\n        filename = instance.data[\"name\"]\n        # Add underscode if basename ends with digits to make sure frame\n        #   number is separated from the name.\n        if filename[-1].isdigit():\n            filename += \"_\"\n        harmony.send(\n            {\n                \"function\": func,\n                \"args\": [node, f\"{path}/{filename}\"]\n            }\n        )\n        harmony.save_scene(zip_and_move=False)\n\n        # Execute rendering. Ignoring error cause Harmony returns error code\n        # always.\n\n        args = [\n            application_path, \"-batch\",\n            \"-frames\", str(frame_start), str(frame_end),\n            scene_path\n        ]\n        self.log.info(f\"running: {' '.join(args)}\")\n        proc = subprocess.Popen(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            stdin=subprocess.PIPE\n        )\n        stdout, _stderr = proc.communicate()\n        self.log.info(\"Click on the line below to see more details.\")\n        self.log.info(stdout.decode(\"utf-8\"))\n\n        # Collect rendered files.\n        self.log.debug(f\"collecting from: {path}\")\n        files = os.listdir(path)\n        if not files:\n            raise PublishError(\n                \"No rendered files found, render failed.\"\n            )\n\n        self.log.debug(f\"files there: {files}\")\n        collections, remainder = clique.assemble(files, minimum_items=1)\n        if remainder:\n            member = instance.data[\"setMembers\"][0]\n            raise KnownPublishError(\n                f\"There should not be a remainder for {member}: {remainder}\"\n            )\n\n        self.log.debug(collections)\n        collection = None\n        if len(collections) &gt; 1:\n            for col in collections:\n                if len(list(col)) &gt; 1:\n                    collection = col\n        else:\n            collection = collections[0]\n\n        if collection is None:\n            raise KnownPublishError(\n                \"Failed to find a collection with multiple files.\"\n            )\n\n        thumbnail_source = os.path.join(path, list(collections[0])[0])\n        instance.data[\"thumbnailSource\"] = thumbnail_source\n\n        # Generate representations.\n        extension = collection.tail[1:]\n        files = list(collection)\n        representation = {\n            \"name\": extension,\n            \"ext\": extension,\n            \"files\": files if len(files) &gt; 1 else files[0],\n            \"stagingDir\": path,\n            \"tags\": [\"review\"],\n            \"fps\": frame_rate\n        }\n        representations = [representation]\n\n        instance.data[\"representations\"] = representations\n\n        if audio_path and os.path.exists(audio_path):\n            instance.data[\"audio\"] = [{\"filename\": audio_path}]\n\n        # Required for extract_review plugin (L222 onwards).\n        instance.data[\"frameStart\"] = frame_start\n        instance.data[\"frameEnd\"] = frame_end\n        instance.data[\"fps\"] = frame_rate\n\n        self.log.info(f\"Extracted {instance} to {path}\")\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_review_source.html","title":"extract_review_source","text":"<p>Export content of Display node as .mov.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_review_source.html#client.ayon_harmony.plugins.publish.extract_review_source.ExtractSourceForReview","title":"<code>ExtractSourceForReview</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Use exporter to save .mov from Display node.</p> <p><code>review</code> product should be created automatically by <code>CreateReview</code> if enabled.</p> <p>This currently triggers only locally, not on farm.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_review_source.py</code> <pre><code>class ExtractSourceForReview(publish.Extractor):\n    \"\"\"Use exporter to save .mov from Display node.\n\n    `review` product should be created automatically by `CreateReview` if\n    enabled.\n\n    This currently triggers only locally, not on farm.\n    \"\"\"\n\n    label = \"Extract sources for Review\"\n    # TODO remove decrement after ayon-core ExtractThumbnailFromSource\n    #   is set later\n    order = pyblish.api.ExtractorOrder - 0.45\n    hosts = [\"harmony\"]\n    families = [\"review\"]\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        if instance.data[\"productType\"] != \"review\":\n            self.log.info(\"Not primary `review` product type, skipping.\")\n            return\n\n        staging_dir = self.staging_dir(instance)\n        file_name = f\"{instance.name}.mov\"\n        filepath = os.path.join(staging_dir, file_name)\n        self.log.info(f\"Exporting to {filepath}\")\n\n        sig = harmony.signature()\n\n        display_node_name = instance.data[\"display_node_name\"]\n\n        func = \"\"\"function %s(args)\n        {\n            var codec = \"openH264\";\n            var startFrame = -1; // take from timeline\n            var endFrame = -1; // take from timeline\n            var withSound = true;\n            var resX = -1; //take from scene\n            var resY = -1;\n            var saveTo = args[0];\n            var displayToRender = args[1];\n            var generateThumbnail = false;\n            var thumbnailFrame = 0;\n            exporter.exportToQuicktime(\n                codec,\n                startFrame,\n                endFrame,\n                withSound,\n                resX,\n                resY,\n                saveTo,\n                displayToRender,\n                generateThumbnail,\n                thumbnailFrame\n            )\n        }\n        %s\n        \"\"\" % (sig, sig)\n        harmony.send(\n            {\n                \"function\": func,\n                \"args\": [filepath, display_node_name]\n            }\n        )\n\n        # for global ExtractReview\n        context = instance.context\n        instance.data[\"frameStart\"] = context.data[\"frameStart\"]\n        instance.data[\"frameEnd\"] = context.data[\"frameEnd\"]\n        instance.data[\"fps\"] = context.data[\"fps\"]\n\n        representation = {\n            \"name\": \"mov\",\n            \"ext\": \"mov\",\n            \"files\": file_name,\n            \"stagingDir\": staging_dir,\n            \"tags\": [\"review\", \"delete\"]\n        }\n\n        instance.data[\"representations\"] = [representation]\n        instance.data[\"thumbnailSource\"] = filepath\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_review_source.html#client.ayon_harmony.plugins.publish.extract_review_source.ExtractSourceForReview.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_review_source.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    if instance.data[\"productType\"] != \"review\":\n        self.log.info(\"Not primary `review` product type, skipping.\")\n        return\n\n    staging_dir = self.staging_dir(instance)\n    file_name = f\"{instance.name}.mov\"\n    filepath = os.path.join(staging_dir, file_name)\n    self.log.info(f\"Exporting to {filepath}\")\n\n    sig = harmony.signature()\n\n    display_node_name = instance.data[\"display_node_name\"]\n\n    func = \"\"\"function %s(args)\n    {\n        var codec = \"openH264\";\n        var startFrame = -1; // take from timeline\n        var endFrame = -1; // take from timeline\n        var withSound = true;\n        var resX = -1; //take from scene\n        var resY = -1;\n        var saveTo = args[0];\n        var displayToRender = args[1];\n        var generateThumbnail = false;\n        var thumbnailFrame = 0;\n        exporter.exportToQuicktime(\n            codec,\n            startFrame,\n            endFrame,\n            withSound,\n            resX,\n            resY,\n            saveTo,\n            displayToRender,\n            generateThumbnail,\n            thumbnailFrame\n        )\n    }\n    %s\n    \"\"\" % (sig, sig)\n    harmony.send(\n        {\n            \"function\": func,\n            \"args\": [filepath, display_node_name]\n        }\n    )\n\n    # for global ExtractReview\n    context = instance.context\n    instance.data[\"frameStart\"] = context.data[\"frameStart\"]\n    instance.data[\"frameEnd\"] = context.data[\"frameEnd\"]\n    instance.data[\"fps\"] = context.data[\"fps\"]\n\n    representation = {\n        \"name\": \"mov\",\n        \"ext\": \"mov\",\n        \"files\": file_name,\n        \"stagingDir\": staging_dir,\n        \"tags\": [\"review\", \"delete\"]\n    }\n\n    instance.data[\"representations\"] = [representation]\n    instance.data[\"thumbnailSource\"] = filepath\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_save_scene.html","title":"extract_save_scene","text":""},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_save_scene.html#client.ayon_harmony.plugins.publish.extract_save_scene.ExtractSaveScene","title":"<code>ExtractSaveScene</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Save scene for extraction.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_save_scene.py</code> <pre><code>class ExtractSaveScene(pyblish.api.ContextPlugin):\n    \"\"\"Save scene for extraction.\"\"\"\n\n    label = \"Extract Save Scene\"\n    order = pyblish.api.ExtractorOrder - 0.49\n    hosts = [\"harmony\"]\n\n    def process(self, context):\n        harmony.save_scene(zip_and_move=True)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_template.html","title":"extract_template","text":"<p>Extract template.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_template.html#client.ayon_harmony.plugins.publish.extract_template.ExtractTemplate","title":"<code>ExtractTemplate</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract the connected nodes to the composite instance.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_template.py</code> <pre><code>class ExtractTemplate(publish.Extractor):\n    \"\"\"Extract the connected nodes to the composite instance.\"\"\"\n\n    label = \"Extract Template\"\n    hosts = [\"harmony\"]\n    families = [\"harmony.template\"]\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        staging_dir = self.staging_dir(instance)\n        filepath = os.path.join(staging_dir, \"harmony\", f\"{instance.name}.tpl\")\n\n        self.log.info(f\"Outputting template to {staging_dir}\")\n\n        # Export template\n        self.log.info(f'{instance.data[\"setMembers\"][0]}')\n        harmony.export_backdrop_as_template(\n            instance.data[\"setMembers\"][0], filepath\n        )\n\n        # Prep representation.\n        os.chdir(staging_dir)\n        shutil.make_archive(\n            f\"{instance.name}\",\n            \"zip\",\n            os.path.join(staging_dir, \"harmony\"),\n        )\n\n        representation = {\n            \"name\": \"tpl\",\n            \"ext\": \"zip\",\n            \"files\": f\"{instance.name}.zip\",\n            \"stagingDir\": staging_dir\n        }\n\n        self.log.info(instance.data.get(\"representations\"))\n        if instance.data.get(\"representations\"):\n            instance.data[\"representations\"].extend([representation])\n        else:\n            instance.data[\"representations\"] = [representation]\n\n        instance.data[\"version_name\"] = \"{}_{}\".format(\n            instance.data[\"productName\"],\n            instance.context.data[\"task\"]\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_template.html#client.ayon_harmony.plugins.publish.extract_template.ExtractTemplate.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_template.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    staging_dir = self.staging_dir(instance)\n    filepath = os.path.join(staging_dir, \"harmony\", f\"{instance.name}.tpl\")\n\n    self.log.info(f\"Outputting template to {staging_dir}\")\n\n    # Export template\n    self.log.info(f'{instance.data[\"setMembers\"][0]}')\n    harmony.export_backdrop_as_template(\n        instance.data[\"setMembers\"][0], filepath\n    )\n\n    # Prep representation.\n    os.chdir(staging_dir)\n    shutil.make_archive(\n        f\"{instance.name}\",\n        \"zip\",\n        os.path.join(staging_dir, \"harmony\"),\n    )\n\n    representation = {\n        \"name\": \"tpl\",\n        \"ext\": \"zip\",\n        \"files\": f\"{instance.name}.zip\",\n        \"stagingDir\": staging_dir\n    }\n\n    self.log.info(instance.data.get(\"representations\"))\n    if instance.data.get(\"representations\"):\n        instance.data[\"representations\"].extend([representation])\n    else:\n        instance.data[\"representations\"] = [representation]\n\n    instance.data[\"version_name\"] = \"{}_{}\".format(\n        instance.data[\"productName\"],\n        instance.context.data[\"task\"]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_workfile.html","title":"extract_workfile","text":"<p>Extract work file.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_workfile.html#client.ayon_harmony.plugins.publish.extract_workfile.ExtractWorkfile","title":"<code>ExtractWorkfile</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract and zip complete workfile folder into zip.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_workfile.py</code> <pre><code>class ExtractWorkfile(publish.Extractor):\n    \"\"\"Extract and zip complete workfile folder into zip.\"\"\"\n\n    label = \"Extract Workfile\"\n    hosts = [\"harmony\"]\n    families = [\"workfile\"]\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        staging_dir = self.staging_dir(instance)\n        filepath = os.path.join(staging_dir, \"{}.tpl\".format(instance.name))\n        src = os.path.dirname(instance.context.data[\"currentFile\"])\n        # handle too long paths on windows\n        current_platform = platform.system().lower()\n        if current_platform == \"windows\":\n            src = fr\"\\\\?\\{src}\"\n            filepath = fr\"\\\\?\\{filepath}\"\n        self.log.info(f\"Copying to {filepath}\")\n        shutil.copytree(src, filepath)\n\n        # Prep representation.\n        os.chdir(staging_dir)\n        shutil.make_archive(\n            f\"{instance.name}\",\n            \"zip\",\n            os.path.join(staging_dir, f\"{instance.name}.tpl\")\n        )\n        # Check if archive is ok\n        with ZipFile(os.path.basename(f\"{instance.name}.zip\")) as zr:\n            if zr.testzip() is not None:\n                raise Exception(\"File archive is corrupted.\")\n\n        representation = {\n            \"name\": \"tpl\",\n            \"ext\": \"zip\",\n            \"files\": f\"{instance.name}.zip\",\n            \"stagingDir\": staging_dir\n        }\n        instance.data[\"representations\"] = [representation]\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/extract_workfile.html#client.ayon_harmony.plugins.publish.extract_workfile.ExtractWorkfile.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_harmony/plugins/publish/extract_workfile.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    staging_dir = self.staging_dir(instance)\n    filepath = os.path.join(staging_dir, \"{}.tpl\".format(instance.name))\n    src = os.path.dirname(instance.context.data[\"currentFile\"])\n    # handle too long paths on windows\n    current_platform = platform.system().lower()\n    if current_platform == \"windows\":\n        src = fr\"\\\\?\\{src}\"\n        filepath = fr\"\\\\?\\{filepath}\"\n    self.log.info(f\"Copying to {filepath}\")\n    shutil.copytree(src, filepath)\n\n    # Prep representation.\n    os.chdir(staging_dir)\n    shutil.make_archive(\n        f\"{instance.name}\",\n        \"zip\",\n        os.path.join(staging_dir, f\"{instance.name}.tpl\")\n    )\n    # Check if archive is ok\n    with ZipFile(os.path.basename(f\"{instance.name}.zip\")) as zr:\n        if zr.testzip() is not None:\n            raise Exception(\"File archive is corrupted.\")\n\n    representation = {\n        \"name\": \"tpl\",\n        \"ext\": \"zip\",\n        \"files\": f\"{instance.name}.zip\",\n        \"stagingDir\": staging_dir\n    }\n    instance.data[\"representations\"] = [representation]\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/increment_workfile.html","title":"increment_workfile","text":""},{"location":"autoapi/client/ayon_harmony/plugins/publish/increment_workfile.html#client.ayon_harmony.plugins.publish.increment_workfile.IncrementWorkfile","title":"<code>IncrementWorkfile</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Increment the current workfile.</p> <p>Saves the current scene with an increased version number in both local unzipped folder and creates zipped file in <code>work</code> area.</p> <p>Marks current unzipped folder with lower version to be deleted afterwards. It should be obsolete as it is fully copied to incremented folder.</p> Source code in <code>client/ayon_harmony/plugins/publish/increment_workfile.py</code> <pre><code>class IncrementWorkfile(pyblish.api.InstancePlugin):\n    \"\"\"Increment the current workfile.\n\n    Saves the current scene with an increased version number in both\n    local unzipped folder and creates zipped file in `work` area.\n\n    Marks current unzipped folder with lower version to be deleted afterwards.\n    It should be obsolete as it is fully copied to incremented folder.\n    \"\"\"\n\n    label = \"Increment Workfile\"\n    order = pyblish.api.IntegratorOrder + 9.0\n    hosts = [\"harmony\"]\n    families = [\"workfile\"]\n    optional = True\n\n    def process(self, instance):\n        errored_plugins = get_errored_plugins_from_context(instance.context)\n        if errored_plugins:\n            raise RuntimeError(\n                \"Skipping incrementing current file because publishing failed.\"\n            )\n\n        context = instance.context\n        host: IWorkfileHost = registered_host()\n\n        current_filepath: str = context.data[\"currentFile\"]\n\n        current_filename = os.path.basename(current_filepath)\n        current_local_dir = os.path.dirname(current_filepath)\n        save_next_version(\n            description=(\n                f\"Incremented by publishing from {current_filename}\"\n            ),\n            # Optimize the save by reducing needed queries for context\n            prepared_data=SaveWorkfileOptionalData(\n                project_entity=context.data[\"projectEntity\"],\n                project_settings=context.data[\"project_settings\"],\n                anatomy=context.data[\"anatomy\"],\n            )\n        )\n        new_scene_path = host.get_current_workfile()\n\n        # Mark unzipped temp workfile to be deleted\n        instance.context.data[\"cleanupFullPaths\"].append(current_local_dir)\n\n        self.log.info(\"Incremented workfile to: {}\".format(new_scene_path))\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_audio.html","title":"validate_audio","text":""},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_audio.html#client.ayon_harmony.plugins.publish.validate_audio.ValidateAudio","title":"<code>ValidateAudio</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensures that there is an audio file in the scene.</p> <p>If you are sure that you want to send render without audio, you can disable this validator before clicking on \"publish\"</p> Source code in <code>client/ayon_harmony/plugins/publish/validate_audio.py</code> <pre><code>class ValidateAudio(\n    pyblish.api.InstancePlugin,\n    OptionalPyblishPluginMixin,\n):\n    \"\"\"Ensures that there is an audio file in the scene.\n\n    If you are sure that you want to send render without audio, you can\n    disable this validator before clicking on \"publish\"\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Audio\"\n    families = [\"render\"]\n    hosts = [\"harmony\"]\n    settings_category = \"harmony\"\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        node = None\n        if instance.data.get(\"setMembers\"):\n            node = instance.data[\"setMembers\"][0]\n\n        if not node:\n            return\n\n        sound_cols = harmony.send(\n            {\"function\": \"column.getColumnListOfType\", \"args\": \"SOUND\"}\n        )[\"result\"]\n\n        if not sound_cols:\n            raise PublishXmlValidationError(\n                self, \"No sound file imported in scene.\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_instances.html","title":"validate_instances","text":""},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_instances.html#client.ayon_harmony.plugins.publish.validate_instances.ValidateInstance","title":"<code>ValidateInstance</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate the instance folder is the current folder.</p> Source code in <code>client/ayon_harmony/plugins/publish/validate_instances.py</code> <pre><code>class ValidateInstance(\n    pyblish.api.InstancePlugin,\n    OptionalPyblishPluginMixin,\n):\n    \"\"\"Validate the instance folder is the current folder.\"\"\"\n\n    label = \"Validate Instance\"\n    hosts = [\"harmony\"]\n    actions = [ValidateInstanceRepair]\n    order = ValidateContentsOrder\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        instance_folder_path = instance.data[\"folderPath\"]\n        current_folder_path = get_current_folder_path()\n        msg = (\n            \"Instance folder is not the same as current folder:\"\n            f\"\\nInstance: {instance_folder_path}]\"\n            f\"\\nCurrent: {current_folder_path}\"\n        )\n\n        formatting_data = {\n            \"found\": instance_folder_path,\n            \"expected\": current_folder_path\n        }\n        if instance_folder_path != current_folder_path:\n            raise PublishXmlValidationError(\n                self, msg, formatting_data=formatting_data\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_instances.html#client.ayon_harmony.plugins.publish.validate_instances.ValidateInstanceRepair","title":"<code>ValidateInstanceRepair</code>","text":"<p>               Bases: <code>Action</code></p> <p>Repair the instance.</p> Source code in <code>client/ayon_harmony/plugins/publish/validate_instances.py</code> <pre><code>class ValidateInstanceRepair(pyblish.api.Action):\n    \"\"\"Repair the instance.\"\"\"\n\n    label = \"Repair\"\n    icon = \"wrench\"\n    on = \"failed\"\n\n    def process(self, context, plugin):\n        # Get the errored instances\n        failed = []\n        for result in context.data[\"results\"]:\n            instance = result[\"instance\"]\n            if (\n                result[\"error\"] is not None\n                and instance is not None\n                and instance not in failed\n            ):\n                failed.append(instance)\n\n        # Apply pyblish.logic to get the instances for the plug-in\n        instances = pyblish.api.instances_by_plugin(failed, plugin)\n\n        folder_path = get_current_folder_path()\n        for instance in instances:\n            data = harmony.read(instance.data[\"setMembers\"][0])\n            data[\"folderPath\"] = folder_path\n            harmony.imprint(instance.data[\"setMembers\"][0], data)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_review_source.html","title":"validate_review_source","text":""},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_review_source.html#client.ayon_harmony.plugins.publish.validate_review_source.ValidateTopDisplay","title":"<code>ValidateTopDisplay</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Ensures that there is a display node with <code>Top/Display</code>.</p> <p>This validator is used for simplified review creation workflow.</p> <p>It requires <code>ayon+settings://harmony/create/CreateReview</code> to be enabled. This creator produces instance of <code>review</code> product type, artist does not need create any instance manually if they have a <code>Top/Display</code> node in the scene.</p> Source code in <code>client/ayon_harmony/plugins/publish/validate_review_source.py</code> <pre><code>class ValidateTopDisplay(pyblish.api.InstancePlugin):\n    \"\"\"Ensures that there is a display node with `Top/Display`.\n\n    This validator is used for simplified review creation workflow.\n\n    It requires `ayon+settings://harmony/create/CreateReview` to be enabled.\n    This creator produces instance of `review` product type, artist does not\n    need create any instance manually if they have a `Top/Display` node\n    in the scene.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Top Display\"\n    families = [\"review\"]\n    hosts = [\"harmony\"]\n    settings_category = \"harmony\"\n\n    def process(self, instance):\n        if instance.data[\"productType\"] != \"review\":\n            self.log.debug(\"Not primary `review` product type, skipping.\")\n            return\n\n        display_node_name = harmony.send(\n            {\"function\": \"node.getName\", \"args\": \"Top/Display\"}\n        )[\"result\"]\n\n        if not display_node_name:\n            raise PublishXmlValidationError(\n                self, \"No display node named 'Top/Display'.\"\n            )\n\n        instance.data[\"display_node_name\"] = display_node_name\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_scene_settings.html","title":"validate_scene_settings","text":"<p>Validate scene settings.</p>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_scene_settings.html#client.ayon_harmony.plugins.publish.validate_scene_settings.ValidateSceneSettings","title":"<code>ValidateSceneSettings</code>","text":"<p>               Bases: <code>OptionalPyblishPluginMixin</code>, <code>InstancePlugin</code></p> <p>Ensure the scene settings are in sync with database.</p> Source code in <code>client/ayon_harmony/plugins/publish/validate_scene_settings.py</code> <pre><code>class ValidateSceneSettings(\n    OptionalPyblishPluginMixin,\n    pyblish.api.InstancePlugin\n):\n    \"\"\"Ensure the scene settings are in sync with database.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Scene Settings\"\n    families = [\"workfile\"]\n    hosts = [\"harmony\"]\n    actions = [ValidateSceneSettingsRepair]\n    settings_category = \"harmony\"\n    optional = True\n\n    # skip frameEnd check if folder contains any of:\n    frame_check_filter = [\"_ch_\", \"_pr_\", \"_intd_\", \"_extd_\"]  # regex\n\n    # skip resolution check if Task name matches any of regex patterns\n    skip_resolution_check = [\"render\", \"Render\"]  # regex\n\n    # skip frameStart, frameEnd check if Task name matches any of regex patt.\n    skip_timelines_check = []  # regex\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        if not self.is_active(instance.data):\n            return\n\n        # TODO 'get_current_context_settings' could expect folder entity\n        #   as an argument which is available on 'context.data[\"folderEntity\"]'\n        #   - the same approach can be used in 'ValidateSceneSettingsRepair'\n        expected_settings = harmony.get_current_context_settings()\n        self.log.debug(f\"Scene settings from DB:{expected_settings}\")\n\n        _update_frames(expected_settings)\n        expected_settings[\"frameEndHandle\"] = (\n            expected_settings[\"frameEnd\"] + expected_settings[\"handleEnd\"]\n        )\n\n        task_name = instance.context.data[\"task\"]\n\n        if any(\n            re.search(pattern, task_name)\n            for pattern in self.skip_resolution_check\n        ):\n            self.log.info(\n                \"Skipping resolution check because of task name\"\n                f\" and pattern {self.skip_resolution_check}\"\n            )\n            expected_settings.pop(\"resolutionWidth\")\n            expected_settings.pop(\"resolutionHeight\")\n\n        if any(\n            re.search(pattern, task_name)\n            for pattern in self.skip_timelines_check\n        ):\n            self.log.info(\n                \"Skipping frames check because of task name\"\n                f\" and pattern {self.skip_timelines_check}\"\n            )\n            expected_settings.pop(\"frameStart\", None)\n            expected_settings.pop(\"frameEnd\", None)\n            expected_settings.pop(\"frameStartHandle\", None)\n            expected_settings.pop(\"frameEndHandle\", None)\n\n        folder_name = instance.context.data[\"folderPath\"].rsplit(\"/\", 1)[-1]\n        if any(re.search(pattern, folder_name)\n                for pattern in self.frame_check_filter):\n            self.log.info(\n                \"Skipping frames check because of task name\"\n                f\" and pattern {self.frame_check_filter}\"\n            )\n            expected_settings.pop('frameStart', None)\n            expected_settings.pop('frameEnd', None)\n            expected_settings.pop('frameStartHandle', None)\n            expected_settings.pop('frameEndHandle', None)\n\n        # handle case when fps uses only two decimal places\n        # 23.976023976023978 vs. 23.98\n        fps = instance.context.data.get(\"frameRate\")\n        if isinstance(instance.context.data.get(\"frameRate\"), float):\n            fps = float(\n                \"{:.2f}\".format(instance.context.data.get(\"frameRate\")))\n\n        self.log.debug(\"filtered settings: {}\".format(expected_settings))\n\n        current_settings = {\n            \"fps\": fps,\n            \"frameStart\": instance.context.data[\"frameStart\"],\n            \"frameEnd\": instance.context.data[\"frameEnd\"],\n            \"handleStart\": instance.context.data.get(\"handleStart\"),\n            \"handleEnd\": instance.context.data.get(\"handleEnd\"),\n            \"frameStartHandle\": instance.context.data.get(\"frameStartHandle\"),\n            \"frameEndHandle\": instance.context.data.get(\"frameEndHandle\"),\n            \"resolutionWidth\": instance.context.data.get(\"resolutionWidth\"),\n            \"resolutionHeight\": instance.context.data.get(\"resolutionHeight\"),\n        }\n        self.log.debug(\"current scene settings {}\".format(current_settings))\n\n        invalid_settings = []\n        invalid_keys = set()\n        for key, value in expected_settings.items():\n            if value != current_settings[key]:\n                invalid_settings.append(\n                    f\"{key} expected: {value}  found: {current_settings[key]}\"\n                )\n                invalid_keys.add(key)\n\n        if (\n            (\n                expected_settings[\"handleStart\"]\n                or expected_settings[\"handleEnd\"]\n            )\n            and invalid_settings\n        ):\n            self.log.info(\n                \"Handles included in calculation. Remove handles in DB\"\n                \" or extend frame range in timeline.\\n\"\n            )\n\n        msg = \"Found invalid settings:\\n{}\".format(\n            json.dumps(invalid_settings, sort_keys=True, indent=4)\n        )\n\n        if invalid_settings:\n            invalid_keys_str = \",\".join(invalid_keys)\n            invalid_setting_str = (\n                \"&lt;b&gt;Found invalid settings:&lt;/b&gt;&lt;br/&gt;{}\".format(\n                    \"&lt;br/&gt;\".join(invalid_settings)\n                )\n            )\n\n            formatting_data = {\n                \"invalid_setting_str\": invalid_setting_str,\n                \"invalid_keys_str\": invalid_keys_str\n            }\n            raise PublishXmlValidationError(\n                self, msg, formatting_data=formatting_data\n            )\n\n        scene_url = instance.context.data.get(\"scenePath\")\n        if not os.path.exists(scene_url):\n            msg = \"Scene file {} not found (saved under wrong name)\".format(\n                scene_url\n            )\n            formatting_data = {\n                \"scene_url\": scene_url\n            }\n            raise PublishXmlValidationError(\n                self,\n                msg,\n                key=\"file_not_found\",\n                formatting_data=formatting_data\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_scene_settings.html#client.ayon_harmony.plugins.publish.validate_scene_settings.ValidateSceneSettings.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_harmony/plugins/publish/validate_scene_settings.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    if not self.is_active(instance.data):\n        return\n\n    # TODO 'get_current_context_settings' could expect folder entity\n    #   as an argument which is available on 'context.data[\"folderEntity\"]'\n    #   - the same approach can be used in 'ValidateSceneSettingsRepair'\n    expected_settings = harmony.get_current_context_settings()\n    self.log.debug(f\"Scene settings from DB:{expected_settings}\")\n\n    _update_frames(expected_settings)\n    expected_settings[\"frameEndHandle\"] = (\n        expected_settings[\"frameEnd\"] + expected_settings[\"handleEnd\"]\n    )\n\n    task_name = instance.context.data[\"task\"]\n\n    if any(\n        re.search(pattern, task_name)\n        for pattern in self.skip_resolution_check\n    ):\n        self.log.info(\n            \"Skipping resolution check because of task name\"\n            f\" and pattern {self.skip_resolution_check}\"\n        )\n        expected_settings.pop(\"resolutionWidth\")\n        expected_settings.pop(\"resolutionHeight\")\n\n    if any(\n        re.search(pattern, task_name)\n        for pattern in self.skip_timelines_check\n    ):\n        self.log.info(\n            \"Skipping frames check because of task name\"\n            f\" and pattern {self.skip_timelines_check}\"\n        )\n        expected_settings.pop(\"frameStart\", None)\n        expected_settings.pop(\"frameEnd\", None)\n        expected_settings.pop(\"frameStartHandle\", None)\n        expected_settings.pop(\"frameEndHandle\", None)\n\n    folder_name = instance.context.data[\"folderPath\"].rsplit(\"/\", 1)[-1]\n    if any(re.search(pattern, folder_name)\n            for pattern in self.frame_check_filter):\n        self.log.info(\n            \"Skipping frames check because of task name\"\n            f\" and pattern {self.frame_check_filter}\"\n        )\n        expected_settings.pop('frameStart', None)\n        expected_settings.pop('frameEnd', None)\n        expected_settings.pop('frameStartHandle', None)\n        expected_settings.pop('frameEndHandle', None)\n\n    # handle case when fps uses only two decimal places\n    # 23.976023976023978 vs. 23.98\n    fps = instance.context.data.get(\"frameRate\")\n    if isinstance(instance.context.data.get(\"frameRate\"), float):\n        fps = float(\n            \"{:.2f}\".format(instance.context.data.get(\"frameRate\")))\n\n    self.log.debug(\"filtered settings: {}\".format(expected_settings))\n\n    current_settings = {\n        \"fps\": fps,\n        \"frameStart\": instance.context.data[\"frameStart\"],\n        \"frameEnd\": instance.context.data[\"frameEnd\"],\n        \"handleStart\": instance.context.data.get(\"handleStart\"),\n        \"handleEnd\": instance.context.data.get(\"handleEnd\"),\n        \"frameStartHandle\": instance.context.data.get(\"frameStartHandle\"),\n        \"frameEndHandle\": instance.context.data.get(\"frameEndHandle\"),\n        \"resolutionWidth\": instance.context.data.get(\"resolutionWidth\"),\n        \"resolutionHeight\": instance.context.data.get(\"resolutionHeight\"),\n    }\n    self.log.debug(\"current scene settings {}\".format(current_settings))\n\n    invalid_settings = []\n    invalid_keys = set()\n    for key, value in expected_settings.items():\n        if value != current_settings[key]:\n            invalid_settings.append(\n                f\"{key} expected: {value}  found: {current_settings[key]}\"\n            )\n            invalid_keys.add(key)\n\n    if (\n        (\n            expected_settings[\"handleStart\"]\n            or expected_settings[\"handleEnd\"]\n        )\n        and invalid_settings\n    ):\n        self.log.info(\n            \"Handles included in calculation. Remove handles in DB\"\n            \" or extend frame range in timeline.\\n\"\n        )\n\n    msg = \"Found invalid settings:\\n{}\".format(\n        json.dumps(invalid_settings, sort_keys=True, indent=4)\n    )\n\n    if invalid_settings:\n        invalid_keys_str = \",\".join(invalid_keys)\n        invalid_setting_str = (\n            \"&lt;b&gt;Found invalid settings:&lt;/b&gt;&lt;br/&gt;{}\".format(\n                \"&lt;br/&gt;\".join(invalid_settings)\n            )\n        )\n\n        formatting_data = {\n            \"invalid_setting_str\": invalid_setting_str,\n            \"invalid_keys_str\": invalid_keys_str\n        }\n        raise PublishXmlValidationError(\n            self, msg, formatting_data=formatting_data\n        )\n\n    scene_url = instance.context.data.get(\"scenePath\")\n    if not os.path.exists(scene_url):\n        msg = \"Scene file {} not found (saved under wrong name)\".format(\n            scene_url\n        )\n        formatting_data = {\n            \"scene_url\": scene_url\n        }\n        raise PublishXmlValidationError(\n            self,\n            msg,\n            key=\"file_not_found\",\n            formatting_data=formatting_data\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_scene_settings.html#client.ayon_harmony.plugins.publish.validate_scene_settings.ValidateSceneSettingsRepair","title":"<code>ValidateSceneSettingsRepair</code>","text":"<p>               Bases: <code>Action</code></p> <p>Repair the instance.</p> Source code in <code>client/ayon_harmony/plugins/publish/validate_scene_settings.py</code> <pre><code>class ValidateSceneSettingsRepair(pyblish.api.Action):\n    \"\"\"Repair the instance.\"\"\"\n\n    label = \"Repair\"\n    icon = \"wrench\"\n    on = \"failed\"\n\n    def process(self, context, plugin):\n        \"\"\"Repair action entry point.\"\"\"\n        expected = harmony.get_current_context_settings()\n        expected_settings = _update_frames(dict.copy(expected))\n        expected_settings[\"frameStart\"] = 1\n        expected_settings[\"frameEnd\"] = (\n            expected_settings[\"frameEnd\"] + expected_settings[\"handleEnd\"]\n        )\n        harmony.set_scene_settings(expected_settings)\n        if not os.path.exists(context.data[\"scenePath\"]):\n            self.log.info(\"correcting scene name\")\n            scene_dir = os.path.dirname(context.data[\"currentFile\"])\n            scene_path = os.path.join(\n                scene_dir, os.path.basename(scene_dir) + \".xstage\"\n            )\n            harmony.save_scene_as(scene_path)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/plugins/publish/validate_scene_settings.html#client.ayon_harmony.plugins.publish.validate_scene_settings.ValidateSceneSettingsRepair.process","title":"<code>process(context, plugin)</code>","text":"<p>Repair action entry point.</p> Source code in <code>client/ayon_harmony/plugins/publish/validate_scene_settings.py</code> <pre><code>def process(self, context, plugin):\n    \"\"\"Repair action entry point.\"\"\"\n    expected = harmony.get_current_context_settings()\n    expected_settings = _update_frames(dict.copy(expected))\n    expected_settings[\"frameStart\"] = 1\n    expected_settings[\"frameEnd\"] = (\n        expected_settings[\"frameEnd\"] + expected_settings[\"handleEnd\"]\n    )\n    harmony.set_scene_settings(expected_settings)\n    if not os.path.exists(context.data[\"scenePath\"]):\n        self.log.info(\"correcting scene name\")\n        scene_dir = os.path.dirname(context.data[\"currentFile\"])\n        scene_path = os.path.join(\n            scene_dir, os.path.basename(scene_dir) + \".xstage\"\n        )\n        harmony.save_scene_as(scene_path)\n</code></pre>"},{"location":"autoapi/client/ayon_harmony/vendor/index.html","title":"vendor","text":""},{"location":"autoapi/client/ayon_harmony/vendor/OpenHarmony/index.html","title":"OpenHarmony","text":""},{"location":"autoapi/client/ayon_harmony/vendor/OpenHarmony/openHarmony/index.html","title":"openHarmony","text":""},{"location":"autoapi/client/ayon_harmony/vendor/OpenHarmony/openHarmony/classes/index.html","title":"classes","text":""},{"location":"autoapi/client/ayon_harmony/vendor/OpenHarmony/reference/index.html","title":"reference","text":""},{"location":"autoapi/client/ayon_harmony/vendor/OpenHarmony/tools/index.html","title":"tools","text":""},{"location":"autoapi/client/ayon_harmony/vendor/OpenHarmony/tools/OpenHarmony_basic/index.html","title":"OpenHarmony_basic","text":""},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/index.html#server.settings.HarmonySettings","title":"<code>HarmonySettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Harmony Project Settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class HarmonySettings(BaseSettingsModel):\n    \"\"\"Harmony Project Settings.\"\"\"\n\n    imageio: HarmonyImageIOModel = SettingsField(\n        default_factory=HarmonyImageIOModel,\n        title=\"OCIO config\"\n    )\n    create: HarmonyCreatePlugins = SettingsField(\n        default_factory=HarmonyCreatePlugins,\n        title=\"Creator plugins\"\n    )\n    publish: HarmonyPublishPlugins = SettingsField(\n        default_factory=HarmonyPublishPlugins,\n        title=\"Publish plugins\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html","title":"creator_plugins","text":""},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.AutoDetectCreateRenderModel","title":"<code>AutoDetectCreateRenderModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>The creator to auto-detect Render Layers and Render Passes in scene.</p> <p>For Render Layers is used group name as a variant and for Render Passes is used Harmony  layer name.</p> <p>Group names are renamed by their used order in scene. The renaming template where can be used '{group_index}' formatting key which is filled by \"used position index of group\". - Template: 'G{group_index}' - Group offset: '10' - Group padding: '3'</p> <p>Would create group names \"G010\", \"G020\", ...</p> <p>If this plugin is enabled, both 'CreateRenderLayer' and 'CreateRenderPass' must be enabled!</p> <p>To fully use this make sure settings in core addon (ayon+settings://core/tools/creator/product_name_profiles) are set to '{product[type]}{Task[name]}{Renderlayer}{Renderpass}' for host 'harmony' and product types: ['renderLayer', 'renderPass']!</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>class AutoDetectCreateRenderModel(BaseSettingsModel):\n    \"\"\"The creator to auto-detect Render Layers and Render Passes in scene.\n\n    For Render Layers is used group name as a variant and for Render Passes is\n    used Harmony  layer name.\n\n    Group names are renamed by their used order in scene. The renaming\n    template where can be used '{group_index}' formatting key which is\n    filled by \"used position index of group\".\n    - Template: 'G{group_index}'\n    - Group offset: '10'\n    - Group padding: '3'\n\n    Would create group names \"G010\", \"G020\", ...\n\n    If this plugin is enabled, both 'CreateRenderLayer' and 'CreateRenderPass'\n    must be enabled!\n\n    To fully use this make sure settings in core addon\n    (ayon+settings://core/tools/creator/product_name_profiles) are\n    set to '{product[type]}{Task[name]}_{Renderlayer}_{Renderpass}' for\n    host 'harmony' and product types: ['renderLayer', 'renderPass']!\n    \"\"\"\n\n    enabled: bool = SettingsField()\n    render_layer_variant_template: str = SettingsField(\n        title=\"Render layer variant template\",\n        description=\"Calculate variant for Render Layer\"\n    )\n    group_idx_offset: int = SettingsField(\n        10, title=\"Group index Offset\", ge=1\n    )\n    group_idx_padding: int = SettingsField(\n        3, title=\"Group index Padding\", ge=0\n    )\n    layer_name_template: LayerNameTemplateModel = SettingsField(\n        default_factory=LayerNameTemplateModel,\n        title=\"Layer name template\",\n        description=(\n            \"Final layer template to parse out variant from\"\n            \" already renamed layers or\"\n        ),\n    )\n</code></pre>"},{"location":"autoapi/server/settings/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/main.html#server.settings.main.HarmonySettings","title":"<code>HarmonySettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Harmony Project Settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class HarmonySettings(BaseSettingsModel):\n    \"\"\"Harmony Project Settings.\"\"\"\n\n    imageio: HarmonyImageIOModel = SettingsField(\n        default_factory=HarmonyImageIOModel,\n        title=\"OCIO config\"\n    )\n    create: HarmonyCreatePlugins = SettingsField(\n        default_factory=HarmonyCreatePlugins,\n        title=\"Creator plugins\"\n    )\n    publish: HarmonyPublishPlugins = SettingsField(\n        default_factory=HarmonyPublishPlugins,\n        title=\"Publish plugins\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html","title":"publish_plugins","text":""},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.CollectPalettesPlugin","title":"<code>CollectPalettesPlugin</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Set regular expressions to filter triggering on specific task names. '.*' means on all.</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class CollectPalettesPlugin(BaseSettingsModel):\n    \"\"\"Set regular expressions to filter triggering on specific task names. '.*' means on all.\"\"\"  # noqa\n\n    allowed_tasks: list[str] = SettingsField(\n        default_factory=list,\n        title=\"Allowed tasks\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.ExtractConvertToEXRModel","title":"<code>ExtractConvertToEXRModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>WARNING: This plugin does not work on MacOS (using OIIO tool).</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class ExtractConvertToEXRModel(BaseSettingsModel):\n    \"\"\"WARNING: This plugin does not work on MacOS (using OIIO tool).\"\"\"\n    enabled: bool = False\n    replace_pngs: bool = SettingsField(\n        True,\n        title=\"Replace original PNG files\",\n        description=\"Remove original PNG files after transcoding to EXR\",\n    )\n    auto_trim: bool = SettingsField(\n        True,\n        title=\"Auto Trim\",\n    )\n    exr_compression: str = SettingsField(\n        \"ZIP\",\n        enum_resolver=compression_enum,\n        title=\"EXR Compression\"\n    )\n    multichannel_exr: bool = SettingsField(\n        False,\n        title=\"Create multichannel EXR\",\n        description=\"Merge render passes into a render layer EXR files\",\n    )\n    keep_passes: bool = SettingsField(\n        False,\n        title=\"Keep render passes\",\n        description=(\n            \"Keep render passes even though multichannel EXR is enabled\"\n        ),\n    )\n    user_overrides: list[str] = SettingsField(\n        default_factory=list,\n        title=\"User overrides\",\n        description=\"Allow user to change the plugin functionality\",\n        enum_resolver=user_exr_choices,\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.ValidateAudioPlugin","title":"<code>ValidateAudioPlugin</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Check if scene contains audio track.</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class ValidateAudioPlugin(BaseSettingsModel):\n    \"\"\"Check if scene contains audio track.\"\"\"  #\n    _isGroup = True\n    enabled: bool = True\n    optional: bool = SettingsField(True, title=\"Optional\")\n    active: bool = SettingsField(True, title=\"Active\")\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.ValidateInstancePlugin","title":"<code>ValidateInstancePlugin</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Validate if instance folder is the current folder.</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class ValidateInstancePlugin(BaseSettingsModel):\n    \"\"\"Validate if instance folder is the current folder.\"\"\"\n    enabled: bool = True\n    optional: bool = SettingsField(False, title=\"Optional\")\n    active: bool = SettingsField(True, title=\"Active\")\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.ValidateSceneSettingsPlugin","title":"<code>ValidateSceneSettingsPlugin</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Validate if FrameStart, FrameEnd and Resolution match shot data in DB. Use regular expressions to limit validations only on particular folder or task names.</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class ValidateSceneSettingsPlugin(BaseSettingsModel):\n    \"\"\"Validate if FrameStart, FrameEnd and Resolution match shot data in DB.\n       Use regular expressions to limit validations only on particular folder\n       or task names.\"\"\"\n    _isGroup = True\n    enabled: bool = True\n    optional: bool = SettingsField(False, title=\"Optional\")\n    active: bool = SettingsField(True, title=\"Active\")\n\n    frame_check_filter: list[str] = SettingsField(\n        default_factory=list,\n        title=\"Skip Frame check for Folder Paths with name containing\"\n    )\n\n    skip_resolution_check: list[str] = SettingsField(\n        default_factory=list,\n        title=\"Skip Resolution Check for Tasks\"\n    )\n\n    skip_timelines_check: list[str] = SettingsField(\n        default_factory=list,\n        title=\"Skip Timeline Check for Tasks\"\n    )\n</code></pre>"}]}